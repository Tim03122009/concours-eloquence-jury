<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="description" content="Tableau de bord administrateur - Gestion des r√©sultats du concours">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <title>üèÜ Administration - R√©sultats Concours</title>
    <style>
        /* Modern Admin Dashboard Styles - Responsive */
        :root {
            /* Light Mode (Default) */
            --primary: #007bff;
            --success: #28a745;
            --warning: #ffc107;
            --danger: #dc3545;
            --danger-color: #dc3545;
            --danger-dark: #c82333;
            --neutral: #6c757d;
            --neutral-color: #6c757d;
            --white: #ffffff;
            --text-color: #333;
            --text-secondary: #666;
            --border-color: #ddd;
            --bg-gradient-start: #667eea;
            --bg-gradient-end: #764ba2;
            --card-bg: #ffffff;
            --input-bg: #ffffff;
            --info-bg-start: #e3f2fd;
            --info-bg-end: #bbdefb;
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 8px rgba(0,0,0,0.12);
            --shadow-lg: 0 8px 16px rgba(0,0,0,0.15);
            --radius: 10px;
            --spacing: 20px;
        }

        /* Dark Mode */
        [data-theme="dark"] {
            --primary: #4da3ff;
            --success: #4caf50;
            --warning: #ffa726;
            --danger: #f44336;
            --danger-color: #f44336;
            --danger-dark: #d32f2f;
            --neutral: #9e9e9e;
            --neutral-color: #9e9e9e;
            --white: #ffffff;
            --text-color: #e0e0e0;
            --text-secondary: #b0b0b0;
            --border-color: #444;
            --bg-gradient-start: #3d5266;
            --bg-gradient-end: #1a252f;
            --card-bg: #2d2d3a;
            --input-bg: #3a3a4a;
            --info-bg-start: #1e3a5f;
            --info-bg-end: #2c4f7c;
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.5);
        }

        * {
            box-sizing: border-box;
        }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            padding: clamp(12px, 3vw, 20px);
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            margin: 0;
            min-height: 100vh;
            line-height: 1.6;
            transition: background 0.3s ease;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--card-bg);
            padding: clamp(15px, 4vw, 40px);
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            position: relative;
        }

        h1 { 
            color: var(--primary);
            border-bottom: 3px solid var(--primary);
            padding-bottom: 15px;
            margin-top: 0;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            font-weight: 700;
        }

        h2 { 
            color: var(--primary);
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
            margin-top: var(--spacing);
            font-size: clamp(1.2rem, 3vw, 1.8rem);
            font-weight: 600;
        }

        /* Action Buttons */
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: var(--spacing);
        }

        .action-button { 
            padding: clamp(10px, 2vw, 14px) clamp(16px, 3vw, 24px);
            font-size: clamp(0.95rem, 2vw, 1.1rem);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-sm);
            flex: 1 1 auto;
            min-width: 140px;
        }

        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .action-button:active {
            transform: translateY(0);
        }

        .load-button { 
            background: linear-gradient(135deg, var(--success) 0%, #1e7e34 100%);
            color: white;
        }

        .export-button { 
            background: linear-gradient(135deg, var(--warning) 0%, #e0a800 100%);
            color: #212529;
        }

        .export-button.excel { 
            background: linear-gradient(135deg, var(--primary) 0%, #0056b3 100%);
            color: white;
        }
        
        .import-button {
            background: linear-gradient(135deg, #ff8c00 0%, #ff6b00 100%) !important;
            color: white !important;
        }

        /* Candidate Zone */
        .candidate-zone { 
            margin-top: 10px;
            padding: clamp(15px, 3vw, 25px);
            border: 2px solid var(--border-color);
            background: var(--input-bg);
            border-radius: var(--radius);
            box-shadow: var(--shadow-sm);
        }

        .candidate-zone h2 {
            margin-top: 0;
            color: var(--primary);
        }

        .candidate-zone h3 {
            margin-top: 0;
            margin-bottom: 10px;
        }

        .candidate-zone textarea { 
            width: 100%;
            min-height: 120px;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-family: inherit;
            font-size: clamp(0.95rem, 2vw, 1.05rem);
            transition: all 0.3s ease;
            resize: vertical;
            background: var(--card-bg);
            color: var(--text-color);
        }

        .candidate-zone textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
        }

        /* Tables */
        .table-container {
            overflow-x: auto;
            overflow-y: visible;
            max-width: 100%;
            margin: var(--spacing) 0;
            border-radius: var(--radius);
            box-shadow: var(--shadow-md);
            /* Permettre le d√©filement horizontal pour les tableaux avec beaucoup de colonnes */
            -webkit-overflow-scrolling: touch;
        }
        
        /* S'assurer que les tableaux ne sont pas tronqu√©s */
        .table-container table {
            min-width: max-content;
        }

        #scores-matrix { 
            width: 100%;
            border-collapse: collapse;
            background: var(--card-bg);
            font-size: clamp(0.8rem, 1.5vw, 0.95rem);
        }

        #scores-matrix th, #scores-matrix td { 
            border: 1px solid var(--border-color);
            padding: clamp(8px, 2vw, 12px);
            text-align: center;
            color: var(--text-color);
        }

        #scores-matrix th { 
            background: var(--input-bg);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            color: var(--text-color);
            cursor: pointer;
            user-select: none;
        }
        
        #scores-matrix th:hover {
            background: var(--border-color);
        }
        
        #scores-matrix th.sorted-asc::after {
            content: ' ‚ñ≤';
            font-size: 0.7em;
        }
        
        #scores-matrix th.sorted-desc::after {
            content: ' ‚ñº';
            font-size: 0.7em;
        }

        .detail-note { 
            font-size: 0.85em;
            color: var(--text-secondary);
            display: block;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 3px;
            margin-bottom: 5px;
        }

        .weighted-total { 
            font-weight: bold;
            color: var(--primary);
            font-size: 1.1em;
        }

        .total-score { 
            background: linear-gradient(135deg, #ffc107 0%, #ffb300 100%);
            font-weight: bold;
            font-size: 1.15em;
            color: #212529;
        }

        .eliminado { 
            background: linear-gradient(135deg, var(--danger) 0%, #c82333 100%);
            color: white;
            font-weight: 600;
        }

        /* Podium Table */
        #podium-table { 
            width: 100%;
            max-width: 800px;
            border-collapse: collapse;
            background: var(--card-bg);
            box-shadow: var(--shadow-md);
            border-radius: var(--radius);
            overflow: hidden;
        }

        #podium-table th, #podium-table td { 
            border: 1px solid var(--border-color);
            padding: clamp(10px, 2.5vw, 15px);
            text-align: center;
            color: var(--text-color);
        }

        #podium-table th {
            background: var(--neutral-color);
            color: var(--white);
            font-weight: 600;
        }

        #podium-table td {
            color: var(--text-color);
        }

        .rank-1 { 
            background: linear-gradient(135deg, gold 0%, #ffed4e 100%);
            font-weight: bold;
            font-size: 1.1em;
        }
        
        .rank-1 td {
            color: #212529 !important;
        }

        .rank-2 { 
            background: linear-gradient(135deg, silver 0%, #e0e0e0 100%);
            font-weight: bold;
            font-size: 1.05em;
        }
        
        .rank-2 td {
            color: #212529 !important;
        }

        .rank-3 { 
            background: linear-gradient(135deg, #cd7f32 0%, #b87333 100%);
            font-weight: bold;
        }
        
        .rank-3 td {
            color: white !important;
        }

        .eliminated-row { 
            background: linear-gradient(135deg, var(--neutral) 0%, #5a6268 100%);
            color: white;
            opacity: 0.8;
        }

        /* Reset Zone */
        .reset-zone { 
            margin-top: 50px;
            padding: clamp(15px, 3vw, 25px);
            border: 3px solid var(--danger-color);
            background: rgba(220, 53, 69, 0.1);
            border-radius: var(--radius);
            box-shadow: var(--shadow-sm);
        }

        .reset-zone h2 {
            color: var(--danger-color);
            margin-top: 0;
        }
        
        .reset-zone p {
            color: var(--text-color);
        }

        .reset-zone .action-button {
            background: linear-gradient(135deg, var(--danger-color) 0%, var(--danger-dark) 100%);
            color: white;
        }

        hr {
            border: none;
            border-top: 2px solid var(--border-color);
            margin: calc(var(--spacing) * 1.5) 0;
        }

        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            gap: 5px;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: var(--spacing);
            flex-wrap: wrap;
        }

        .tab-btn {
            padding: 12px 24px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .tab-btn:hover {
            color: var(--primary);
            background: rgba(0, 123, 255, 0.05);
        }

        .tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Candidate Table */
        .candidate-table {
            width: 100%;
            border-collapse: collapse;
            margin: var(--spacing) 0;
        }

        .candidate-table th,
        .candidate-table td {
            border: 1px solid var(--border-color);
            padding: 12px;
            text-align: left;
            color: var(--text-color);
        }

        .candidate-table th {
            background: var(--input-bg);
            font-weight: 600;
            color: var(--text-color);
        }

        .candidate-table input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background: var(--card-bg);
            color: var(--text-color);
            font-family: inherit;
        }

        .candidate-table .actions {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2em;
            padding: 4px 8px;
            transition: all 0.3s ease;
        }

        .icon-btn:hover {
            transform: scale(1.2);
        }

        .icon-btn.delete {
            color: var(--danger-color);
        }

        .icon-btn.reset {
            color: var(--warning);
        }

        .icon-btn.lock {
            color: var(--neutral-color);
        }

        .icon-btn.lock.locked {
            color: var(--danger-color);
        }

        /* Notes Table */
        .notes-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
            table-layout: auto;
        }
        
        #notes-table {
            width: max-content;
            min-width: 100%;
        }

        .notes-table th,
        .notes-table td {
            border: 1px solid var(--border-color);
            padding: 8px;
            text-align: center;
            overflow: visible;
            color: var(--text-color);
        }

        .notes-table th {
            background: var(--input-bg);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            color: var(--text-color);
        }

        .notes-table select {
            width: 100%;
            min-width: 80px;
            max-width: 90px;
            padding: 6px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: var(--card-bg);
            color: var(--text-color);
            text-align: center;
            font-size: 14px;
            font-family: inherit;
        }

        .notes-table .candidate-name {
            text-align: left;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .notes-table .locked-cell {
            background: rgba(220, 53, 69, 0.1);
        }

        .notes-table .col-actions {
            width: 100px;
        }

        .notes-table .col-candidate {
            width: 150px;
        }

        .notes-table .col-score {
            min-width: 90px;
            width: 90px;
            text-align: center;
        }

        /* Burger Menu & Theme Toggle */
        .burger-menu {
            position: absolute;
            top: var(--spacing);
            right: var(--spacing);
            z-index: 9999;
        }

        .burger-icon {
            width: 36px;
            height: 36px;
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 4px;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-sm);
        }

        .burger-icon:hover {
            box-shadow: var(--shadow-md);
        }

        .burger-icon span {
            width: 20px;
            height: 2px;
            background: var(--text-color);
            transition: all 0.3s ease;
        }

        .burger-menu-content {
            position: absolute;
            top: 45px;
            right: 0;
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 5px;
            box-shadow: var(--shadow-lg);
            padding: 0;
            min-width: 200px;
            display: none;
            overflow: hidden;
            z-index: 10000;
        }

        .burger-menu-content.active {
            display: block;
        }

        .burger-menu-content > * {
            padding: 12px;
        }

        .burger-menu-content > *:not(:last-child) {
            border-bottom: 1px solid var(--border-color);
        }

        .theme-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: var(--text-color);
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: var(--neutral-color);
            border-radius: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-switch.active {
            background: var(--primary);
        }

        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(24px);
        }

        .menu-item {
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 12px;
            color: var(--text-color);
            border: none;
            background: transparent;
            width: 100%;
            text-align: left;
            font-size: clamp(0.9rem, 2vw, 1rem);
            font-family: inherit;
            margin: 0;
        }

        .menu-item:hover {
            background: var(--info-bg-start, rgba(0, 123, 255, 0.1));
        }

        #menu-content .menu-item {
            padding: 12px;
        }

        /* Responsive Design */
        @media (max-width: 767px) {
            .button-group {
                flex-direction: column;
            }

            .action-button {
                width: 100%;
                min-width: unset;
            }

            #scores-matrix {
                font-size: 0.75rem;
            }

            #scores-matrix th,
            #scores-matrix td {
                padding: 6px;
            }

            #podium-table {
                font-size: 0.85rem;
            }
        }

        @media (min-width: 768px) and (max-width: 1023px) {
            .button-group {
                justify-content: flex-start;
            }

            .action-button {
                flex: 0 1 calc(50% - 6px);
            }
        }

        @media (min-width: 1024px) {
            .action-button {
                flex: 0 1 auto;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .action-button {
                min-height: 44px;
            }
        }

        /* Print styles */
        @media print {
            body {
                background: white;
            }

            .container {
                box-shadow: none;
            }

            .candidate-zone,
            .reset-zone,
            .action-button {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="burger-menu">
            <div class="burger-icon" onclick="toggleMenu()">
                <span></span>
                <span></span>
                <span></span>
            </div>
            <div class="burger-menu-content" id="menu-content">
                <div class="theme-toggle">
                    <span>Mode sombre</span>
                    <div class="toggle-switch" id="theme-toggle" onclick="toggleTheme()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
                <div class="menu-item" onclick="showPasswordModal()">
                    <span>Changer le mot de passe</span>
                </div>
                <div class="menu-item" onclick="adminLogout()" style="color: var(--danger-color); font-weight: 600;">
                    <span>D√©connexion</span>
                </div>
            </div>
        </div>

    <h1>Tableau de bord Administrateur</h1>
    
        <!-- Tab Navigation -->
        <div class="tab-navigation">
            <button class="tab-btn active" onclick="switchTab('candidats')">Candidats</button>
            <button class="tab-btn" onclick="switchTab('jury')">Jury</button>
            <button class="tab-btn" onclick="switchTab('tours')">Tours</button>
            <button class="tab-btn" onclick="switchTab('notes')">Notes</button>
            <button class="tab-btn" onclick="switchTab('podium')">Podium</button>
            <button class="tab-btn" onclick="switchTab('reinitialiser')">R√©initialiser</button>
        </div>

        <!-- TAB 1: CANDIDATS -->
        <div id="tab-candidats" class="tab-content active">
    <div class="candidate-zone">
                <h3 style="color: var(--text-color);">Import rapide (copier-coller)</h3>
                <p style="color: var(--text-color); font-size: 0.9em; margin: 5px 0;">Les candidats de la liste seront <strong>ajout√©s</strong> aux candidats existants (pas de remplacement).</p>
                <textarea id="candidate-names" placeholder="Un nom par ligne...&#10;Exemple:&#10;Alice Martin&#10;Bob Dupont&#10;Claire Bernard"></textarea>
                <div style="display: flex; align-items: center; gap: 8px; margin: 10px 0;">
                    <input type="checkbox" id="random-ids-checkbox" style="width: 18px; height: 18px; cursor: pointer;">
                    <label for="random-ids-checkbox" style="color: var(--text-color); cursor: pointer; font-size: 0.95em;">D√©finir des IDs al√©atoires (sinon 001, 002, 003...)</label>
                </div>
                <button onclick="importCandidates()" class="action-button" style="background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); color:white;">Ajouter les nouveaux candidats</button>
    </div>

            <h3 style="color: var(--text-color);">Liste des candidats</h3>
            <button onclick="addCandidate()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); color:white;">+ Ajouter un candidat</button>
            
            <table class="candidate-table" id="candidate-table">
                <thead>
                    <tr>
                        <th style="width: 80px;">ID</th>
                        <th>Nom du candidat</th>
                        <th style="width: 100px;">Actions</th>
                    </tr>
                </thead>
                <tbody id="candidate-table-body">
                    <!-- Rempli dynamiquement -->
                </tbody>
            </table>
    </div>

        <!-- TAB 2: JURY -->
        <div id="tab-jury" class="tab-content">
            <div class="candidate-zone" style="background: var(--primary-light, #e3f2fd); border: 2px solid var(--primary-color, #2196f3); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <h3 style="color: var(--primary-color, #1565c0);">üîë Mot de passe par d√©faut</h3>
                <p style="color: var(--text-color); font-size: 0.9em; margin: 5px 0;">Ce mot de passe sera requis pour cr√©er un nouveau compte jury et sera d√©fini par d√©faut lors de la cr√©ation.</p>
                <div style="display: flex; gap: 10px; align-items: center; margin-top: 10px;">
                    <input type="text" id="default-jury-password" placeholder="Mot de passe par d√©faut" style="flex: 1; padding: 10px; border: 2px solid var(--primary-color, #2196f3); border-radius: 6px; background: var(--input-bg); color: var(--text-color); font-size: 1em;">
                    <button onclick="saveDefaultJuryPassword()" class="action-button" style="background: linear-gradient(135deg, #2196f3 0%, #1565c0 100%); color: white;">üíæ Enregistrer</button>
                </div>
                <p style="color: var(--text-secondary); font-size: 0.85em; margin-top: 8px;">üí° Astuce : Communiquez ce mot de passe aux jurys avant le concours.</p>
            </div>
            
            <div class="candidate-zone">
                <h3 style="color: var(--text-color);">Import rapide (copier-coller)</h3>
                <p style="color: var(--text-color); font-size: 0.9em; margin: 5px 0;">Les jurys de la liste seront <strong>ajout√©s</strong> aux jurys existants (pas de remplacement).</p>
                <textarea id="jury-names" placeholder="Un nom par ligne...&#10;Exemple:&#10;Pierre Dubois&#10;Marie Martin&#10;Jacques Bernard"></textarea>
                <button onclick="importJuries()" class="action-button" style="background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); color:white;">Ajouter les nouveaux jurys</button>
            </div>

            <h3 style="color: var(--text-color);">Liste des jurys</h3>
            <button onclick="addJury()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); color:white;">+ Ajouter un jury</button>
            
            <table class="candidate-table" id="jury-table">
                <thead>
                    <tr>
                        <th style="width: 60px;">ID</th>
                        <th>Nom du jury</th>
                        <th style="width: 100px;">Mot de passe</th>
                        <th style="width: 150px;">Actions</th>
                    </tr>
                </thead>
                <tbody id="jury-table-body">
                    <!-- Rempli dynamiquement -->
                </tbody>
    </table>
        </div>

        <!-- TAB 3: TOURS -->
        <div id="tab-tours" class="tab-content">
            <p style="color: var(--text-secondary); margin-bottom: 20px;">
                D√©finissez les diff√©rents tours du concours. Chaque tour peut avoir un type diff√©rent.
            </p>
            
            <div style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">
                <button onclick="addRound()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); color:white;">+ Ajouter un tour</button>
                
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="active-round-select" style="color: var(--text-color); font-weight: 600;">Tour actif :</label>
                    <select id="active-round-select" onchange="setActiveRound(this.value)" style="padding: 8px 12px; border: 2px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-color); font-size: 1em; font-family: inherit; min-width: 200px;">
                        <!-- Rempli dynamiquement -->
                    </select>
                    <button onclick="finishRound()" class="action-button" style="background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); color:white; padding: 8px 16px;">‚úì Terminer le tour</button>
                </div>
            </div>
            
            <div class="table-container">
                <table class="notes-table" id="rounds-table">
                    <thead>
                        <tr>
                            <th style="width: 70px;">Actions</th>
                            <th style="width: 60px;">Ordre</th>
                            <th style="width: 20%;">Nom du tour</th>
                            <th style="min-width: 220px; width: 35%;">Type</th>
                            <th style="width: 140px;">Candidats suivants</th>
                        </tr>
                    </thead>
                    <tbody id="rounds-table-body">
                        <!-- Rempli dynamiquement -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- TAB 4: NOTES -->
        <div id="tab-notes" class="tab-content">
            <p style="color: var(--text-secondary); margin-bottom: 20px;">
                Modifiez les notes directement dans le tableau. Les modifications sont sauvegard√©es automatiquement.
            </p>
            
            <div style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 15px;">
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <label for="notes-round-select" style="color: var(--text-color); font-weight: 600;">Tour √† afficher :</label>
                        <select id="notes-round-select" onchange="changeNotesRound(this.value)" style="padding: 8px 12px; border: 2px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-color); font-size: 1em; font-family: inherit; min-width: 200px;">
                            <!-- Rempli dynamiquement -->
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="notes-filter-current-round" checked style="width: 18px; height: 18px; cursor: pointer;">
                        <label for="notes-filter-current-round" style="color: var(--text-color); cursor: pointer;">Candidats en cours sur ce tour</label>
                    </div>
                </div>
                
                <div class="button-group">
                    <button onclick="exportNotesToCSV()" class="action-button export-button excel">üì• Exporter en CSV</button>
                    <input type="file" id="csv-import-file" accept=".csv" style="display: none;" onchange="importNotesFromCSV(event)">
                    <button onclick="document.getElementById('csv-import-file').click()" class="action-button import-button">üì§ Importer depuis CSV</button>
                </div>
            </div>
            
            <div class="table-container">
                <table class="notes-table" id="notes-table">
                    <thead>
                        <tr>
                            <!-- En-t√™te g√©n√©r√© dynamiquement -->
                        </tr>
                    </thead>
                    <tbody id="notes-table-body">
                        <!-- Rempli dynamiquement -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- TAB 5: PODIUM -->
        <div id="tab-podium" class="tab-content">
    <h2>Classement Officiel</h2>
            
            <div style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="podium-round-select" style="color: var(--text-color); font-weight: 600;">Tour √† afficher :</label>
                    <select id="podium-round-select" onchange="changePodiumRound(this.value)" style="padding: 8px 12px; border: 2px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-color); font-size: 1em; font-family: inherit; min-width: 200px;">
                        <!-- Rempli dynamiquement -->
                    </select>
                </div>
                
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="result-limit" style="font-weight: 600; color: var(--text-color);">Nombre de candidats :</label>
                    <input type="number" id="result-limit" value="3" min="1" oninput="renderPodium()" style="width: 80px; padding: 8px; border: 2px solid var(--border-color); border-radius: 5px; background: var(--card-bg); color: var(--text-color);">
                    <button onclick="exportPodiumToImage()" class="action-button export-button">Exporter en image</button>
                </div>
            </div>
            
            <div style="margin-bottom: 20px; padding: 15px; background: var(--info-bg-start); border-radius: 8px; border: 1px solid var(--border-color);">
                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; color: var(--text-color);">
                    <input type="checkbox" id="show-podium-after-repechage" onchange="saveShowPodiumAfterRepechage(this.checked)" style="width: 18px; height: 18px; cursor: pointer;">
                    <span style="font-weight: 600;">üìä Afficher le podium au Pr√©sident apr√®s la validation du rep√™chage</span>
                </label>
                <p style="margin: 8px 0 0 28px; font-size: 0.9em; color: var(--text-muted);">
                    Si activ√©, le Pr√©sident verra le classement final apr√®s avoir valid√© les r√©sultats du rep√™chage.
                </p>
            </div>

            <div class="table-container">
    <table id="podium-table">
        <thead>
            <tr><th>Rang</th><th>Candidat</th><th>Score</th></tr>
        </thead>
        <tbody id="podium-body"></tbody>
    </table>
            </div>
        </div>

        <!-- TAB 7: REINITIALISER -->
        <div id="tab-reinitialiser" class="tab-content">
        <h2>Zone de Danger</h2>
            <p style="color: var(--danger-color); font-weight: 600; margin-bottom: 20px;">
                ‚ö†Ô∏è Attention: Ces actions sont irr√©versibles !
            </p>

            <div class="reset-zone" style="background: var(--info-bg-start); border: 2px solid var(--primary);">
                <h3 style="color: var(--primary);">üîß Utilitaires</h3>
                <p>V√©rifier et nettoyer la base de donn√©es : supprime les doublons, les scores orphelins (candidats/jurys supprim√©s), et les valeurs calcul√©es obsol√®tes.</p>
                <p style="font-weight: 600; color: var(--warning-color); margin-top: 10px;">‚ö†Ô∏è Recommand√© : Sauvegardez votre base de donn√©es avant de lancer cette op√©ration.</p>
                <button onclick="cleanDatabase()" class="action-button" style="background: var(--primary);">Nettoyer la base de donn√©es</button>
            </div>

            <div class="reset-zone" style="background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%); border: 2px solid #ffc107;">
                <h3 style="color: #856404;">üß™ Tests</h3>
                <p style="color: #212529;">Ins√©rer des candidats et jurys de test pour simuler rapidement un concours.</p>
                <button onclick="insertTestData()" class="action-button" style="background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%); color: #212529; margin-bottom: 10px;">üìã Ins√©rer candidats et jurys de test</button>
                
                <p style="color: #212529; margin-top: 15px;">Auto-remplir les notes des candidats actifs du tour en cours avec des <strong>notes al√©atoires de test (5, 10, 15 ou 20)</strong>.</p>
                <p style="font-weight: 600; color: #856404; margin-top: 10px;">‚ö†Ô∏è Les candidats seront <strong>qualifi√©s ou √©limin√©s</strong> selon leur classement et la limite "Candidats suivants" du tour actif.</p>
                <button onclick="autoFillActiveRound()" class="action-button" style="background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%); color: #212529;">‚úì Auto-remplir et qualifier le tour actif</button>
            </div>

            <div class="reset-zone" style="background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); border: 2px solid #28a745;">
                <h3 style="color: #1e7e34;">üíæ Sauvegarde & Restauration</h3>
                <p style="color: #212529;">T√©l√©charger toutes les donn√©es (candidats, scores, verrous, configuration) en format JSON.</p>
                <button onclick="downloadDatabase()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); color: white;">üì• T√©l√©charger la base de donn√©es</button>
                
                <p style="margin-top: 15px; color: #212529;">Restaurer les donn√©es depuis un fichier JSON de sauvegarde.</p>
                <input type="file" id="db-upload-file" accept=".json" style="display: none;" onchange="uploadDatabase(event)">
                <button onclick="document.getElementById('db-upload-file').click()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); color: white;">üì§ Restaurer depuis un fichier</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">Supprimer TOUS les jurys</h3>
                <p>Supprime tous les comptes jurys ET toutes leurs notations (mais conserve la liste des candidats).</p>
                <button onclick="confirmDeleteAllJuries()" class="action-button" style="background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); color: white;">Supprimer tous les jurys</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">R√©initialiser les scores</h3>
                <p>Remet toutes les notations √† "-" mais conserve la structure (jurys et candidats).</p>
                <button onclick="confirmResetScores()" class="action-button">R√©initialiser les scores uniquement</button>
            </div>
            
            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">R√©initialiser les tours par d√©faut</h3>
                <p>Remet la configuration des tours aux valeurs par d√©faut (6 tours : 1er tour, Rep√™chage 1, 2√®me tour, Rep√™chage 2, Demi-finale, Finale).</p>
                <p style="font-weight: 600; color: var(--warning-color); margin-top: 10px;">‚ö†Ô∏è Les notes et candidats sont conserv√©s, seule la structure des tours est r√©initialis√©e.</p>
                <button onclick="confirmResetRoundsToDefault()" class="action-button" style="background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%); color: white;">üîÑ Remettre les tours par d√©faut</button>
            </div>
            
            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">R√©initialiser le tour en cours</h3>
                <p>Supprime toutes les notes des candidats du tour actif et remet leur statut √† "Actif".</p>
                <button onclick="confirmResetActiveRound()" class="action-button" style="background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%); color: white;">üîÑ R√©initialiser les notes du tour actif</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">R√©initialiser tous les scores et tours</h3>
                <p>Supprime TOUTES les notes de TOUS les tours et remet TOUS les candidats en statut "Actif" au premier tour. Les jurys et candidats sont conserv√©s.</p>
                <p style="font-weight: 600; color: var(--warning-color); margin-top: 10px;">‚ö†Ô∏è Cette action efface toutes les notations mais garde les jurys et la liste des candidats.</p>
                <button onclick="confirmResetAllScoresAndRounds()" class="action-button" style="background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); color: white;">üîÑ R√©initialiser tous les scores et tours</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">R√©initialisation compl√®te</h3>
                <p>Supprime TOUS les jurys, TOUS les candidats ET toutes les notations. Remet l'application √† z√©ro.</p>
                <button onclick="confirmResetAll()" class="action-button">R√âINITIALISER TOUT (Jurys + Candidats + Scores)</button>
            </div>
        </div>
    </div>

    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script type="module">
        import { db } from './firebase-init.js';
        import { collection, getDocs, deleteDoc, doc, setDoc, getDoc, addDoc, query, where, writeBatch, onSnapshot } from "https://www.gstatic.com/firebasejs/10.1.0/firebase-firestore.js";

        let CANDIDATES = [];
        let ROUNDS = [];
        let activeRoundId = null;
        let aggregatedData = {};
        let candidateLocks = {}; // {candidateId: {juryName: boolean}}
        let scoresListener = null; // Pour stocker le listener en temps r√©el
        let candidatesListener = null; // Pour stocker le listener sur les candidats

        // --- REAL-TIME SCORES LISTENER ---
        let refreshTimeout = null;
        let isFirstSnapshot = true;
        let isFirstCandidatesSnapshot = true;
        let pendingRefresh = false;
        
        function setupScoresListener() {
            // Si un listener existe d√©j√†, ne pas en cr√©er un nouveau
            if (scoresListener) {
                console.log('üì° Scores listener already active');
                return;
            }
            
            console.log('üîÑ Setting up real-time scores listener...');
            
            // √âcouter les changements dans la collection scores
            const scoresQuery = query(collection(db, "scores"));
            scoresListener = onSnapshot(scoresQuery, (snapshot) => {
                // Ignorer le premier appel (√©tat initial lors du chargement)
                if (isFirstSnapshot) {
                    console.log('‚è≠Ô∏è Skipping initial snapshot');
                    isFirstSnapshot = false;
                    return;
                }
                
                // V√©rifier les changements r√©els
                const changes = snapshot.docChanges();
                if (changes.length === 0) {
                    return;
                }
                
                console.log('‚ú® Score changes detected:', changes.map(c => `${c.type} ${c.doc.id}`).join(', '));
                
                // Marquer qu'il y a un rafra√Æchissement en attente
                pendingRefresh = true;
                
                // V√©rifier si l'onglet Notes est actif
                const notesTab = document.getElementById('tab-notes');
                const isNotesActive = notesTab && notesTab.classList.contains('active');
                
                if (isNotesActive) {
                    // D√©bounce: attendre 300ms avant de rafra√Æchir
                    if (refreshTimeout) {
                        clearTimeout(refreshTimeout);
                    }
                    refreshTimeout = setTimeout(() => {
                        console.log('üîÑ Refreshing Notes table...');
                        renderNotesTable();
                        pendingRefresh = false;
                    }, 300);
                } else {
                    console.log('üìã Notes tab not active, refresh pending');
                }
            }, (error) => {
                console.error('‚ùå Error listening to scores:', error);
            });
            
            console.log('‚úÖ Scores listener setup complete');
        }
        
        function setupCandidatesListener() {
            // Si un listener existe d√©j√†, ne pas en cr√©er un nouveau
            if (candidatesListener) {
                console.log('üì° Candidates listener already active');
                return;
            }
            
            console.log('üîÑ Setting up real-time candidates listener...');
            
            // √âcouter les changements dans le document des candidats
            const candidatesDocRef = doc(db, "candidats", "liste_actuelle");
            candidatesListener = onSnapshot(candidatesDocRef, (snapshot) => {
                // Ignorer le premier appel (√©tat initial lors du chargement)
                if (isFirstCandidatesSnapshot) {
                    console.log('‚è≠Ô∏è Skipping initial candidates snapshot');
                    isFirstCandidatesSnapshot = false;
                    return;
                }
                
                if (!snapshot.exists()) {
                    return;
                }
                
                console.log('‚ú® Candidates status changes detected');
                
                // Recharger les candidats
                CANDIDATES = snapshot.data().candidates || [];
                
                // Marquer qu'il y a un rafra√Æchissement en attente
                pendingRefresh = true;
                
                // V√©rifier si l'onglet Notes est actif
                const notesTab = document.getElementById('tab-notes');
                const isNotesActive = notesTab && notesTab.classList.contains('active');
                
                if (isNotesActive) {
                    // D√©bounce: attendre 300ms avant de rafra√Æchir
                    if (refreshTimeout) {
                        clearTimeout(refreshTimeout);
                    }
                    refreshTimeout = setTimeout(() => {
                        console.log('üîÑ Refreshing Notes table after candidate status change...');
                        renderNotesTable();
                        pendingRefresh = false;
                    }, 300);
                } else {
                    console.log('üìã Notes tab not active, refresh pending');
                }
            }, (error) => {
                console.error('‚ùå Error listening to candidates:', error);
            });
            
            console.log('‚úÖ Candidates listener setup complete');
        }

        // --- TAB SWITCHING ---
        window.switchTab = function(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(`tab-${tabName}`).classList.add('active');
            event.target.classList.add('active');
            
            // Load tab-specific data
            if (tabName === 'candidats') {
                renderCandidateTable();
            } else if (tabName === 'jury') {
                renderJuryTable();
            } else if (tabName === 'tours') {
                renderRoundsTable();
            } else if (tabName === 'notes') {
                populateNotesRoundDropdown();
                renderNotesTable();
                // Rafra√Æchir si des changements sont en attente
                if (pendingRefresh) {
                    console.log('üîÑ Applying pending refresh...');
                    pendingRefresh = false;
                }
            } else if (tabName === 'podium') {
                populatePodiumRoundDropdown();
                loadResults();
            }
        };

        // --- GESTION CANDIDATS ---
        
        // G√©n√®re un ID al√©atoire unique entre 001 et 999
        function generateUniqueCandidateId() {
            const existingIds = new Set(CANDIDATES.map(c => c.id));
            let attempts = 0;
            const maxAttempts = 1000;
            
            while (attempts < maxAttempts) {
                // G√©n√©rer un nombre al√©atoire entre 1 et 999
                const randomNum = Math.floor(Math.random() * 999) + 1;
                // Formater avec des z√©ros devant (001, 002, etc.)
                const id = String(randomNum).padStart(3, '0');
                
                if (!existingIds.has(id)) {
                    return id;
                }
                attempts++;
            }
            
            // Si tous les IDs sont pris (tr√®s improbable), chercher le premier disponible
            for (let i = 1; i <= 999; i++) {
                const id = String(i).padStart(3, '0');
                if (!existingIds.has(id)) {
                    return id;
                }
            }
            
            // Si vraiment tous les IDs sont pris (999 candidats), retourner null
            return null;
        }

        const loadList = async () => {
            const snap = await getDoc(doc(db, "candidats", "liste_actuelle"));
            if (snap.exists()) {
                CANDIDATES = snap.data().candidates || [];
                
                // Initialiser les nouveaux champs tour et status s'ils n'existent pas
                CANDIDATES = CANDIDATES.map(c => ({
                    ...c,
                    tour: c.tour || activeRoundId || 'round1',
                    status: c.status || 'Actif'
                }));
                
                document.getElementById('candidate-names').value = CANDIDATES.map(c => c.name).join('\n');
                renderCandidateTable();
            }
            
            // Charger les verrous
            const lockSnap = await getDoc(doc(db, "config", "locks"));
            if (lockSnap.exists()) {
                candidateLocks = lockSnap.data().locks || {};
            }
        };

        function generateSequentialCandidateId() {
            // Trouver le prochain ID s√©quentiel disponible
            const usedIds = new Set(CANDIDATES.map(c => c.id));
            for (let i = 1; i <= 999; i++) {
                const id = String(i).padStart(3, '0');
                if (!usedIds.has(id)) {
                    return id;
                }
            }
            return null; // Tous les IDs sont utilis√©s
        }

        window.importCandidates = async () => {
            const names = document.getElementById('candidate-names').value.split('\n').map(n => n.trim()).filter(n => n !== "");
            if (names.length === 0) {
                await customAlert("Veuillez entrer au moins un candidat");
                return;
            }
            
            // V√©rifier si l'utilisateur veut des IDs al√©atoires ou s√©quentiels
            const useRandomIds = document.getElementById('random-ids-checkbox').checked;
            
            // Charger les candidats existants
            const docSnap = await getDoc(doc(db, "candidats", "liste_actuelle"));
            const existingCandidates = docSnap.exists() ? (docSnap.data().candidates || []) : [];
            
            // Cr√©er une copie de CANDIDATES pour la g√©n√©ration d'ID (√©viter les modifications par r√©f√©rence)
            CANDIDATES = [...existingCandidates];
            
            // Cr√©er un Set des noms existants pour v√©rification rapide
            const existingNames = new Set(existingCandidates.map(c => c.name.toLowerCase()));
            
            // Ajouter uniquement les nouveaux candidats
            const newCandidates = [];
            const duplicates = [];
            
            names.forEach(name => {
                if (existingNames.has(name.toLowerCase())) {
                    duplicates.push(name);
                } else {
                    // G√©n√©rer l'ID selon le choix de l'utilisateur
                    const newId = useRandomIds ? generateUniqueCandidateId() : generateSequentialCandidateId();
                    if (newId) {
                        const newCandidate = { 
                            id: newId, 
                            name: name,
                            tour: activeRoundId || 'round1',
                            status: 'Actif'
                        };
                        newCandidates.push(newCandidate);
                        existingNames.add(name.toLowerCase());
                        // Ajouter temporairement √† CANDIDATES pour les prochaines g√©n√©rations d'ID
                        CANDIDATES.push(newCandidate);
                    }
                }
            });
            
            // Fusionner avec les candidats existants
            const updatedList = [...existingCandidates, ...newCandidates];
            
            // Sauvegarder
            await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: updatedList });
            
            // Message de confirmation
            let message = `‚úì ${newCandidates.length} nouveau(x) candidat(s) ajout√©(s)`;
            if (useRandomIds) {
                message += '\n(IDs al√©atoires)';
            } else {
                message += '\n(IDs s√©quentiels)';
            }
            if (duplicates.length > 0) {
                message += `\n‚ö†Ô∏è ${duplicates.length} candidat(s) d√©j√† existant(s) ignor√©(s):\n${duplicates.join(', ')}`;
            }
            await customAlert(message);
            
            CANDIDATES = updatedList;
            renderCandidateTable();
        };

        window.addCandidate = async () => {
            // G√©n√©rer un ID al√©atoire unique
            const newId = generateUniqueCandidateId();
            if (!newId) {
                await customAlert("Impossible d'ajouter un candidat : tous les IDs (001-999) sont utilis√©s.");
                return;
            }
            
            CANDIDATES.push({ 
                id: newId, 
                name: `Candidat ${newId}`,
                tour: activeRoundId || 'round1',
                status: 'Actif'
            });
            saveCandidates();
        };

        window.deleteCandidate = async (candidateId) => {
            if (!await confirm(`Supprimer ce candidat et toutes ses notes ?`)) return;
            
            CANDIDATES = CANDIDATES.filter(c => c.id !== candidateId);
            
            // Supprimer aussi les scores de ce candidat
            const scoresQuery = query(collection(db, "scores"), where("candidateId", "==", candidateId));
            const scoresSnap = await getDocs(scoresQuery);
            for (const scoreDoc of scoresSnap.docs) {
                await deleteDoc(doc(db, "scores", scoreDoc.id));
            }
            
            saveCandidates();
        };

        window.updateCandidateId = async (oldId, newId) => {
            // Nettoyer et valider le nouvel ID
            newId = newId.trim();
            
            // V√©rifier le format (doit √™tre un nombre entre 001 et 999)
            if (!/^\d{3}$/.test(newId)) {
                await customAlert("L'ID doit √™tre un nombre √† 3 chiffres (001 √† 999)");
                renderCandidateTable(); // Restaurer l'ancien ID
                return;
            }
            
            const numericId = parseInt(newId);
            if (numericId < 1 || numericId > 999) {
                await customAlert("L'ID doit √™tre entre 001 et 999");
                renderCandidateTable();
                return;
            }
            
            // V√©rifier l'unicit√©
            if (oldId !== newId && CANDIDATES.some(c => c.id === newId)) {
                await customAlert(`L'ID ${newId} est d√©j√† utilis√© par un autre candidat`);
                renderCandidateTable();
                return;
            }
            
            // Si l'ID n'a pas chang√©, ne rien faire
            if (oldId === newId) {
                return;
            }
            
            // Mettre √† jour l'ID du candidat
            const candidate = CANDIDATES.find(c => c.id === oldId);
            if (candidate) {
                candidate.id = newId;
                
                // Mettre √† jour tous les scores associ√©s √† ce candidat
                const scoresQuery = query(collection(db, "scores"), where("candidateId", "==", oldId));
                const scoresSnap = await getDocs(scoresQuery);
                
                for (const scoreDoc of scoresSnap.docs) {
                    await updateDoc(doc(db, "scores", scoreDoc.id), {
                        candidateId: newId
                    });
                }
                
                // Mettre √† jour les verrous si n√©cessaire
                if (candidateLocks[oldId]) {
                    candidateLocks[newId] = candidateLocks[oldId];
                    delete candidateLocks[oldId];
                    await setDoc(doc(db, "config", "locks"), { locks: candidateLocks });
                }
                
                await saveCandidates();
                await customAlert(`ID mis √† jour : ${oldId} ‚Üí ${newId}`);
            }
        };
        
        window.updateCandidateName = (candidateId, newName) => {
            const candidate = CANDIDATES.find(c => c.id === candidateId);
            if (candidate) {
                candidate.name = newName;
                saveCandidates();
            }
        };

        async function saveCandidates() {
            await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: CANDIDATES });
            renderCandidateTable();
        }

        function renderCandidateTable() {
            const tbody = document.getElementById('candidate-table-body');
            tbody.innerHTML = '';
            
            // Trier les candidats par ID (num√©riquement)
            const sortedCandidates = [...CANDIDATES].sort((a, b) => {
                const idA = parseInt(a.id) || 0;
                const idB = parseInt(b.id) || 0;
                return idA - idB;
            });
            
            sortedCandidates.forEach(candidate => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td><input type="text" value="${candidate.id}" onchange="updateCandidateId('${candidate.id}', this.value)" style="width: 70px; padding: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px; text-align: center; font-family: monospace;"></td>
                    <td><input type="text" value="${candidate.name}" onchange="updateCandidateName('${candidate.id}', this.value)" style="width: 100%; padding: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px;"></td>
                    <td class="actions">
                        <button class="icon-btn delete" onclick="deleteCandidate('${candidate.id}')" title="Supprimer">üóëÔ∏è</button>
                    </td>
                `;
            });
        }

        loadList();

        // --- GESTION JURY ---
        let JURIES = [];
        
        const loadJuries = async () => {
            const accountsSnap = await getDocs(collection(db, "accounts"));
            JURIES = [];
            accountsSnap.forEach(docSnap => {
                const data = docSnap.data();
                JURIES.push({
                    id: docSnap.id,  // ID num√©rique (jury1, jury2, etc.)
                    name: data.name || docSnap.id,  // Nom affich√©
                    password: data.password || '',
                    theme: data.theme || 'light',
                    createdAt: data.createdAt,
                    rounds: data.rounds || [],  // Tours o√π le jury est pr√©sent
                    isPresident: data.isPresident || false  // Pr√©sident du jury
                });
            });
            
            // Trier par ID
            JURIES.sort((a, b) => {
                const numA = parseInt(a.id.replace('jury', ''));
                const numB = parseInt(b.id.replace('jury', ''));
                return numA - numB;
            });
            
            // Mettre √† jour le textarea avec la liste des noms de jurys
            const textarea = document.getElementById('jury-names');
            if (textarea) {
                textarea.value = JURIES.map(j => j.name).join('\n');
            }
            
            renderJuryTable();
        };
        
        // --- GESTION MOT DE PASSE PAR D√âFAUT JURY ---
        let DEFAULT_JURY_PASSWORD = '';
        
        const loadDefaultJuryPassword = async () => {
            try {
                const configDoc = await getDoc(doc(db, "config", "juryDefaults"));
                if (configDoc.exists()) {
                    DEFAULT_JURY_PASSWORD = configDoc.data().defaultPassword || '';
                    const input = document.getElementById('default-jury-password');
                    if (input) {
                        input.value = DEFAULT_JURY_PASSWORD;
                    }
                }
            } catch (e) {
                console.log('Aucun mot de passe par d√©faut configur√©');
            }
        };
        
        window.saveDefaultJuryPassword = async () => {
            const input = document.getElementById('default-jury-password');
            const password = input.value.trim();
            
            if (!password) {
                await customAlert('‚ö†Ô∏è Le mot de passe par d√©faut ne peut pas √™tre vide.\n\nSi vous souhaitez autoriser les jurys √† se connecter sans mot de passe, laissez simplement ce champ vide lors de la cr√©ation du compte.');
                return;
            }
            
            try {
                await setDoc(doc(db, "config", "juryDefaults"), {
                    defaultPassword: password,
                    updatedAt: new Date()
                });
                
                DEFAULT_JURY_PASSWORD = password;
                await customAlert('‚úì Mot de passe par d√©faut enregistr√© avec succ√®s !\n\nCe mot de passe sera maintenant requis pour cr√©er de nouveaux comptes jury.');
            } catch (e) {
                console.error('Erreur:', e);
                await customAlert('‚ùå Erreur lors de l\'enregistrement : ' + e.message);
            }
        };
        
        // Charger le mot de passe par d√©faut au d√©marrage
        loadDefaultJuryPassword();
        
        // --- GESTION OPTION PODIUM APR√àS REP√äCHAGE ---
        let SHOW_PODIUM_AFTER_REPECHAGE = false;
        
        const loadShowPodiumAfterRepechage = async () => {
            try {
                const configDoc = await getDoc(doc(db, "config", "podiumSettings"));
                if (configDoc.exists()) {
                    SHOW_PODIUM_AFTER_REPECHAGE = configDoc.data().showPodiumAfterRepechage || false;
                    const checkbox = document.getElementById('show-podium-after-repechage');
                    if (checkbox) {
                        checkbox.checked = SHOW_PODIUM_AFTER_REPECHAGE;
                    }
                }
            } catch (e) {
                console.log('Aucune configuration podium trouv√©e');
            }
        };
        
        window.saveShowPodiumAfterRepechage = async (value) => {
            try {
                await setDoc(doc(db, "config", "podiumSettings"), {
                    showPodiumAfterRepechage: value,
                    updatedAt: new Date()
                });
                
                SHOW_PODIUM_AFTER_REPECHAGE = value;
                console.log(`‚úì Option podium apr√®s rep√™chage: ${value ? 'activ√©e' : 'd√©sactiv√©e'}`);
            } catch (e) {
                console.error('Erreur:', e);
                await customAlert('‚ùå Erreur lors de l\'enregistrement : ' + e.message);
            }
        };
        
        // Charger l'option au d√©marrage
        loadShowPodiumAfterRepechage();
        
        // Fonction utilitaire pour g√©n√©rer le prochain ID de jury
        async function getNextJuryId() {
            const accountsSnap = await getDocs(collection(db, "accounts"));
            let maxNum = 0;
            accountsSnap.forEach(doc => {
                const match = doc.id.match(/^jury(\d+)$/);
                if (match) {
                    const num = parseInt(match[1]);
                    if (num > maxNum) maxNum = num;
                }
            });
            return `jury${maxNum + 1}`;
        }
        
        window.importJuries = async () => {
            const names = document.getElementById('jury-names').value.split('\n').map(n => n.trim()).filter(n => n !== "");
            if (names.length === 0) {
                alert("Veuillez entrer au moins un jury");
                return;
            }
            
            // Charger les jurys existants
            await loadJuries();
            
            // Cr√©er un Set des noms existants pour v√©rification rapide
            const existingNames = new Set(JURIES.map(j => j.name.toLowerCase()));
            
            // Ajouter uniquement les nouveaux jurys
            const newJuries = [];
            const duplicates = [];
            
            for (const name of names) {
                if (existingNames.has(name.toLowerCase())) {
                    duplicates.push(name);
                } else {
                    const juryId = await getNextJuryId();
                    await setDoc(doc(db, "accounts", juryId), {
                        name: name,
                        password: DEFAULT_JURY_PASSWORD || '',
                        theme: 'light',
                        createdAt: new Date()
                    });
                    newJuries.push(name);
                    existingNames.add(name.toLowerCase());
                }
            }
            
            // Message de confirmation
            let message = `‚úì ${newJuries.length} nouveau(x) jury(s) ajout√©(s)`;
            if (duplicates.length > 0) {
                message += `\n‚ö†Ô∏è ${duplicates.length} jury(s) d√©j√† existant(s) ignor√©(s):\n${duplicates.join(', ')}`;
            }
            alert(message);
            
            await loadJuries();
        };
        
        window.addJury = async () => {
            // Ajouter un jury avec un nom par d√©faut unique
            const juryId = await getNextJuryId();
            
            // G√©n√©rer un nom unique pour le jury
            const existingNames = new Set(JURIES.map(j => j.name.toLowerCase()));
            let juryNumber = JURIES.length + 1;
            let juryName = `Jury ${juryNumber}`;
            
            // S'assurer que le nom est unique
            while (existingNames.has(juryName.toLowerCase())) {
                juryNumber++;
                juryName = `Jury ${juryNumber}`;
            }
            
            // D√©terminer si c'est le premier jury (pr√©sident)
            const isFirstJury = JURIES.length === 0;
            
            // D√©terminer les tours par d√©faut
            // Le jury est pr√©sent sur le tour actif et tous les suivants
            // Sauf pour le rep√™chage, seul le pr√©sident acc√®de √† ce tour
            const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
            const activeRoundIndex = sortedRounds.findIndex(r => r.id === activeRoundId);
            const defaultRounds = sortedRounds
                .filter((r, index) => {
                    // Inclure le tour actif et tous les suivants
                    if (index < activeRoundIndex) return false;
                    
                    // Si c'est un rep√™chage, l'inclure seulement si c'est le pr√©sident
                    if (r.type === 'Rep√™chage') {
                        return isFirstJury;
                    }
                    
                    return true;
                })
                .map(r => r.id);
            
            await setDoc(doc(db, "accounts", juryId), {
                name: juryName,
                password: DEFAULT_JURY_PASSWORD || '',
                theme: 'light',
                createdAt: new Date(),
                isPresident: isFirstJury,
                rounds: defaultRounds
            });
            
            await loadJuries();
        };
        
        window.deleteJury = async (juryId) => {
            const jury = JURIES.find(j => j.id === juryId);
            if (!jury) return;
            
            if (!await confirm(`Supprimer le jury "${jury.name}" et toutes ses notations ?`)) return;
            
            const wasPresident = jury.isPresident;
            
            // Supprimer le compte
            await deleteDoc(doc(db, "accounts", juryId));
            
            // Supprimer toutes les notations de ce jury
            const scoresQuery = query(collection(db, "scores"), where("juryId", "==", juryId));
            const scoresSnap = await getDocs(scoresQuery);
            const batch = writeBatch(db);
            scoresSnap.forEach(doc => batch.delete(doc.ref));
            await batch.commit();
            
            // Si le jury supprim√© √©tait le pr√©sident, assigner un nouveau pr√©sident
            if (wasPresident) {
                await loadJuries(); // Recharger la liste mise √† jour
                
                // Trouver le dernier jury restant pour en faire le pr√©sident
                if (JURIES.length > 0) {
                    const lastJury = JURIES[JURIES.length - 1];
                    console.log(`üîÑ Le pr√©sident a √©t√© supprim√©. Attribution du statut au jury: ${lastJury.name}`);
                    await setJuryPresident(lastJury.id);
                }
            } else {
                await loadJuries();
            }
        };
        
        window.updateJuryName = async (juryId, newName) => {
            if (!newName || !newName.trim()) {
                await loadJuries();
                return;
            }
            
            const trimmedName = newName.trim();
            const jury = JURIES.find(j => j.id === juryId);
            if (!jury || jury.name === trimmedName) {
                await loadJuries();
                return;
            }
            
            // V√©rifier que le nom n'existe pas d√©j√† (ignorer la casse)
            const existingJury = JURIES.find(j => j.id !== juryId && j.name.toLowerCase() === trimmedName.toLowerCase());
            if (existingJury) {
                await customAlert(`‚ö†Ô∏è Un jury avec le nom "${existingJury.name}" existe d√©j√†.\n\nVeuillez choisir un nom diff√©rent.`);
                await loadJuries(); // Recharger pour restaurer l'ancien nom dans l'input
                return;
            }
            
            // Mettre √† jour le nom dans le document
            await setDoc(doc(db, "accounts", juryId), {
                name: trimmedName
            }, { merge: true });
            
            // Mettre √† jour le champ d√©normalis√© juryName dans tous les scores
            const scoresQuery = query(collection(db, "scores"), where("juryId", "==", juryId));
            const scoresSnap = await getDocs(scoresQuery);
            if (!scoresSnap.empty) {
                const batch = writeBatch(db);
                scoresSnap.forEach(docSnap => {
                    batch.update(docSnap.ref, { juryName: trimmedName });
                });
                await batch.commit();
            }
            
            await loadJuries();
        };
        
        window.toggleJuryRound = async (juryId, roundId, isChecked) => {
            const jury = JURIES.find(j => j.id === juryId);
            if (!jury) return;
            
            let updatedRounds = [...(jury.rounds || [])];
            
            if (isChecked) {
                // Ajouter le tour si pas d√©j√† pr√©sent
                if (!updatedRounds.includes(roundId)) {
                    updatedRounds.push(roundId);
                }
            } else {
                // Retirer le tour
                updatedRounds = updatedRounds.filter(r => r !== roundId);
            }
            
            await setDoc(doc(db, "accounts", juryId), {
                rounds: updatedRounds
            }, { merge: true });
            
            await loadJuries();
        };
        
        window.setJuryPresident = async (juryId) => {
            // D√©finir ce jury comme pr√©sident et retirer le statut des autres
            const batch = writeBatch(db);
            const repechageRounds = ROUNDS.filter(r => r.type === 'Rep√™chage').map(r => r.id);
            
            for (const jury of JURIES) {
                const isNewPresident = jury.id === juryId;
                
                // Mettre √† jour le statut de pr√©sident
                const juryRef = doc(db, "accounts", jury.id);
                batch.update(juryRef, { isPresident: isNewPresident });
                
                if (isNewPresident) {
                    // Si ce jury devient pr√©sident, ajouter automatiquement tous les tours de rep√™chage
                    const currentRounds = new Set(jury.rounds || []);
                    repechageRounds.forEach(roundId => currentRounds.add(roundId));
                    batch.update(juryRef, { rounds: Array.from(currentRounds) });
                } else if (!isNewPresident && jury.isPresident) {
                    // Si ce jury n'est plus pr√©sident, retirer les tours de rep√™chage
                    const updatedRounds = (jury.rounds || []).filter(r => !repechageRounds.includes(r));
                    batch.update(juryRef, { rounds: updatedRounds });
                }
            }
            
            await batch.commit();
            await loadJuries();
        };
        
        // Garder l'ancienne fonction pour compatibilit√© (mais elle n'est plus utilis√©e)
        window.toggleJuryPresident = async (juryId, isPresident) => {
            await setDoc(doc(db, "accounts", juryId), {
                isPresident: isPresident
            }, { merge: true });
            
            // Si on retire le statut de pr√©sident, retirer aussi les tours de rep√™chage
            if (!isPresident) {
                const jury = JURIES.find(j => j.id === juryId);
                if (jury) {
                    const repechageRounds = ROUNDS.filter(r => r.type === 'Rep√™chage').map(r => r.id);
                    const updatedRounds = (jury.rounds || []).filter(r => !repechageRounds.includes(r));
                    
                    await setDoc(doc(db, "accounts", juryId), {
                        rounds: updatedRounds
                    }, { merge: true });
                }
            }
            
            await loadJuries();
        };
        
        window.resetJuryPassword = async (juryId) => {
            const jury = JURIES.find(j => j.id === juryId);
            if (!jury) return;
            
            const passwordMsg = DEFAULT_JURY_PASSWORD ? `au mot de passe par d√©faut` : `(vide)`;
            if (!await confirm(`R√©initialiser le mot de passe de "${jury.name}" ${passwordMsg} ?`)) return;
            
            await setDoc(doc(db, "accounts", juryId), {
                password: DEFAULT_JURY_PASSWORD || ''
            }, { merge: true });
            
            const successMsg = DEFAULT_JURY_PASSWORD ? 'r√©initialis√© au mot de passe par d√©faut' : 'r√©initialis√© √† vide';
            await customAlert(`‚úì Mot de passe ${successMsg}`);
            await loadJuries();
        };
        
        function renderJuryTable() {
            const tbody = document.getElementById('jury-table-body');
            const thead = document.querySelector('#jury-table thead tr');
            if (!tbody || !thead) return;
            
            // Construire l'en-t√™te avec les tours
            const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
            thead.innerHTML = `
                <th style="width: 60px; text-align: center;">ID</th>
                <th style="min-width: 150px;">Nom</th>
                <th style="width: 100px; text-align: center;">Pr√©sident</th>
                <th style="min-width: 200px; text-align: center;">Tours pr√©sents</th>
                <th style="width: 120px; text-align: center;">Mot de passe</th>
                <th style="width: 100px; text-align: center;">Actions</th>
            `;
            
            tbody.innerHTML = '';
            
            JURIES.forEach(jury => {
                const row = tbody.insertRow();
                const passwordDisplay = jury.password ? 'üîí D√©fini' : 'üîì Vide';
                const juryNumber = jury.id.replace('jury', '');
                
                // Cr√©er les checkboxes pour les tours
                const roundsCheckboxes = sortedRounds.map(round => {
                    const isChecked = jury.rounds && jury.rounds.includes(round.id);
                    const isRepechage = round.type === 'Rep√™chage';
                    const disabled = isRepechage && !jury.isPresident ? 'disabled' : '';
                    const title = isRepechage && !jury.isPresident ? 'Seul le pr√©sident peut acc√©der aux tours de rep√™chage' : '';
                    return `
                        <label style="display: inline-flex; align-items: center; gap: 4px; margin: 2px 4px; padding: 4px 8px; background: ${isChecked ? 'var(--success-color)' : 'var(--bg-secondary)'}; color: ${isChecked ? 'white' : 'var(--text-color)'}; border-radius: 4px; cursor: ${disabled ? 'not-allowed' : 'pointer'}; opacity: ${disabled ? '0.5' : '1'}; font-size: 0.85em; white-space: nowrap;" title="${title}">
                            <input type="checkbox" 
                                   ${isChecked ? 'checked' : ''} 
                                   ${disabled}
                                   onchange="toggleJuryRound('${jury.id}', '${round.id}', this.checked)"
                                   style="cursor: ${disabled ? 'not-allowed' : 'pointer'};">
                            <span>${round.name}</span>
                        </label>
                    `;
                }).join('');
                
                row.innerHTML = `
                    <td style="text-align: center; color: var(--text-secondary); font-family: monospace;">${juryNumber}</td>
                    <td><input type="text" value="${jury.name}" onchange="updateJuryName('${jury.id}', this.value)" style="width: 100%; padding: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px;"></td>
                    <td style="text-align: center;">
                        <input type="radio" 
                               name="jury-president" 
                               ${jury.isPresident ? 'checked' : ''} 
                               onchange="setJuryPresident('${jury.id}')"
                               style="width: 20px; height: 20px; cursor: pointer;"
                               title="Le pr√©sident peut acc√©der aux tours de rep√™chage">
                    </td>
                    <td style="padding: 8px;">
                        <div style="display: flex; flex-wrap: wrap; gap: 4px; justify-content: center;">
                            ${roundsCheckboxes}
                        </div>
                    </td>
                    <td style="text-align: center;">${passwordDisplay}</td>
                    <td class="actions">
                        <button class="icon-btn" onclick="resetJuryPassword('${jury.id}')" title="R√©initialiser le mot de passe">üîë</button>
                        <button class="icon-btn delete" onclick="deleteJury('${jury.id}')" title="Supprimer">üóëÔ∏è</button>
                    </td>
                `;
            });
        }
        
        loadJuries();
        
        // Charger le th√®me admin depuis Firebase au chargement
        async function loadAdminTheme() {
            try {
                const adminDoc = await getDoc(doc(db, "config", "admin"));
                if (adminDoc.exists()) {
                    const adminTheme = adminDoc.data().theme || 'light';
                    localStorage.setItem('theme_admin', adminTheme);
                    // R√©appliquer le th√®me
                    initTheme();
                }
            } catch (e) {
                console.log('Impossible de charger le th√®me admin:', e);
            }
        }
        loadAdminTheme();

        // --- GESTION TOURS ---
        const loadRounds = async () => {
            const snap = await getDoc(doc(db, "config", "rounds"));
            if (snap.exists()) {
                ROUNDS = snap.data().rounds || [];
                activeRoundId = snap.data().activeRoundId || null;
            }
            
            // Initialiser avec les tours par d√©faut si aucun n'existe
            if (ROUNDS.length === 0) {
                ROUNDS = [
                    {
                        id: 'round1',
                        order: 1,
                        name: '1er tour',
                        type: 'Notation individuelle',
                        nextRoundCandidates: 'ALL',
                        active: true
                    },
                    {
                        id: 'round2',
                        order: 2,
                        name: 'Repechage 1er tour',
                        type: 'Rep√™chage',
                        nextRoundCandidates: 18,
                        active: false
                    },
                    {
                        id: 'round3',
                        order: 3,
                        name: '2eme tour',
                        type: 'Duels',
                        nextRoundCandidates: 'ALL',
                        active: false
                    },
                    {
                        id: 'round4',
                        order: 4,
                        name: 'Repechage 2eme tour',
                        type: 'Rep√™chage',
                        nextRoundCandidates: 7,
                        active: false
                    },
                    {
                        id: 'round5',
                        order: 5,
                        name: 'Demi-finale',
                        type: 'Duels',
                        nextRoundCandidates: 3,
                        active: false
                    },
                    {
                        id: 'round6',
                        order: 6,
                        name: 'Finale',
                        type: 'Duels',
                        nextRoundCandidates: 1,
                        active: false
                    }
                ];
                activeRoundId = 'round1';
                await saveRounds();
            }
            
            renderRoundsTable();
        };
        
        async function saveRounds() {
            await setDoc(doc(db, "config", "rounds"), { 
                rounds: ROUNDS,
                activeRoundId: activeRoundId
            });
            renderRoundsTable();
        }
        
        // Fonction pour mettre √† jour un champ d'un tour
        window.updateRoundField = async (roundId, field, value) => {
            const round = ROUNDS.find(r => r.id === roundId);
            if (round) {
                round[field] = value;
                console.log(`üîÑ Mise √† jour du tour ${roundId}: ${field} = ${value}`);
                await saveRounds();
            }
        };
        
        function renderRoundsTable() {
            const tbody = document.getElementById('rounds-table-body');
            const select = document.getElementById('active-round-select');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            
            // Trier par ordre
            const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
            
            sortedRounds.forEach(round => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td class="actions">
                        <button class="icon-btn delete" onclick="deleteRound('${round.id}')" title="Supprimer">üóëÔ∏è</button>
                    </td>
                    <td><input type="number" value="${round.order}" onchange="updateRoundField('${round.id}', 'order', parseInt(this.value))" style="width: 60px; padding: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px;"></td>
                    <td><input type="text" value="${round.name}" onchange="updateRoundField('${round.id}', 'name', this.value)" style="width: 100%; padding: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px;"></td>
                    <td>
                        <select onchange="updateRoundField('${round.id}', 'type', this.value)" style="width: 100%; min-width: 200px; padding: 6px 8px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px; font-size: 13px;">
                            <option value="Notation individuelle" ${round.type === 'Notation individuelle' ? 'selected' : ''}>Notation individuelle</option>
                            <option value="Rep√™chage" ${round.type === 'Rep√™chage' ? 'selected' : ''}>Rep√™chage</option>
                            <option value="Duels" ${round.type === 'Duels' ? 'selected' : ''}>Duels</option>
                            <option value="Classement" ${round.type === 'Classement' ? 'selected' : ''}>Classement</option>
                        </select>
                    </td>
                    <td><input type="text" value="${round.nextRoundCandidates}" onchange="updateRoundField('${round.id}', 'nextRoundCandidates', this.value)" style="width: 100%; padding: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px;" placeholder="ALL ou nombre"></td>
                `;
            });
            
            // Mettre √† jour le dropdown du tour actif
            if (select) {
                select.innerHTML = '<option value="">-- S√©lectionner un tour --</option>';
                sortedRounds.forEach(round => {
                    const option = document.createElement('option');
                    option.value = round.id;
                    option.textContent = round.name;
                    option.selected = (round.id === activeRoundId);
                    select.appendChild(option);
                });
            }
            
        }
        
        window.addRound = () => {
            // Cr√©er un nouveau tour avec des valeurs par d√©faut
            const newId = `round${Date.now()}`;
            const newOrder = ROUNDS.length > 0 ? Math.max(...ROUNDS.map(r => r.order)) + 1 : 1;
            const roundNumber = ROUNDS.length + 1;
            
            ROUNDS.push({
                id: newId,
                order: newOrder,
                name: `Tour #${roundNumber}`,
                type: 'Notation individuelle',
                nextRoundCandidates: 'ALL',
                active: false
            });
            
            saveRounds();
        };
        
        window.editRound = async (roundId) => {
            const round = ROUNDS.find(r => r.id === roundId);
            if (!round) return;
            
            const name = await prompt("Nom du tour:", round.name);
            if (!name || !name.trim()) return;
            
            const typeNum = {
                'Notation individuelle': '1',
                'Rep√™chage': '2',
                'Duels': '3',
                'Classement': '4'
            }[round.type] || '1';
            
            const type = await prompt(`Type du tour:\n1 - Notation individuelle\n2 - Rep√™chage\n3 - Duels\n4 - Classement\n\nEntrez le num√©ro:`, typeNum);
            const types = {
                '1': 'Notation individuelle',
                '2': 'Rep√™chage',
                '3': 'Duels',
                '4': 'Classement'
            };
            
            if (!types[type]) {
                alert("Type invalide");
                return;
            }
            
            const nextCandidates = await prompt("Nombre de candidats pour le tour suivant (ou 'ALL' pour tous):", 
                round.nextRoundCandidates === 'ALL' ? 'ALL' : round.nextRoundCandidates.toString());
            if (!nextCandidates || !nextCandidates.trim()) return;
            
            const candidates = nextCandidates.toUpperCase() === 'ALL' ? 'ALL' : parseInt(nextCandidates);
            if (candidates !== 'ALL' && isNaN(candidates)) {
                alert("Nombre invalide");
                return;
            }
            
            round.name = name.trim();
            round.type = types[type];
            round.nextRoundCandidates = candidates;
            
            saveRounds();
        };
        
        window.deleteRound = async (roundId) => {
            const round = ROUNDS.find(r => r.id === roundId);
            if (!round) return;
            
            // V√©rifier si ce tour contient des scores
            const scoresSnap = await getDocs(query(collection(db, "scores"), where("roundId", "==", roundId)));
            if (!scoresSnap.empty) {
                if (!await confirm(`Ce tour contient ${scoresSnap.size} notation(s). Supprimer le tour ET toutes ses notations ?`)) {
                    return;
                }
                
                // Supprimer tous les scores du tour
                const batch = writeBatch(db);
                scoresSnap.forEach(doc => batch.delete(doc.ref));
                await batch.commit();
            } else {
                if (!await confirm(`Supprimer le tour "${round.name}" ?`)) {
                    return;
                }
            }
            
            ROUNDS = ROUNDS.filter(r => r.id !== roundId);
            
            // Si on supprime le tour actif, activer le premier tour disponible
            if (activeRoundId === roundId && ROUNDS.length > 0) {
                activeRoundId = ROUNDS[0].id;
                ROUNDS[0].active = true;
            }
            
            saveRounds();
        };
        
        window.setActiveRound = (roundId) => {
            ROUNDS.forEach(r => r.active = (r.id === roundId));
            activeRoundId = roundId;
            saveRounds();
        };
        
        async function initializeRepechage(previousRoundId, repechageRoundId) {
            try {
                console.log(`üéØ Initialisation du rep√™chage pour le tour ${repechageRoundId}`);
                
                const repechageRound = ROUNDS.find(r => r.id === repechageRoundId);
                if (!repechageRound) {
                    console.error('Tour de rep√™chage introuvable');
                    return;
                }
                
                const topN = parseInt(repechageRound.nextRoundCandidates) || 10;
                console.log(`üìä Nombre de candidats √† qualifier: ${topN}`);
                
                // R√©cup√©rer les scores du tour pr√©c√©dent
                const scoresQuery = query(
                    collection(db, "scores"),
                    where("roundId", "==", previousRoundId)
                );
                const scoresSnap = await getDocs(scoresQuery);
                
                // Calculer les scores totaux par candidat
                const candidateScores = {};
                scoresSnap.forEach(docSnap => {
                    const data = docSnap.data();
                    if (!candidateScores[data.candidateId]) {
                        candidateScores[data.candidateId] = 0;
                    }
                    
                    // Calculer le score pond√©r√©
                    if (data.score1 && data.score1 !== '-' && data.score2 && data.score2 !== '-') {
                        if (data.score1 === 'EL' || data.score2 === 'EL') {
                            // √âlimination = 0
                            candidateScores[data.candidateId] += 0;
                        } else {
                            const weighted = (parseInt(data.score1) * 3) + parseInt(data.score2);
                            candidateScores[data.candidateId] += weighted;
                        }
                    }
                });
                
                // Trier les candidats par score d√©croissant
                const sortedCandidates = Object.entries(candidateScores)
                    .sort((a, b) => b[1] - a[1]) // Tri d√©croissant
                    .map(([candidateId, score]) => candidateId);
                
                console.log('üìä Classement des candidats:', sortedCandidates.map((id, i) => `${i+1}. ${id} (${candidateScores[id]}pts)`));
                
                // Les topN premiers re√ßoivent "1", les autres re√ßoivent "0"
                const qualifiedCandidates = new Set(sortedCandidates.slice(0, topN));
                const eliminatedCandidates = sortedCandidates.slice(topN);
                
                console.log(`‚úÖ ${qualifiedCandidates.size} candidats qualifi√©s:`, Array.from(qualifiedCandidates));
                console.log(`‚ùå ${eliminatedCandidates.length} candidats √©limin√©s:`, eliminatedCandidates);
                
                // Charger tous les jurys
                await loadJuries();
                
                // Filtrer les jurys pr√©sents sur le tour de rep√™chage
                const juriesOnRepechage = JURIES.filter(jury => {
                    return jury.rounds && jury.rounds.includes(repechageRoundId);
                });
                
                console.log(`üë• Jurys pr√©sents sur le rep√™chage:`, juriesOnRepechage.map(j => j.name));
                
                // Cr√©er les scores pour tous les candidats actifs du rep√™chage
                const candidatesInRepechage = CANDIDATES.filter(c => c.tour === repechageRoundId && c.status === 'Actif');
                
                const batch = writeBatch(db);
                let scoresCreated = 0;
                
                for (const candidate of candidatesInRepechage) {
                    const noteValue = qualifiedCandidates.has(candidate.id) ? '1' : '0';
                    
                    // Cr√©er les scores seulement pour les jurys pr√©sents sur ce tour
                    for (const jury of juriesOnRepechage) {
                        const newScoreRef = doc(collection(db, "scores"));
                        batch.set(newScoreRef, {
                            juryId: jury.id,
                            juryName: jury.name,
                            candidateId: candidate.id,
                            roundId: repechageRoundId,
                            score1: noteValue,
                            score2: noteValue, // Les deux scores sont identiques pour le rep√™chage
                            timestamp: new Date()
                        });
                        scoresCreated++;
                    }
                }
                
                await batch.commit();
                console.log(`‚úÖ ${scoresCreated} scores de rep√™chage cr√©√©s`);
                
                await customAlert(`üéØ Rep√™chage initialis√© !\n\n‚úÖ ${qualifiedCandidates.size} candidats qualifi√©s (note "1")\n‚ùå ${eliminatedCandidates.length} candidats √©limin√©s (note "0")\n\nChaque jury peut maintenant modifier ces notes si n√©cessaire.`);
                
            } catch (e) {
                console.error('‚ùå Erreur lors de l\'initialisation du rep√™chage:', e);
                await customAlert('‚ùå Erreur lors de l\'initialisation du rep√™chage:\n' + e.message);
            }
        }

        window.finishRound = async () => {
            if (!activeRoundId) {
                await customAlert("Aucun tour actif s√©lectionn√©.");
                return;
            }
            
            const activeRound = ROUNDS.find(r => r.id === activeRoundId);
            if (!activeRound) {
                await customAlert("Tour actif introuvable.");
                return;
            }
            
            // V√©rifier que tous les candidats du tour actif sont soit qualifi√©s soit √©limin√©s
            const candidatesInRound = CANDIDATES.filter(c => c.tour === activeRoundId);
            const candidatesNotReady = candidatesInRound.filter(c => c.status !== 'Qualifie' && c.status !== 'Elimine');
            
            if (candidatesNotReady.length > 0) {
                const names = candidatesNotReady.map(c => `- ${c.name} (${c.status})`).join('\n');
                await customAlert(`‚ùå Impossible de terminer le tour.\n\n${candidatesNotReady.length} candidat(s) ne sont ni Qualifi√©s ni √âlimin√©s :\n\n${names}\n\nVeuillez mettre √† jour leur statut dans l'onglet "Notes".`);
                return;
            }
            
            // Trouver le tour suivant
            const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
            const currentIndex = sortedRounds.findIndex(r => r.id === activeRoundId);
            
            if (currentIndex === -1) {
                await customAlert("Erreur : impossible de trouver le tour actif.");
                return;
            }
            
            if (currentIndex >= sortedRounds.length - 1) {
                await customAlert("C'est le dernier tour. Impossible de passer au tour suivant.");
                return;
            }
            
            const nextRound = sortedRounds[currentIndex + 1];
            
            // Demander confirmation
            const qualifiedCount = candidatesInRound.filter(c => c.status === 'Qualifie').length;
            const eliminatedCount = candidatesInRound.filter(c => c.status === 'Elimine').length;
            
            if (!await customConfirm(`Terminer le tour "${activeRound.name}" ?\n\n‚úì ${qualifiedCount} candidat(s) qualifi√©(s) passeront au tour "${nextRound.name}"\n‚úó ${eliminatedCount} candidat(s) √©limin√©(s)\n\nContinuer ?`)) {
                return;
            }
            
            // Passer les candidats qualifi√©s au tour suivant et les remettre en "Actif"
            let movedCount = 0;
            CANDIDATES.forEach(candidate => {
                if (candidate.tour === activeRoundId && candidate.status === 'Qualifie') {
                    candidate.tour = nextRound.id;
                    candidate.status = 'Actif';
                    movedCount++;
                }
            });
            
            // Sauvegarder les modifications
            await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: CANDIDATES });
            
            // Changer le tour actif
            activeRoundId = nextRound.id;
            ROUNDS.forEach(r => r.active = (r.id === activeRoundId));
            await saveRounds();
            
            // Si le tour suivant est un Rep√™chage, initialiser automatiquement
            if (nextRound.type === 'Rep√™chage') {
                console.log('üéØ Tour suivant est un Rep√™chage, initialisation...');
                await initializeRepechage(activeRound.id, nextRound.id);
            }
            
            // Notifier les jurys connect√©s du changement de tour
            await loadJuries();
            const juriesOnNextRound = JURIES.filter(j => j.rounds && j.rounds.includes(nextRound.id));
            const juryIdsOnNextRound = new Set(juriesOnNextRound.map(j => j.id));
            
            // Cr√©er un signal pour les jurys (timestamp pour forcer la d√©tection)
            await setDoc(doc(db, "config", "roundChange"), {
                newRoundId: nextRound.id,
                newRoundName: nextRound.name,
                juriesOnNewRound: Array.from(juryIdsOnNextRound),
                timestamp: new Date()
            });
            
            await customAlert(`‚úì Tour termin√© avec succ√®s !\n\n${movedCount} candidat(s) qualifi√©(s) sont pass√©s au tour "${nextRound.name}".\n\nLe tour actif est maintenant : "${nextRound.name}"\n\n‚ÑπÔ∏è Les jurys pr√©sents sur le tour suivant verront leur page se recharger automatiquement.`);
            
            // Rafra√Æchir l'affichage
            renderNotesTable();
        };
        
        loadRounds();
        
        // D√©marrer les listeners en temps r√©el apr√®s le chargement
        setTimeout(() => {
            console.log('üöÄ Initializing real-time listeners...');
            setupScoresListener();
            setupCandidatesListener();
        }, 500);

        // --- GESTION NOTES ---
        // Variables globales pour le tri du tableau Notes et l'affichage des tours
        let notesSortColumn = 'id'; // Tri par d√©faut par ID
        let notesSortAscending = true;
        let notesDisplayRound = null; // Tour affich√© dans le tableau Notes
        let podiumDisplayRound = null; // Tour affich√© dans le podium
        
        async function renderNotesTable() {
            const tbody = document.getElementById('notes-table-body');
            const thead = document.querySelector('#notes-table thead tr');
            tbody.innerHTML = '';
            
            // Utiliser le tour s√©lectionn√© dans le dropdown ou le tour actif par d√©faut
            const displayRound = notesDisplayRound || activeRoundId || 'round1';
            
            console.log(`üîç [renderNotesTable] ==========================================`);
            console.log(`üîç [renderNotesTable] notesDisplayRound: ${notesDisplayRound}`);
            console.log(`üîç [renderNotesTable] activeRoundId: ${activeRoundId}`);
            console.log(`üîç [renderNotesTable] displayRound (utilis√©): ${displayRound}`);
            
            // D√©terminer le type du tour affich√© et le tour pr√©c√©dent
            const currentRound = ROUNDS.find(r => r.id === displayRound);
            const isRepechage = currentRound && currentRound.type === 'Rep√™chage';
            let previousRoundId = null;
            
            if (isRepechage) {
                const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
                const currentIndex = sortedRounds.findIndex(r => r.id === displayRound);
                if (currentIndex > 0) {
                    previousRoundId = sortedRounds[currentIndex - 1].id;
                }
            }
            
            console.log(`üîç [renderNotesTable] Type de tour: ${currentRound?.type}, isRepechage: ${isRepechage}, previousRoundId: ${previousRoundId}`);
            
            // Charger TOUS les jurys depuis la collection accounts
            await loadJuries();
            
            // Filtrer les jurys pr√©sents sur le tour affich√©
            const juriesOnRound = JURIES.filter(jury => {
                return jury.rounds && jury.rounds.includes(displayRound);
            });
            const sortedJuries = [...juriesOnRound].sort((a, b) => a.name.localeCompare(b.name));
            
            console.log(`üîç [renderNotesTable] Jurys pr√©sents sur le tour ${displayRound}:`, juriesOnRound.map(j => j.name));
            
            // Charger les scores du tour s√©lectionn√©
            const q = query(
                collection(db, "scores"),
                where("roundId", "==", displayRound)
            );
            const querySnapshot = await getDocs(q);
            const scoresByCandidate = {};
            
            console.log(`üîç [renderNotesTable] Chargement des scores pour le tour: ${displayRound}`);
            console.log(`üîç [renderNotesTable] Nombre de scores trouv√©s: ${querySnapshot.size}`);
            
            querySnapshot.forEach(docSnap => {
                const data = docSnap.data();
                const juryId = data.juryId || data.juryName;
                console.log(`üîç [renderNotesTable] Score trouv√©: candidateId=${data.candidateId}, juryId=${juryId}, score1=${data.score1}, score2=${data.score2}`);
                if (!scoresByCandidate[data.candidateId]) {
                    scoresByCandidate[data.candidateId] = {};
                }
                scoresByCandidate[data.candidateId][juryId] = {
                    id: docSnap.id,
                    score1: data.score1,
                    score2: data.score2
                };
            });
            
            console.log(`üîç [renderNotesTable] scoresByCandidate:`, scoresByCandidate);
            
            // Si c'est un rep√™chage, charger aussi les scores du tour pr√©c√©dent pour affichage
            let previousRoundScores = {};
            let previousRoundJuries = [];
            if (isRepechage && previousRoundId) {
                const prevQuery = query(
                    collection(db, "scores"),
                    where("roundId", "==", previousRoundId)
                );
                const prevQuerySnapshot = await getDocs(prevQuery);
                
                // Charger les jurys qui √©taient pr√©sents sur le tour pr√©c√©dent
                const previousRoundJuriesSet = new Set();
                prevQuerySnapshot.forEach(docSnap => {
                    const data = docSnap.data();
                    const juryId = data.juryId || data.juryName;
                    previousRoundJuriesSet.add(juryId);
                    
                    if (!previousRoundScores[data.candidateId]) {
                        previousRoundScores[data.candidateId] = {};
                    }
                    previousRoundScores[data.candidateId][juryId] = {
                        score1: data.score1,
                        score2: data.score2
                    };
                });
                
                // Filtrer les jurys pour obtenir ceux du tour pr√©c√©dent
                previousRoundJuries = JURIES.filter(j => previousRoundJuriesSet.has(j.id));
                
                console.log(`üîç [renderNotesTable] Scores du tour pr√©c√©dent charg√©s:`, previousRoundScores);
                console.log(`üîç [renderNotesTable] Jurys du tour pr√©c√©dent:`, previousRoundJuries.map(j => j.name));
            }
            
            // Calculer le score total pour chaque candidat
            console.log(`üîç [renderNotesTable] Nombre de candidats √† traiter: ${CANDIDATES.length}`);
            console.log(`üîç [renderNotesTable] Nombre de jurys: ${sortedJuries.length}`);
            console.log(`üîç [renderNotesTable] IDs des jurys:`, sortedJuries.map(j => j.id));
            
            let candidatesWithScores = CANDIDATES.map(candidate => {
                let totalScore = 0;
                let hasScores = false;
                
                if (isRepechage) {
                    // Pour le rep√™chage, v√©rifier d'abord le vote du pr√©sident
                    const president = sortedJuries.find(j => j.isPresident);
                    let presidentVote = null;
                    
                    if (president) {
                        const presidentScore = scoresByCandidate[candidate.id]?.[president.id];
                        if (presidentScore && presidentScore.score1 !== '-') {
                            presidentVote = presidentScore.score1; // '0' ou '1'
                        }
                    }
                    
                    // Si le pr√©sident a vot√© "0" (√©limin√©), le score est 0
                    if (presidentVote === '0') {
                        totalScore = 0;
                        hasScores = true;
                    }
                    // Si le pr√©sident a vot√© "1" (qualifi√©) ou n'a pas encore vot√©, afficher le score du tour pr√©c√©dent
                    else {
                        previousRoundJuries.forEach(jury => {
                            const scores = previousRoundScores[candidate.id]?.[jury.id];
                            if (scores) {
                                // V√©rifier si ce jury a not√© le candidat (pas de '-')
                                if (scores.score1 !== '-' && scores.score2 !== '-') {
                                    hasScores = true;
                                    
                                    // R√®gle : si un jury met "EL", toute sa notation = 0
                                    if (scores.score1 === 'EL' || scores.score2 === 'EL') {
                                        totalScore += 0;
                                    } else {
                                        const s1 = parseFloat(scores.score1) || 0;
                                        const s2 = parseFloat(scores.score2) || 0;
                                        totalScore += (s1 * 3 + s2);
                                    }
                                }
                            }
                        });
                    }
                } else {
                    // Pour les autres tours, utiliser les jurys pr√©sents sur ce tour
                    sortedJuries.forEach(jury => {
                        const scores = scoresByCandidate[candidate.id]?.[jury.id];
                        if (scores) {
                            // V√©rifier si ce jury a not√© le candidat (pas de '-')
                            if (scores.score1 !== '-' && scores.score2 !== '-') {
                                hasScores = true;
                                
                                // R√®gle : si un jury met "EL", toute sa notation = 0
                                if (scores.score1 === 'EL' || scores.score2 === 'EL') {
                                    totalScore += 0;
                                } else {
                                    const s1 = parseFloat(scores.score1) || 0;
                                    const s2 = parseFloat(scores.score2) || 0;
                                    totalScore += (s1 * 3 + s2);
                                }
                            }
                        }
                    });
                }
                
                return {
                    candidate,
                    totalScore: hasScores ? totalScore : null,
                    scoresByJury: scoresByCandidate[candidate.id] || {},
                    previousRoundScoresByJury: isRepechage ? (previousRoundScores[candidate.id] || {}) : {}
                };
            });
            
            // Filtrer par tour si le checkbox est coch√©
            const filterCheckbox = document.getElementById('notes-filter-current-round');
            if (filterCheckbox && filterCheckbox.checked) {
                candidatesWithScores = candidatesWithScores.filter(item => 
                    item.candidate.tour === displayRound
                );
            }
            
            // Appliquer le tri si une colonne est s√©lectionn√©e
            if (notesSortColumn) {
                candidatesWithScores.sort((a, b) => {
                    let valA, valB;
                    
                    if (notesSortColumn === 'id') {
                        valA = parseInt(a.candidate.id) || 0;
                        valB = parseInt(b.candidate.id) || 0;
                    } else if (notesSortColumn === 'candidat') {
                        valA = a.candidate.name.toLowerCase();
                        valB = b.candidate.name.toLowerCase();
                    } else if (notesSortColumn === 'score') {
                        valA = a.totalScore !== null ? a.totalScore : -Infinity;
                        valB = b.totalScore !== null ? b.totalScore : -Infinity;
                    } else if (notesSortColumn === 'tour') {
                        const roundA = ROUNDS.find(r => r.id === a.candidate.tour);
                        const roundB = ROUNDS.find(r => r.id === b.candidate.tour);
                        valA = roundA ? roundA.name.toLowerCase() : '';
                        valB = roundB ? roundB.name.toLowerCase() : '';
                    } else if (notesSortColumn === 'statut') {
                        valA = a.candidate.status.toLowerCase();
                        valB = b.candidate.status.toLowerCase();
                    }
                    
                    if (valA < valB) return notesSortAscending ? -1 : 1;
                    if (valA > valB) return notesSortAscending ? 1 : -1;
                    return 0;
                });
            }
            
            // Construire l'en-t√™te avec colonnes triables
            const sortIcon = (col) => {
                if (notesSortColumn === col) {
                    return notesSortAscending ? ' ‚ñ≤' : ' ‚ñº';
                }
                return '';
            };
            
            // En-t√™te diff√©rent pour rep√™chage vs autres tours
            const juryHeaders = isRepechage 
                ? sortedJuries.map(j => `<th class="col-score" style="min-width: 90px;">${j.name}<br><small>(0 ou 1)</small></th>`).join('')
                : sortedJuries.map(j => `<th colspan="2" class="col-score" style="min-width: 180px;">${j.name}<br><small>(Fond | Forme)</small></th>`).join('');
            
            const scoreLabel = isRepechage ? 'Score<br><small>(tour pr√©c√©dent)</small>' : 'Score';
            
            thead.innerHTML = `
                <th style="width: 60px; cursor: pointer;" onclick="sortNotesTable('id')">ID${sortIcon('id')}</th>
                <th class="col-candidate" style="cursor: pointer;" onclick="sortNotesTable('candidat')">Candidat${sortIcon('candidat')}</th>
                <th style="width: 100px; cursor: pointer;" onclick="sortNotesTable('score')">${scoreLabel}${sortIcon('score')}</th>
                <th style="min-width: 200px; width: 200px; cursor: pointer;" onclick="sortNotesTable('tour')">Dernier Tour${sortIcon('tour')}</th>
                <th style="width: 150px; cursor: pointer;" onclick="sortNotesTable('statut')">Statut${sortIcon('statut')}</th>
                ${juryHeaders}
            `;
            
            // Construire les lignes
            candidatesWithScores.forEach(item => {
                const candidate = item.candidate;
                const row = tbody.insertRow();
                
                // ID
                const idCell = row.insertCell();
                idCell.textContent = candidate.id;
                idCell.style.textAlign = 'center';
                
                // Nom du candidat
                const nameCell = row.insertCell();
                nameCell.className = 'candidate-name col-candidate';
                nameCell.textContent = candidate.name;
                
                // Score total
                const scoreCell = row.insertCell();
                // Pour le rep√™chage, afficher 0 au lieu de "-" pour les √©limin√©s
                if (isRepechage && item.totalScore === null) {
                    scoreCell.textContent = '0';
                } else {
                    scoreCell.textContent = item.totalScore !== null ? item.totalScore.toFixed(0) : '-';
                }
                scoreCell.style.textAlign = 'center';
                scoreCell.style.fontWeight = 'bold';
                
                // Tour
                const tourCell = row.insertCell();
                tourCell.innerHTML = createTourDropdown(candidate);
                
                // Statut
                const statusCell = row.insertCell();
                statusCell.innerHTML = createStatusDropdown(candidate);
                
                // Notes par jury
                sortedJuries.forEach(jury => {
                    const scores = item.scoresByJury[jury.id];
                    
                    if (isRepechage) {
                        // Pour rep√™chage : une seule colonne par jury (0 ou 1)
                        const cell = row.insertCell();
                        cell.className = 'col-score';
                        cell.style.minWidth = '90px';
                        cell.style.width = '90px';
                        cell.style.textAlign = 'center';
                        
                        // Si le statut est "Elimine" ou "Qualifie", les notes ne sont pas √©ditables
                        const readonly = (candidate.status === 'Elimine' || candidate.status === 'Qualifie');
                        
                        if (scores) {
                            cell.innerHTML = createRepechageScoreDropdown(scores.id, scores.score1, candidate.id, jury.id, readonly);
                        } else {
                            cell.innerHTML = createRepechageScoreDropdown(null, '-', candidate.id, jury.id, readonly);
                        }
                    } else {
                        // Pour autres tours : deux colonnes (Fond | Forme)
                        const cell1 = row.insertCell();
                        const cell2 = row.insertCell();
                        cell1.className = 'col-score';
                        cell2.className = 'col-score';
                        cell1.style.minWidth = '90px';
                        cell1.style.width = '90px';
                        cell2.style.minWidth = '90px';
                        cell2.style.width = '90px';
                        
                        // Si le statut est "Elimine" ou "Qualifie", les notes ne sont pas √©ditables
                        const readonly = (candidate.status === 'Elimine' || candidate.status === 'Qualifie');
                        
                        if (scores) {
                            cell1.innerHTML = createScoreDropdown(scores.id, 'score1', scores.score1, candidate.id, jury.id, readonly);
                            cell2.innerHTML = createScoreDropdown(scores.id, 'score2', scores.score2, candidate.id, jury.id, readonly);
                        } else {
                            cell1.innerHTML = createScoreDropdown(null, 'score1', '-', candidate.id, jury.id, readonly);
                            cell2.innerHTML = createScoreDropdown(null, 'score2', '-', candidate.id, jury.id, readonly);
                        }
                    }
                });
            });
        }
        
        window.sortNotesTable = (column) => {
            if (notesSortColumn === column) {
                notesSortAscending = !notesSortAscending;
            } else {
                notesSortColumn = column;
                notesSortAscending = true;
            }
            renderNotesTable();
        };
        
        // Fonction pour remplir le dropdown des tours dans l'onglet Notes
        function populateNotesRoundDropdown() {
            const select = document.getElementById('notes-round-select');
            if (!select) return;
            
            select.innerHTML = '';
            const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
            
            sortedRounds.forEach(round => {
                const option = document.createElement('option');
                option.value = round.id;
                option.textContent = round.name;
                option.selected = (round.id === (notesDisplayRound || activeRoundId));
                select.appendChild(option);
            });
            
            // Attacher l'event listener sur la checkbox de filtrage (si pas d√©j√† fait)
            const filterCheckbox = document.getElementById('notes-filter-current-round');
            if (filterCheckbox && !filterCheckbox.hasAttribute('data-listener-attached')) {
                filterCheckbox.addEventListener('change', () => {
                    console.log('üîÑ Checkbox chang√©e, rechargement du tableau...');
                    renderNotesTable();
                });
                filterCheckbox.setAttribute('data-listener-attached', 'true');
            }
        }
        
        // Fonction pour remplir le dropdown des tours dans l'onglet Podium
        function populatePodiumRoundDropdown() {
            const select = document.getElementById('podium-round-select');
            if (!select) return;
            
            select.innerHTML = '';
            const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
            
            sortedRounds.forEach(round => {
                const option = document.createElement('option');
                option.value = round.id;
                option.textContent = round.name;
                option.selected = (round.id === (podiumDisplayRound || activeRoundId));
                select.appendChild(option);
            });
        }
        
        // Fonction pour changer le tour affich√© dans Notes
        window.changeNotesRound = (roundId) => {
            notesDisplayRound = roundId;
            renderNotesTable();
        };
        
        // Fonction pour changer le tour affich√© dans Podium
        window.changePodiumRound = (roundId) => {
            podiumDisplayRound = roundId;
            loadResults();
        };
        
        function createTourDropdown(candidate) {
            let html = `<select onchange="updateCandidateTour('${candidate.id}', this.value)" style="width: 100%; min-width: 180px; padding: 6px 8px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px; font-size: 13px;">`;
            ROUNDS.forEach(round => {
                const selected = round.id === candidate.tour ? 'selected' : '';
                html += `<option value="${round.id}" ${selected}>${round.name}</option>`;
            });
            html += '</select>';
            return html;
        }
        
        function createStatusDropdown(candidate) {
            const statuses = ['Actif', 'Reset', 'Elimine', 'Qualifie'];
            let html = `<select onchange="updateCandidateStatus('${candidate.id}', this.value)" style="width: 100%; min-width: 130px; padding: 6px 8px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px; font-size: 13px;">`;
            statuses.forEach(status => {
                const selected = status === candidate.status ? 'selected' : '';
                html += `<option value="${status}" ${selected}>${status}</option>`;
            });
            html += '</select>';
            return html;
        }
        
        window.updateCandidateTour = async (candidateId, newTour) => {
            const candidate = CANDIDATES.find(c => c.id === candidateId);
            if (candidate) {
                candidate.tour = newTour;
                await saveCandidates();
                renderNotesTable();
            }
        };
        
        window.updateCandidateStatus = async (candidateId, newStatus) => {
            // Sauvegarder la position de scroll
            const tableContainer = document.querySelector('#tab-notes .table-container');
            const scrollTop = tableContainer ? tableContainer.scrollTop : 0;
            const scrollLeft = tableContainer ? tableContainer.scrollLeft : 0;
            
            const candidate = CANDIDATES.find(c => c.id === candidateId);
            if (!candidate) return;
            
            const oldStatus = candidate.status;
            candidate.status = newStatus;
            
            // Si on passe √† "Reset", r√©initialiser les notes et revenir √† "Actif"
            if (newStatus === 'Reset') {
                await resetCandidateScores(candidateId);
                candidate.status = 'Actif';
            }
            
            await saveCandidates();
            await renderNotesTable();
            await loadResults();
            
            // Restaurer la position de scroll apr√®s que le DOM soit mis √† jour
            // Utiliser setTimeout pour s'assurer que le navigateur a rendu les changements
            setTimeout(() => {
                const container = document.querySelector('#tab-notes .table-container');
                if (container) {
                    container.scrollTop = scrollTop;
                    container.scrollLeft = scrollLeft;
                }
            }, 0);
        };
        
        // Fonction pour v√©rifier si un candidat a toutes ses notes d√©finies 
        // et qualifier/√©liminer en fonction du classement et de la limite nextRoundCandidates
        async function checkAndQualifyCandidate(candidateId) {
            const candidate = CANDIDATES.find(c => c.id === candidateId);
            if (!candidate || candidate.status !== 'Actif') return;
            
            // R√©cup√©rer le tour actif pour conna√Ætre la limite de candidats
            const activeRound = ROUNDS.find(r => r.id === activeRoundId);
            if (!activeRound) return;
            
            // Charger les jurys pr√©sents sur ce tour
            await loadJuries();
            const juriesOnRound = JURIES.filter(j => j.rounds && j.rounds.includes(activeRoundId));
            if (juriesOnRound.length === 0) return;
            
            // R√©cup√©rer tous les candidats du tour actif qui sont "Actif"
            const candidatesInRound = CANDIDATES.filter(c => c.tour === activeRoundId && c.status === 'Actif');
            if (candidatesInRound.length === 0) return;
            
            // Charger tous les scores du tour actif
            const scoresQuery = query(
                collection(db, "scores"),
                where("roundId", "==", activeRoundId || 'round1')
            );
            const scoresSnap = await getDocs(scoresQuery);
            
            // Organiser les scores par candidat et jury
            const scoresByCandidate = {};
            scoresSnap.forEach(docSnap => {
                const data = docSnap.data();
                if (!scoresByCandidate[data.candidateId]) {
                    scoresByCandidate[data.candidateId] = {};
                }
                const juryId = data.juryId || data.juryName;
                scoresByCandidate[data.candidateId][juryId] = {
                    score1: data.score1,
                    score2: data.score2
                };
            });
            
            // V√©rifier si TOUS les candidats ont toutes leurs notes compl√®tes
            let allCandidatesComplete = true;
            const candidateScores = [];
            
            for (const c of candidatesInRound) {
                const candidateScoreData = scoresByCandidate[c.id] || {};
                let isComplete = true;
                let totalScore = 0;
                
                for (const jury of juriesOnRound) {
                    const scores = candidateScoreData[jury.id];
                    if (!scores || 
                        !scores.score1 || scores.score1 === '-' ||
                        !scores.score2 || scores.score2 === '-') {
                        isComplete = false;
                        allCandidatesComplete = false;
                        break;
                    }
                    
                    // Calculer le score (EL = 0)
                    if (scores.score1 === 'EL' || scores.score2 === 'EL') {
                        totalScore += 0;
                    } else {
                        const s1 = parseFloat(scores.score1) || 0;
                        const s2 = parseFloat(scores.score2) || 0;
                        totalScore += (s1 * 3 + s2);
                    }
                }
                
                if (isComplete) {
                    candidateScores.push({
                        id: c.id,
                        name: c.name,
                        totalScore: totalScore
                    });
                }
            }
            
            // Si tous les candidats ne sont pas encore complets, on attend
            if (!allCandidatesComplete) {
                console.log(`‚è≥ En attente : ${candidatesInRound.length - candidateScores.length} candidat(s) n'ont pas encore toutes leurs notes`);
                return;
            }
            
            console.log(`‚úÖ Tous les candidats ont leurs notes compl√®tes. Calcul du classement...`);
            
            // Trier par score d√©croissant
            candidateScores.sort((a, b) => b.totalScore - a.totalScore);
            
            // D√©terminer le nombre de candidats √† qualifier
            let qualifyCount;
            if (activeRound.nextRoundCandidates === 'ALL') {
                qualifyCount = candidateScores.length; // Tous qualifi√©s
            } else {
                qualifyCount = parseInt(activeRound.nextRoundCandidates) || candidateScores.length;
            }
            
            console.log(`üìä ${candidateScores.length} candidats, ${qualifyCount} seront qualifi√©s`);
            
            // Qualifier les N premiers, √©liminer les autres
            let qualifiedCount = 0;
            let eliminatedCount = 0;
            
            candidateScores.forEach((scoreData, index) => {
                const c = CANDIDATES.find(cand => cand.id === scoreData.id);
                if (c) {
                    if (index < qualifyCount) {
                        c.status = 'Qualifie';
                        qualifiedCount++;
                        console.log(`  ‚úì ${c.name}: ${scoreData.totalScore} pts ‚Üí Qualifi√© (rang ${index + 1})`);
                    } else {
                        c.status = 'Elimine';
                        eliminatedCount++;
                        console.log(`  ‚úó ${c.name}: ${scoreData.totalScore} pts ‚Üí √âlimin√© (rang ${index + 1})`);
                    }
                }
            });
            
            await saveCandidates();
            console.log(`‚úÖ Qualification termin√©e: ${qualifiedCount} qualifi√©(s), ${eliminatedCount} √©limin√©(s)`);
        }

        function createScoreDropdown(scoreId, field, currentValue, candidateId, juryId, readonly = false) {
            const options = ['-', '5', '10', '15', '20', 'EL'];
            const selectId = `score-${candidateId}-${juryId}-${field}`;
            const disabledAttr = readonly ? 'disabled' : '';
            
            let html = `<select id="${selectId}" onchange="handleScoreChange('${scoreId}', '${field}', this.value, '${candidateId}', '${juryId}')" ${disabledAttr} style="text-align: center;">`;
            options.forEach(opt => {
                const selected = opt === String(currentValue) ? 'selected' : '';
                html += `<option value="${opt}" ${selected}>${opt}</option>`;
            });
            html += '</select>';
            return html;
        }
        
        function createRepechageScoreDropdown(scoreId, currentValue, candidateId, juryId, readonly = false) {
            const options = ['-', '0', '1'];
            const selectId = `score-${candidateId}-${juryId}-repechage`;
            const disabledAttr = readonly ? 'disabled' : '';
            
            let html = `<select id="${selectId}" onchange="handleRepechageScoreChange('${scoreId}', this.value, '${candidateId}', '${juryId}')" ${disabledAttr} style="text-align: center;">`;
            options.forEach(opt => {
                const selected = opt === String(currentValue) ? 'selected' : '';
                html += `<option value="${opt}" ${selected}>${opt}</option>`;
            });
            html += '</select>';
            return html;
        }
        
        window.handleRepechageScoreChange = async function(scoreId, value, candidateId, juryId) {
            // Sauvegarder la position de scroll et l'√©l√©ment actif
            const tableContainer = document.querySelector('#tab-notes .table-container');
            const scrollTop = tableContainer ? tableContainer.scrollTop : 0;
            const scrollLeft = tableContainer ? tableContainer.scrollLeft : 0;
            
            if (value === '-') {
                // Supprimer le score s'il existe
                if (scoreId && scoreId !== 'null') {
                    await deleteDoc(doc(db, "scores", scoreId));
                }
            } else {
                // Pour le rep√™chage, score1 et score2 sont identiques
                const jury = JURIES.find(j => j.id === juryId);
                const juryName = jury ? jury.name : juryId;
                
                if (scoreId && scoreId !== 'null') {
                    // Mettre √† jour le score existant
                    await setDoc(doc(db, "scores", scoreId), {
                        score1: value,
                        score2: value,
                        timestamp: new Date()
                    }, { merge: true });
                } else {
                    // Cr√©er un nouveau score
                    await addDoc(collection(db, "scores"), {
                        candidateId: candidateId,
                        juryId: juryId,
                        juryName: juryName,
                        roundId: notesDisplayRound || activeRoundId,
                        score1: value,
                        score2: value,
                        timestamp: new Date()
                    });
                }
            }
            
            // Restaurer la position de scroll apr√®s le rechargement
            setTimeout(() => {
                if (tableContainer) {
                    tableContainer.scrollTop = scrollTop;
                    tableContainer.scrollLeft = scrollLeft;
                }
            }, 50);
        };

        window.handleScoreChange = async function(scoreId, field, value, candidateId, juryId) {
            // Sauvegarder la position de scroll et l'√©l√©ment actif
            const tableContainer = document.querySelector('#tab-notes .table-container');
            const scrollTop = tableContainer ? tableContainer.scrollTop : 0;
            const scrollLeft = tableContainer ? tableContainer.scrollLeft : 0;
            
            if (value === '-') {
                // Supprimer le score s'il existe
                if (scoreId && scoreId !== 'null') {
                    await deleteDoc(doc(db, "scores", scoreId));
                }
            } else {
                // Cr√©er ou mettre √† jour le score
                if (scoreId && scoreId !== 'null') {
                    await updateScore(scoreId, field, value);
                } else {
                    await createScore(candidateId, juryId, field, value);
                }
            }
            
            // V√©rifier si le candidat doit √™tre qualifi√© automatiquement
            await checkAndQualifyCandidate(candidateId);
            
            // Rafra√Æchir les deux onglets
            await renderNotesTable();
            await loadResults();
            
            // Restaurer la position de scroll apr√®s que le DOM soit mis √† jour
            // Utiliser setTimeout pour s'assurer que le navigateur a rendu les changements
            setTimeout(() => {
                const container = document.querySelector('#tab-notes .table-container');
                if (container) {
                    container.scrollTop = scrollTop;
                    container.scrollLeft = scrollLeft;
                }
            }, 0);
        };

        async function createScore(candidateId, juryNameOrId, field, value) {
            // juryNameOrId est maintenant le juryId dans le nouveau syst√®me ou le nom dans l'ancien
            // On essaie d'abord par juryId, sinon par juryName (compatibilit√©)
            let q = query(collection(db, "scores"), 
                where("candidateId", "==", candidateId),
                where("juryId", "==", juryNameOrId),
                where("roundId", "==", activeRoundId || 'round1'));
            let snap = await getDocs(q);
            
            // Si pas trouv√© par juryId, essayer par juryName (ancien syst√®me)
            if (snap.empty) {
                q = query(collection(db, "scores"), 
                    where("candidateId", "==", candidateId),
                    where("juryName", "==", juryNameOrId),
                    where("roundId", "==", activeRoundId || 'round1'));
                snap = await getDocs(q);
            }
            
            if (snap.empty) {
                // Cr√©er nouveau score - d√©terminer si on a un juryId ou juryName
                let juryId, juryName;
                if (juryNameOrId.startsWith('jury')) {
                    // C'est un ID num√©rique
                    juryId = juryNameOrId;
                    const juryDoc = await getDoc(doc(db, "accounts", juryId));
                    juryName = juryDoc.exists() ? (juryDoc.data().name || juryId) : juryId;
                } else {
                    // C'est un ancien nom - chercher l'ID
                    const accountsSnap = await getDocs(collection(db, "accounts"));
                    accountsSnap.forEach(d => {
                        if ((d.data().name || d.id) === juryNameOrId) {
                            juryId = d.id;
                            juryName = juryNameOrId;
                        }
                    });
                    // Si pas trouv√©, utiliser le nom comme ID (compatibilit√©)
                    if (!juryId) {
                        juryId = juryNameOrId;
                        juryName = juryNameOrId;
                    }
                }
                
                const data = {
                    candidateId: candidateId,
                    juryId: juryId,
                    juryName: juryName,
                    roundId: activeRoundId || 'round1',
                    score1: field === 'score1' ? value : '-',
                    score2: field === 'score2' ? value : '-',
                    timestamp: new Date()
                };
                
                await addDoc(collection(db, "scores"), data);
            } else {
                // Si des doublons existent, les nettoyer
                if (snap.docs.length > 1) {
                    console.warn(`‚ö†Ô∏è ${snap.docs.length} doublons trouv√©s pour ${candidateId}/${juryName}, nettoyage...`);
                    // Garder le plus r√©cent, supprimer les autres
                    const sorted = snap.docs.sort((a, b) => {
                        const timeA = a.data().timestamp?.toDate?.() || new Date(0);
                        const timeB = b.data().timestamp?.toDate?.() || new Date(0);
                        return timeB - timeA;
                    });
                    
                    // Supprimer tous sauf le premier (le plus r√©cent)
                    for (let i = 1; i < sorted.length; i++) {
                        await deleteDoc(doc(db, "scores", sorted[i].id));
                    }
                }
                
                // Mettre √† jour le score existant (ou le seul restant apr√®s nettoyage)
                const scoreDoc = snap.docs[0];
                await updateScore(scoreDoc.id, field, value);
            }
        }

        window.updateScore = async (scoreId, field, value) => {
            try {
                const scoreRef = doc(db, "scores", scoreId);
                const scoreSnap = await getDoc(scoreRef);
                
                if (!scoreSnap.exists()) return;
                
                const data = scoreSnap.data();
                data[field] = value;
                
                // Ne pas stocker totalWeightedScore - il sera calcul√© √† la vol√©e
                delete data.totalWeightedScore;
                
                await setDoc(scoreRef, data);
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la mise √† jour: ' + e.message);
            }
        };

        async function resetCandidateScores(candidateId) {
            // Supprimer toutes les notes de ce candidat pour le tour actif
            const scoresQuery = query(
                collection(db, "scores"), 
                where("candidateId", "==", candidateId),
                where("roundId", "==", activeRoundId || 'round1')
            );
            const scoresSnap = await getDocs(scoresQuery);
            
            for (const scoreDoc of scoresSnap.docs) {
                await deleteDoc(doc(db, "scores", scoreDoc.id));
            }
            
            // D√©verrouiller automatiquement ce candidat apr√®s r√©initialisation (compatibilit√©)
            if (candidateLocks[candidateId]) {
                delete candidateLocks[candidateId];
                await setDoc(doc(db, "config", "locks"), { locks: candidateLocks });
            }
        }

        // --- CALCUL DES SCORES ---
        window.loadResults = async () => {
            // Utiliser le tour s√©lectionn√© dans le dropdown du podium ou le tour actif par d√©faut
            const displayRound = podiumDisplayRound || activeRoundId || 'round1';
            
            // D√©terminer le type du tour affich√© et le tour pr√©c√©dent
            const currentRound = ROUNDS.find(r => r.id === displayRound);
            const isRepechage = currentRound && currentRound.type === 'Rep√™chage';
            let previousRoundId = null;
            
            if (isRepechage) {
                const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
                const currentIndex = sortedRounds.findIndex(r => r.id === displayRound);
                if (currentIndex > 0) {
                    previousRoundId = sortedRounds[currentIndex - 1].id;
                }
            }
            
            console.log(`üìä [loadResults] Type de tour: ${currentRound?.type}, isRepechage: ${isRepechage}, previousRoundId: ${previousRoundId}`);
            
            // Charger les scores du tour s√©lectionn√©
            const q = query(
                collection(db, "scores"),
                where("roundId", "==", displayRound)
            );
            const querySnapshot = await getDocs(q);
            
            // Charger aussi les jurys pour identifier le pr√©sident si c'est un rep√™chage
            await loadJuries();
            const president = JURIES.find(j => j.isPresident);
            
            // Pour rep√™chage : charger les scores du tour pr√©c√©dent
            let previousRoundScores = {};
            let previousRoundJuries = [];
            if (isRepechage && previousRoundId) {
                const prevQuery = query(
                    collection(db, "scores"),
                    where("roundId", "==", previousRoundId)
                );
                const prevQuerySnapshot = await getDocs(prevQuery);
                
                const previousRoundJuriesSet = new Set();
                prevQuerySnapshot.forEach(docSnap => {
                    const data = docSnap.data();
                    const juryId = data.juryId || data.juryName;
                    previousRoundJuriesSet.add(juryId);
                    
                    if (!previousRoundScores[data.candidateId]) {
                        previousRoundScores[data.candidateId] = {};
                    }
                    previousRoundScores[data.candidateId][juryId] = {
                        score1: data.score1,
                        score2: data.score2,
                        juryName: data.juryName
                    };
                });
                
                previousRoundJuries = JURIES.filter(j => previousRoundJuriesSet.has(j.id));
                console.log(`üìä [loadResults] Jurys du tour pr√©c√©dent:`, previousRoundJuries.map(j => j.name));
            }
            
            aggregatedData = {};
            const juries = new Set();

            CANDIDATES.forEach(c => {
                aggregatedData[c.id] = { name: c.name, total: 0, juryScores: {}, hasScores: false };
            });

            // Utiliser un Set pour d√©tecter et √©viter les doublons
            const processedKeys = new Set();

            querySnapshot.forEach(doc => {
                const data = doc.data();
                const key = `${data.candidateId}_${data.juryName}`;
                
                // Ignorer les doublons (garder seulement le premier rencontr√©)
                if (processedKeys.has(key)) {
                    console.warn(`‚ö†Ô∏è Doublon ignor√©: ${key}`);
                    return;
                }
                processedKeys.add(key);
                
                if (aggregatedData[data.candidateId]) {
                    juries.add(data.juryName);
                    aggregatedData[data.candidateId].juryScores[data.juryName] = data;
                }
            });
            
            // Calculer les scores pour chaque candidat
            CANDIDATES.forEach(c => {
                let totalScore = 0;
                let hasScores = false;
                
                if (isRepechage && president) {
                    // Pour le rep√™chage, v√©rifier d'abord le vote du pr√©sident
                    const presidentScore = aggregatedData[c.id].juryScores[president.name];
                    let presidentVote = null;
                    
                    if (presidentScore && presidentScore.score1 !== '-') {
                        presidentVote = presidentScore.score1; // '0' ou '1'
                    }
                    
                    // Si le pr√©sident a vot√© "0" (√©limin√©), le score est 0
                    if (presidentVote === '0') {
                        totalScore = 0;
                        hasScores = true;
                    }
                    // Si le pr√©sident a vot√© "1" (qualifi√©) ou n'a pas encore vot√©, utiliser le score du tour pr√©c√©dent
                    else {
                        previousRoundJuries.forEach(jury => {
                            const scores = previousRoundScores[c.id]?.[jury.id];
                            if (scores) {
                                if (scores.score1 !== '-' && scores.score2 !== '-') {
                                    hasScores = true;
                                    
                                    // R√®gle : si un jury met "EL", toute sa notation = 0
                                    if (scores.score1 === 'EL' || scores.score2 === 'EL') {
                                        totalScore += 0;
                                    } else {
                                        const s1 = parseFloat(scores.score1) || 0;
                                        const s2 = parseFloat(scores.score2) || 0;
                                        totalScore += (s1 * 3 + s2);
                                    }
                                    
                                    // Ajouter les scores du tour pr√©c√©dent aux juryScores pour l'export
                                    if (!aggregatedData[c.id].juryScores[scores.juryName]) {
                                        aggregatedData[c.id].juryScores[scores.juryName] = scores;
                                    }
                                }
                            }
                        });
                    }
                } else {
                    // Pour les autres tours, utiliser les scores du tour courant
                    Object.values(aggregatedData[c.id].juryScores).forEach(data => {
                        if (data.score1 && data.score1 !== '-' && data.score2 && data.score2 !== '-') {
                            hasScores = true;
                            
                            // R√®gle : si un jury met "EL", toute sa notation = 0
                            if (data.score1 === 'EL' || data.score2 === 'EL') {
                                totalScore += 0;
                            } else {
                                const s1 = parseFloat(data.score1) || 0;
                                const s2 = parseFloat(data.score2) || 0;
                                totalScore += (s1 * 3 + s2);
                            }
                        }
                    });
                }
                
                aggregatedData[c.id].total = totalScore;
                aggregatedData[c.id].hasScores = hasScores;
            });

            // L'onglet R√©sultats n'existe plus, on ne garde que le podium
            // renderMatrix(Array.from(juries).sort());
            renderPodium();
        };

        let currentSortColumn = -1;
        let currentSortDirection = 'desc'; // Start with descending for Total column
        let cachedSortedJuries = [];

        function renderMatrix(sortedJuries) {
            cachedSortedJuries = sortedJuries; // Cache for sorting
            
            const thead = document.querySelector("#scores-matrix thead tr");
            const tbody = document.querySelector("#scores-matrix tbody");
            
            // Build header with click handlers
            thead.innerHTML = "<th data-col='0' title='Cliquer pour trier'>Candidat</th>" + 
                sortedJuries.map((j, idx) => `<th data-col='${idx + 1}' title='Cliquer pour trier'>${j}</th>`).join('') + 
                "<th data-col='total' title='Cliquer pour trier'>Total</th>";
            
            // Add click handlers to headers
            thead.querySelectorAll('th').forEach((th, colIndex) => {
                th.addEventListener('click', () => sortTable(colIndex));
            });
            
            // Store data for sorting
            const candidateRows = CANDIDATES.map(c => {
                const data = aggregatedData[c.id];
                return { candidate: c, data: data };
            });
            
            // Sort if needed
            if (currentSortColumn >= 0) {
                candidateRows.sort((a, b) => {
                    let valA, valB;
                    
                    if (currentSortColumn === 0) {
                        // Sort by candidate name
                        valA = a.candidate.name.toLowerCase();
                        valB = b.candidate.name.toLowerCase();
                        return currentSortDirection === 'asc' ? 
                            valA.localeCompare(valB) : valB.localeCompare(valA);
                    } else if (currentSortColumn === sortedJuries.length + 1) {
                        // Sort by total
                        valA = a.data.total || 0;
                        valB = b.data.total || 0;
                        return currentSortDirection === 'asc' ? valA - valB : valB - valA;
                    } else {
                        // Sort by jury score
                        const juryName = sortedJuries[currentSortColumn - 1];
                        const scoreA = a.data.juryScores[juryName];
                        const scoreB = b.data.juryScores[juryName];
                        
                        // Calculate weighted scores
                        valA = 0;
                        valB = 0;
                        
                        if (scoreA && scoreA.score1 !== '-' && scoreA.score2 !== '-' && 
                            scoreA.score1 !== 'EL' && scoreA.score2 !== 'EL') {
                            valA = (parseInt(scoreA.score1) * 3) + parseInt(scoreA.score2);
                        }
                        if (scoreB && scoreB.score1 !== '-' && scoreB.score2 !== '-' && 
                            scoreB.score1 !== 'EL' && scoreB.score2 !== 'EL') {
                            valB = (parseInt(scoreB.score1) * 3) + parseInt(scoreB.score2);
                        }
                        
                        return currentSortDirection === 'asc' ? valA - valB : valB - valA;
                    }
                });
                
                // Update sort indicator
                thead.querySelectorAll('th').forEach(th => {
                    th.classList.remove('sorted-asc', 'sorted-desc');
                });
                thead.querySelectorAll('th')[currentSortColumn].classList.add(
                    currentSortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc'
                );
            }
            
            // Render rows
            tbody.innerHTML = "";
            candidateRows.forEach(({ candidate: c, data }) => {
                const row = tbody.insertRow();
                row.insertCell().innerHTML = `<b>${c.name}</b>`;
                
                sortedJuries.forEach(j => {
                    const scoreObj = data.juryScores[j];
                    const cell = row.insertCell();
                    if (scoreObj) {
                        if (scoreObj.score1 === "EL") {
                            cell.className = "eliminado";
                            cell.textContent = "√âLIMIN√â";
                        } else {
                            // Recalculer le weighted score pour l'affichage
                            let displayWeightedScore = 0;
                            if (scoreObj.score1 && scoreObj.score1 !== '-' && 
                                scoreObj.score2 && scoreObj.score2 !== '-' &&
                                scoreObj.score1 !== 'EL' && scoreObj.score2 !== 'EL') {
                                displayWeightedScore = (parseInt(scoreObj.score1) * 3) + parseInt(scoreObj.score2);
                            }
                            cell.innerHTML = `<span class="detail-note">${scoreObj.score1} | ${scoreObj.score2}</span><span class="weighted-total">${displayWeightedScore}</span>`;
                        }
                    } else { cell.textContent = "-"; }
                });
                const totalCell = row.insertCell();
                totalCell.className = "total-score";
                totalCell.textContent = data.total;
            });
        }

        function sortTable(colIndex) {
            if (currentSortColumn === colIndex) {
                // Toggle direction
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                // New column - default to descending for numbers, ascending for names
                currentSortColumn = colIndex;
                currentSortDirection = colIndex === 0 ? 'asc' : 'desc';
            }
            renderMatrix(cachedSortedJuries);
        }

        window.renderPodium = function() {
            const body = document.getElementById('podium-body');
            if (!body) return;
            
            body.innerHTML = "";
            
            // V√©rifier que les donn√©es sont charg√©es
            if (!aggregatedData || Object.keys(aggregatedData).length === 0) {
                const row = body.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 3;
                cell.textContent = "Aucune donn√©e. Les r√©sultats se calculent automatiquement en ouvrant cet onglet.";
                cell.style.textAlign = "center";
                cell.style.padding = "20px";
                cell.style.color = "var(--text-secondary)";
                return;
            }
            
            // Filtrer les candidats : uniquement ceux qui ont des scores ET qui ne sont pas √©limin√©s
            let list = Object.values(aggregatedData).filter(c => {
                // Trouver le candidat correspondant dans CANDIDATES pour v√©rifier son statut
                const candidate = CANDIDATES.find(cand => cand.name === c.name);
                
                // Inclure uniquement si le candidat a des scores ET n'est pas √©limin√©
                return c.hasScores && candidate && candidate.status !== 'Elimine';
            }).sort((a,b) => b.total - a.total);
            
            // Limiter le nombre de r√©sultats affich√©s
            const limitInput = document.getElementById('result-limit');
            const limit = limitInput ? parseInt(limitInput.value || 3) : 3;
            list = list.slice(0, limit);
            
            if (list.length === 0) {
                const row = body.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 3;
                cell.textContent = "Aucun r√©sultat disponible.";
                cell.style.textAlign = "center";
                cell.style.padding = "20px";
                return;
            }
            
            list.forEach((c, i) => {
                const row = body.insertRow();
                if (i === 0) row.className = "rank-1";
                else if (i === 1) row.className = "rank-2";
                else if (i === 2) row.className = "rank-3";

                row.insertCell().textContent = i + 1;
                row.insertCell().textContent = c.name;
                row.insertCell().textContent = c.total;
            });
        };

        // Migrer les scores vers le nouveau syst√®me avec juryId
        window.migrateScoresToJuryIds = async () => {
            if (!await confirm('Migrer tous les scores vers le nouveau syst√®me avec IDs num√©riques ?\n\nCela ajoutera un champ juryId √† tous les scores qui n\'en ont pas encore.')) {
                return;
            }
            
            try {
                // Charger tous les comptes jury
                const accountsSnap = await getDocs(collection(db, "accounts"));
                const juryNameToId = new Map();
                accountsSnap.forEach(doc => {
                    const juryName = doc.data().name || doc.id;
                    juryNameToId.set(juryName, doc.id);
                });
                
                // Charger tous les scores
                const scoresSnap = await getDocs(collection(db, "scores"));
                let migrated = 0;
                let skipped = 0;
                let notFound = 0;
                
                const batch = writeBatch(db);
                let batchCount = 0;
                
                for (const scoreDoc of scoresSnap.docs) {
                    const data = scoreDoc.data();
                    
                    // Si le score a d√©j√† un juryId, le sauter
                    if (data.juryId) {
                        skipped++;
                        continue;
                    }
                    
                    // Chercher le juryId correspondant au juryName
                    const juryId = juryNameToId.get(data.juryName);
                    
                    if (juryId) {
                        // Ajouter le juryId au score
                        batch.update(scoreDoc.ref, { juryId: juryId });
                        migrated++;
                        batchCount++;
                        
                        // Firestore batch limit is 500
                        if (batchCount >= 500) {
                            await batch.commit();
                            batchCount = 0;
                        }
                    } else {
                        notFound++;
                        console.warn(`‚ö†Ô∏è Jury non trouv√© pour le score: ${data.juryName}`);
                    }
                }
                
                // Commit remaining operations
                if (batchCount > 0) {
                    await batch.commit();
                }
                
                alert(`‚úì Migration termin√©e !\n\n${migrated} score(s) migr√©(s)\n${skipped} score(s) d√©j√† √† jour\n${notFound} jury(s) non trouv√©(s)`);
                
                // Rafra√Æchir l'affichage
                await loadResults();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la migration: ' + e.message);
            }
        };
        
        // Nettoyer et v√©rifier la conformit√© de la base de donn√©es
        window.cleanDatabase = async () => {
            if (!await confirm('‚ö†Ô∏è NETTOYAGE DE LA BASE DE DONN√âES ‚ö†Ô∏è\n\nCette op√©ration va :\n- Supprimer les doublons de scores\n- Supprimer les scores orphelins (candidats/jurys supprim√©s)\n- Nettoyer les valeurs calcul√©es obsol√®tes\n\nüíæ Recommandation : Sauvegardez votre base avant de continuer !\n\nContinuer le nettoyage ?')) {
                return;
            }
            
            try {
                let report = {
                    duplicatesRemoved: 0,
                    orphanScores: 0,
                    obsoleteFields: 0
                };
                
                // 1. Charger les candidats et jurys valides
                const candidatsSnap = await getDoc(doc(db, "candidats", "liste_actuelle"));
                const validCandidates = new Set(candidatsSnap.exists() ? (candidatsSnap.data().candidates || []).map(c => c.id) : []);
                
                const accountsSnap = await getDocs(collection(db, "accounts"));
                const validJuries = new Set();
                accountsSnap.forEach(d => {
                    validJuries.add(d.id); // juryId
                    validJuries.add(d.data().name || d.id); // juryName pour compatibilit√©
                });
                
                // 2. Analyser tous les scores
                const querySnapshot = await getDocs(collection(db, "scores"));
                const scoresByKey = {};
                const toDelete = [];
                
                querySnapshot.forEach(scoreDoc => {
                    const data = scoreDoc.data();
                    const key = `${data.candidateId}_${data.juryId || data.juryName}_${data.roundId || 'round1'}`;
                    
                    // V√©rifier si le score est orphelin
                    const isOrphan = !validCandidates.has(data.candidateId) || 
                                     (!validJuries.has(data.juryId) && !validJuries.has(data.juryName));
                    
                    if (isOrphan) {
                        toDelete.push({ id: scoreDoc.id, reason: 'orphan' });
                        report.orphanScores++;
                    } else {
                        // Grouper pour d√©tecter les doublons
                        if (!scoresByKey[key]) {
                            scoresByKey[key] = [];
                        }
                        scoresByKey[key].push({ 
                            id: scoreDoc.id, 
                            data: data, 
                            timestamp: data.timestamp 
                        });
                    }
                    
                    // V√©rifier les champs obsol√®tes
                    if ('totalWeightedScore' in data) {
                        toDelete.push({ id: scoreDoc.id, reason: 'obsoleteField', data: data });
                        report.obsoleteFields++;
                    }
                });
                
                // 3. Trouver les doublons
                for (const key in scoresByKey) {
                    const scores = scoresByKey[key];
                    if (scores.length > 1) {
                        // Trier par timestamp (le plus r√©cent en premier)
                        scores.sort((a, b) => {
                            const timeA = a.timestamp?.toDate?.() || new Date(0);
                            const timeB = b.timestamp?.toDate?.() || new Date(0);
                            return timeB - timeA;
                        });
                        
                        // Marquer les anciens pour suppression
                        for (let i = 1; i < scores.length; i++) {
                            toDelete.push({ id: scores[i].id, reason: 'duplicate' });
                            report.duplicatesRemoved++;
                        }
                    }
                }
                
                // 4. Supprimer les scores invalides/obsol√®tes
                for (const item of toDelete) {
                    if (item.reason === 'obsoleteField') {
                        // Juste enlever le champ obsol√®te
                        const { totalWeightedScore, ...cleanData } = item.data;
                        await setDoc(doc(db, "scores", item.id), cleanData);
                    } else {
                        // Supprimer compl√®tement (doublon ou orphelin)
                        await deleteDoc(doc(db, "scores", item.id));
                    }
                }
                
                await alert(`‚úì Nettoyage termin√© !\n\nüìä Rapport :\n- ${report.duplicatesRemoved} doublon(s) supprim√©(s)\n- ${report.orphanScores} score(s) orphelin(s) supprim√©(s)\n- ${report.obsoleteFields} champ(s) obsol√®te(s) nettoy√©(s)\n\nTotal : ${report.duplicatesRemoved + report.orphanScores} score(s) supprim√©(s)`);
                
                // Rafra√Æchir l'affichage
                renderNotesTable();
                await loadResults();
            } catch (e) {
                console.error('Erreur:', e);
                await alert('Erreur lors du nettoyage: ' + e.message);
            }
        };
        
        // Supprimer les doublons de scores
        window.removeDuplicateScores = async () => {
            if (!await confirm('Rechercher et supprimer les doublons de scores ?\n\nPour chaque combinaison candidat+jury, seule la note la plus r√©cente sera conserv√©e.')) {
                return;
            }
            
            try {
                const querySnapshot = await getDocs(collection(db, "scores"));
                
                // Grouper par candidat+jury
                const scoresByKey = {};
                querySnapshot.forEach(doc => {
                    const data = doc.data();
                    const key = `${data.candidateId}_${data.juryName}`;
                    
                    if (!scoresByKey[key]) {
                        scoresByKey[key] = [];
                    }
                    scoresByKey[key].push({ id: doc.id, data: data, timestamp: data.timestamp });
                });
                
                // Trouver et supprimer les doublons
                let duplicatesFound = 0;
                let duplicatesRemoved = 0;
                
                for (const key in scoresByKey) {
                    const scores = scoresByKey[key];
                    if (scores.length > 1) {
                        duplicatesFound += scores.length - 1;
                        console.log(`Doublon trouv√© pour ${key}: ${scores.length} entr√©es`);
                        
                        // Trier par timestamp (le plus r√©cent en premier)
                        scores.sort((a, b) => {
                            const timeA = a.timestamp?.toDate?.() || new Date(0);
                            const timeB = b.timestamp?.toDate?.() || new Date(0);
                            return timeB - timeA;
                        });
                        
                        // Garder le premier (le plus r√©cent), supprimer les autres
                        for (let i = 1; i < scores.length; i++) {
                            console.log(`Suppression de l'ancien score: ${scores[i].id}`, scores[i].data);
                            await deleteDoc(doc(db, "scores", scores[i].id));
                            duplicatesRemoved++;
                        }
                    }
                }
                
                alert(`‚úì Nettoyage des doublons termin√© !\n${duplicatesFound} doublon(s) trouv√©(s)\n${duplicatesRemoved} doublon(s) supprim√©(s)`);
                
                // Rafra√Æchir l'affichage
                renderNotesTable();
                await loadResults();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors du nettoyage des doublons: ' + e.message);
            }
        };

        // Nettoyer les valeurs calcul√©es obsol√®tes de la base de donn√©es
        // T√©l√©charger toute la base de donn√©es en JSON
        window.downloadDatabase = async () => {
            try {
                const backup = {
                    exportDate: new Date().toISOString(),
                    version: "2.0",
                    data: {}
                };
                
                // Exporter les candidats
                const candidatsSnap = await getDoc(doc(db, "candidats", "liste_actuelle"));
                if (candidatsSnap.exists()) {
                    backup.data.candidats = candidatsSnap.data();
                }
                
                // Exporter tous les comptes jury (collection accounts)
                const accountsSnap = await getDocs(collection(db, "accounts"));
                backup.data.accounts = [];
                accountsSnap.forEach(d => {
                    backup.data.accounts.push({ 
                        id: d.id, 
                        ...d.data(),
                        // Convertir les timestamps en ISO strings pour le JSON
                        createdAt: d.data().createdAt?.toDate?.()?.toISOString() || null
                    });
                });
                
                // Exporter tous les scores
                const scoresSnap = await getDocs(collection(db, "scores"));
                backup.data.scores = [];
                scoresSnap.forEach(d => {
                    const scoreData = d.data();
                    backup.data.scores.push({ 
                        id: d.id, 
                        ...scoreData,
                        // Convertir les timestamps en ISO strings
                        timestamp: scoreData.timestamp?.toDate?.()?.toISOString() || null
                    });
                });
                
                // Exporter la configuration compl√®te
                backup.data.config = {};
                
                // Config: locks
                const locksSnap = await getDoc(doc(db, "config", "locks"));
                if (locksSnap.exists()) {
                    backup.data.config.locks = locksSnap.data();
                }
                
                // Config: session
                const sessionSnap = await getDoc(doc(db, "config", "session"));
                if (sessionSnap.exists()) {
                    backup.data.config.session = sessionSnap.data();
                }
                
                // Config: admin (mot de passe et th√®me)
                const adminSnap = await getDoc(doc(db, "config", "admin"));
                if (adminSnap.exists()) {
                    backup.data.config.admin = adminSnap.data();
                }
                
                // Config: rounds (tours)
                const roundsSnap = await getDoc(doc(db, "config", "rounds"));
                if (roundsSnap.exists()) {
                    backup.data.config.rounds = roundsSnap.data();
                }
                
                // Cr√©er le fichier JSON
                const json = JSON.stringify(backup, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // T√©l√©charger
                const a = document.createElement('a');
                a.href = url;
                a.download = `concours-eloquence-backup-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert(`‚úì Sauvegarde cr√©√©e avec succ√®s !\n\n${backup.data.scores.length} score(s)\n${backup.data.candidats?.candidates?.length || 0} candidat(s)\n${backup.data.accounts.length} jury(s)`);
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la sauvegarde: ' + e.message);
            }
        };
        
        // Restaurer la base de donn√©es depuis un fichier JSON
        window.uploadDatabase = async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!await confirm(`‚ö†Ô∏è ATTENTION ‚ö†Ô∏è\n\nRestaurer la base de donn√©es va REMPLACER toutes les donn√©es actuelles !\n\nVoulez-vous continuer ?`)) {
                event.target.value = ''; // Reset file input
                return;
            }
            
            try {
                const text = await file.text();
                const backup = JSON.parse(text);
                
                if (!backup.data || !backup.version) {
                    throw new Error('Format de fichier invalide');
                }
                
                let restored = 0;
                
                // Restaurer les candidats
                if (backup.data.candidats) {
                    await setDoc(doc(db, "candidats", "liste_actuelle"), backup.data.candidats);
                    CANDIDATES = backup.data.candidats.candidates || [];
                    restored++;
                }
                
                // Restaurer les comptes jury (supprimer les anciens d'abord)
                if (backup.data.accounts) {
                    const oldAccounts = await getDocs(collection(db, "accounts"));
                    for (const d of oldAccounts.docs) {
                        await deleteDoc(doc(db, "accounts", d.id));
                    }
                    
                    for (const account of backup.data.accounts) {
                        const { id, ...accountData } = account;
                        // Convertir les ISO strings en Timestamps
                        if (accountData.createdAt && typeof accountData.createdAt === 'string') {
                            accountData.createdAt = new Date(accountData.createdAt);
                        }
                        await setDoc(doc(db, "accounts", id), accountData);
                        restored++;
                    }
                }
                
                // Restaurer les scores (supprimer les anciens d'abord)
                const oldScores = await getDocs(collection(db, "scores"));
                for (const d of oldScores.docs) {
                    await deleteDoc(doc(db, "scores", d.id));
                }
                
                if (backup.data.scores) {
                    for (const score of backup.data.scores) {
                        const { id, ...scoreData } = score;
                        // Convertir les ISO strings en Timestamps
                        if (scoreData.timestamp && typeof scoreData.timestamp === 'string') {
                            scoreData.timestamp = new Date(scoreData.timestamp);
                        }
                        await addDoc(collection(db, "scores"), scoreData);
                        restored++;
                    }
                }
                
                // Restaurer la configuration (version 2.0 avec structure unifi√©e)
                if (backup.data.config) {
                    if (backup.data.config.locks) {
                        await setDoc(doc(db, "config", "locks"), backup.data.config.locks);
                        candidateLocks = backup.data.config.locks.locks || {};
                        restored++;
                    }
                    
                    if (backup.data.config.session) {
                        await setDoc(doc(db, "config", "session"), backup.data.config.session);
                        restored++;
                    }
                    
                    if (backup.data.config.admin) {
                        await setDoc(doc(db, "config", "admin"), backup.data.config.admin);
                        restored++;
                    }
                    
                    if (backup.data.config.rounds) {
                        await setDoc(doc(db, "config", "rounds"), backup.data.config.rounds);
                        restored++;
                    }
                }
                // Support de l'ancien format (version 1.0)
                else {
                    if (backup.data.locks) {
                        await setDoc(doc(db, "config", "locks"), backup.data.locks);
                        candidateLocks = backup.data.locks.locks || {};
                        restored++;
                    }
                    
                    if (backup.data.session) {
                        await setDoc(doc(db, "config", "session"), backup.data.session);
                        restored++;
                    }
                    
                    if (backup.data.adminPassword) {
                        await setDoc(doc(db, "config", "admin"), { password: backup.data.adminPassword });
                        restored++;
                    }
                }
                
                alert(`‚úì Restauration r√©ussie !\n\n${restored} √©l√©ment(s) restaur√©(s)\nVersion: ${backup.version}\nDate de sauvegarde: ${new Date(backup.exportDate).toLocaleString()}`);
                
                // Recharger la page pour rafra√Æchir toutes les donn√©es
                location.reload();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la restauration: ' + e.message);
                event.target.value = ''; // Reset file input
            }
        };

        window.recalculateAllScores = async () => {
            if (!await confirm('Nettoyer les valeurs calcul√©es obsol√®tes en base de donn√©es ?\n\nLes scores pond√©r√©s seront d√©sormais toujours calcul√©s √† la vol√©e.')) {
                return;
            }
            
            try {
                const querySnapshot = await getDocs(collection(db, "scores"));
                let cleaned = 0;
                
                for (const scoreDoc of querySnapshot.docs) {
                    const data = scoreDoc.data();
                    
                    // Supprimer totalWeightedScore s'il existe
                    if ('totalWeightedScore' in data) {
                        delete data.totalWeightedScore;
                        await setDoc(doc(db, "scores", scoreDoc.id), data);
                        cleaned++;
                    }
                }
                
                alert(`‚úì Nettoyage termin√© !\n${cleaned} enregistrement(s) nettoy√©(s).\n\nLes totaux sont maintenant calcul√©s correctement.`);
                
                // Rafra√Æchir l'affichage
                renderNotesTable();
                await loadResults();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors du nettoyage: ' + e.message);
            }
        };

        window.confirmDeleteAllJuries = async () => {
            if (!await customConfirm(`‚ö†Ô∏è ATTENTION ‚ö†Ô∏è\n\nSupprimer TOUS les comptes jurys ET toutes leurs notations ?\n\nLa liste des candidats sera conserv√©e.\n\nCette action est IRR√âVERSIBLE !`)) {
                return;
            }
            
            // Double confirmation
            if (!await customConfirm(`√ätes-vous VRAIMENT s√ªr ?\n\nTous les comptes jurys et toutes leurs notes seront supprim√©s d√©finitivement.`)) {
                return;
            }
            
            try {
                // Supprimer toutes les notations
                const scoresSnapshot = await getDocs(collection(db, "scores"));
                const batch1 = writeBatch(db);
                scoresSnapshot.docs.forEach(d => batch1.delete(d.ref));
                await batch1.commit();
                const deletedScores = scoresSnapshot.docs.length;
                
                // Supprimer tous les comptes jurys
                const accountsSnapshot = await getDocs(collection(db, "accounts"));
                const batch2 = writeBatch(db);
                accountsSnapshot.docs.forEach(d => batch2.delete(d.ref));
                await batch2.commit();
                const deletedJuries = accountsSnapshot.docs.length;
                
                // Supprimer tous les verrous
                candidateLocks = {};
                await setDoc(doc(db, "config", "locks"), { locks: {} });
                
                await customAlert(`‚úì Suppression termin√©e avec succ√®s\n\n- ${deletedJuries} jury(s) supprim√©(s)\n- ${deletedScores} notation(s) supprim√©e(s)`);
                location.reload();
            } catch (e) {
                console.error('Erreur:', e);
                await customAlert('‚ùå Erreur lors de la suppression:\n' + e.message);
            }
        };

        window.insertTestData = async () => {
            // Listes par d√©faut
            const defaultCandidateNames = [
                "Tim√©o Charvolin", "Paul R√©gent", "Lo√Øc Delais", "Sophie Moreau", "Lucas Bernard",
                "Emma Dubois", "Nathan Thomas", "L√©a Petit", "Hugo Robert", "Chlo√© Richard",
                "Arthur Durand", "Manon Lefebvre", "Louis Martin", "Camille Laurent", "Gabriel Simon",
                "Sarah Michel", "Alexandre Lef√®vre", "Julie Garcia", "Maxime Roux", "Marine Vincent",
                "Th√©o Fournier", "Clara Bertrand", "Antoine Girard", "Pauline Morel", "Nicolas Andr√©",
                "Laura Mercier", "Julien Blanchard", "Alice Fontaine", "Romain Rousseau", "Ana√Øs Lambert",
                "Pierre Chevalier", "Am√©lie Bonnet", "L√©na Garnier", "Benjamin Faure"
            ];
            
            const defaultJuryNames = ["Martin", "Lasso", "Murat", "Blier", "Collisse", "Pierre"];
            
            // Cr√©er la modal personnalis√©e
            const modalHtml = `
                <div style="display: flex; flex-direction: column; gap: 20px; max-height: 70vh; overflow-y: auto;">
                    <div style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; border: 2px solid var(--border-color);">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <input type="checkbox" id="test-add-candidates" checked style="width: 20px; height: 20px; cursor: pointer;">
                            <label for="test-add-candidates" style="font-weight: 600; font-size: 1.1em; color: var(--text-color); cursor: pointer;">üìã Ajouter des candidats de test</label>
                        </div>
                        <p style="color: var(--text-secondary); font-size: 0.9em; margin-bottom: 10px;">Un nom par ligne. Ces candidats seront ajout√©s aux candidats existants.</p>
                        <textarea id="test-candidates-list" style="width: 100%; min-height: 150px; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-color); font-family: monospace; font-size: 0.9em; resize: vertical;">${defaultCandidateNames.join('\n')}</textarea>
                        <div style="display: flex; align-items: center; gap: 8px; margin-top: 10px;">
                            <input type="checkbox" id="test-random-ids" style="width: 18px; height: 18px; cursor: pointer;">
                            <label for="test-random-ids" style="color: var(--text-color); cursor: pointer; font-size: 0.95em;">G√©n√©rer des IDs al√©atoires (sinon 001, 002, 003...)</label>
                        </div>
                    </div>
                    
                    <div style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; border: 2px solid var(--border-color);">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <input type="checkbox" id="test-add-juries" checked style="width: 20px; height: 20px; cursor: pointer;">
                            <label for="test-add-juries" style="font-weight: 600; font-size: 1.1em; color: var(--text-color); cursor: pointer;">üë• Ajouter des jurys de test</label>
                        </div>
                        <p style="color: var(--text-secondary); font-size: 0.9em; margin-bottom: 10px;">Un nom par ligne. Ces jurys seront ajout√©s aux jurys existants avec le mot de passe par d√©faut.</p>
                        <textarea id="test-juries-list" style="width: 100%; min-height: 100px; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-color); font-family: monospace; font-size: 0.9em; resize: vertical;">${defaultJuryNames.join('\n')}</textarea>
                    </div>
                    
                    <div style="background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%); padding: 12px; border-radius: 6px; border: 1px solid #ffc107;">
                        <p style="color: #856404; font-size: 0.9em; margin: 0;">
                            <strong>‚ö†Ô∏è Note :</strong> Les doublons seront automatiquement ignor√©s.
                        </p>
                    </div>
                </div>
            `;
            
            // Variable pour stocker les valeurs avant que la modal ne se ferme
            let modalData = null;
            
            // Cr√©er une Promise personnalis√©e pour g√©rer la modal
            const confirmed = await new Promise((resolve) => {
                // Afficher la modal avec customConfirm
                customConfirm(modalHtml, {
                    title: 'üß™ Ins√©rer des donn√©es de test',
                    confirmText: '‚úì Ajouter',
                    cancelText: '‚úó Annuler',
                    width: '600px'
                }).then((result) => {
                    resolve(result);
                });
                
                // Intercepter le clic sur le bouton confirm pour r√©cup√©rer les valeurs
                setTimeout(() => {
                    const confirmBtn = document.getElementById('modal-confirm');
                    if (confirmBtn) {
                        confirmBtn.addEventListener('click', () => {
                            // R√©cup√©rer les valeurs juste avant la fermeture
                            const addCandidatesEl = document.getElementById('test-add-candidates');
                            const addJuriesEl = document.getElementById('test-add-juries');
                            const candidatesListEl = document.getElementById('test-candidates-list');
                            const juriesListEl = document.getElementById('test-juries-list');
                            const randomIdsEl = document.getElementById('test-random-ids');
                            
                            modalData = {
                                addCandidates: addCandidatesEl?.checked || false,
                                addJuries: addJuriesEl?.checked || false,
                                candidatesList: candidatesListEl?.value || '',
                                juriesList: juriesListEl?.value || '',
                                randomIds: randomIdsEl?.checked || false
                            };
                        }, { once: true, capture: true });
                    }
                }, 100);
            });
            
            if (!confirmed || !modalData) return;
            
            try {
                // Utiliser les donn√©es sauvegard√©es
                const { addCandidates, addJuries, candidatesList, juriesList, randomIds } = modalData;
                
                if (!addCandidates && !addJuries) {
                    await customAlert('‚ö†Ô∏è Aucune donn√©e s√©lectionn√©e pour l\'ajout.');
                    return;
                }
                
                let candidatesAdded = 0;
                let juriesAdded = 0;
                
                // Ajouter les candidats si la checkbox est coch√©e
                if (addCandidates && candidatesList.trim()) {
                    const testCandidateNames = candidatesList.split('\n')
                        .map(name => name.trim())
                        .filter(name => name.length > 0);
                    
                    const candidatesDoc = await getDoc(doc(db, "candidats", "liste_actuelle"));
                    let existingCandidates = candidatesDoc.exists() ? candidatesDoc.data().candidates || [] : [];
                    const usedIds = new Set(existingCandidates.map(c => c.id));
                    const existingNames = new Set(existingCandidates.map(c => c.name.toLowerCase()));
                    
                    // Trouver le prochain ID s√©quentiel si n√©cessaire
                    let nextSequentialId = 1;
                    if (!randomIds) {
                        existingCandidates.forEach(c => {
                            const numId = parseInt(c.id);
                            if (!isNaN(numId) && numId >= nextSequentialId) {
                                nextSequentialId = numId + 1;
                            }
                        });
                    }
                    
                    for (const name of testCandidateNames) {
                        // Ignorer les doublons
                        if (existingNames.has(name.toLowerCase())) {
                            continue;
                        }
                        
                        // G√©n√©rer un ID unique
                        let newId;
                        if (randomIds) {
                            // IDs al√©atoires
                            do {
                                newId = String(Math.floor(Math.random() * 999) + 1).padStart(3, '0');
                            } while (usedIds.has(newId));
                        } else {
                            // IDs s√©quentiels
                            do {
                                newId = String(nextSequentialId).padStart(3, '0');
                                nextSequentialId++;
                            } while (usedIds.has(newId));
                        }
                        usedIds.add(newId);
                        
                        existingCandidates.push({
                            id: newId,
                            name: name,
                            tour: activeRoundId || 'round1',
                            status: 'Actif'
                        });
                        existingNames.add(name.toLowerCase());
                        candidatesAdded++;
                    }
                    
                    // Sauvegarder les candidats
                    await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: existingCandidates });
                }
                
                // Ajouter les jurys si la checkbox est coch√©e
                if (addJuries && juriesList.trim()) {
                    const testJuryNames = juriesList.split('\n')
                        .map(name => name.trim())
                        .filter(name => name.length > 0);
                    
                    // Charger les jurys existants sans mettre √† jour le textarea
                    const accountsSnap = await getDocs(collection(db, "accounts"));
                    JURIES = [];
                    accountsSnap.forEach(docSnap => {
                        const data = docSnap.data();
                        JURIES.push({
                            id: docSnap.id,
                            name: data.name || docSnap.id,
                            password: data.password || '',
                            theme: data.theme || 'light',
                            createdAt: data.createdAt,
                            rounds: data.rounds || [],
                            isPresident: data.isPresident || false
                        });
                    });
                    JURIES.sort((a, b) => {
                        const numA = parseInt(a.id.replace('jury', ''));
                        const numB = parseInt(b.id.replace('jury', ''));
                        return numA - numB;
                    });
                    
                    const existingJuryNames = new Set(JURIES.map(j => j.name.toLowerCase()));
                    
                    for (const juryName of testJuryNames) {
                        // Ignorer les doublons
                        if (existingJuryNames.has(juryName.toLowerCase())) {
                            continue;
                        }
                        
                        // Trouver le prochain ID disponible
                        let maxId = 0;
                        JURIES.forEach(j => {
                            const num = parseInt(j.id.replace('jury', ''));
                            if (num > maxId) maxId = num;
                        });
                        const newJuryId = `jury${maxId + 1}`;
                        
                        // D√©terminer si c'est le premier jury (pr√©sident)
                        const isFirstJury = JURIES.length === 0;
                        
                        // D√©terminer les tours par d√©faut
                        // Le jury est pr√©sent sur le tour actif et tous les suivants
                        // Sauf pour le rep√™chage, seul le pr√©sident acc√®de √† ce tour
                        const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
                        const activeRoundIndex = sortedRounds.findIndex(r => r.id === activeRoundId);
                        const defaultRounds = sortedRounds
                            .filter((r, index) => {
                                // Inclure le tour actif et tous les suivants
                                if (index < activeRoundIndex) return false;
                                
                                // Si c'est un rep√™chage, l'inclure seulement si c'est le pr√©sident
                                if (r.type === 'Rep√™chage') {
                                    return isFirstJury;
                                }
                                
                                return true;
                            })
                            .map(r => r.id);
                        
                        await setDoc(doc(db, "accounts", newJuryId), {
                            name: juryName,
                            password: DEFAULT_JURY_PASSWORD || '',
                            theme: 'light',
                            createdAt: new Date(),
                            isPresident: isFirstJury,
                            rounds: defaultRounds
                        });
                        
                        JURIES.push({
                            id: newJuryId,
                            name: juryName,
                            isPresident: isFirstJury,
                            rounds: defaultRounds
                        });
                        existingJuryNames.add(juryName.toLowerCase());
                        
                        juriesAdded++;
                    }
                }
                
                // Message de confirmation
                let message = '‚úì Donn√©es ajout√©es avec succ√®s !\n\n';
                if (candidatesAdded > 0) {
                    message += `üìã ${candidatesAdded} candidat(s) ajout√©(s)\n`;
                }
                if (juriesAdded > 0) {
                    message += `üë• ${juriesAdded} jury(s) ajout√©(s)\n`;
                }
                if (candidatesAdded === 0 && juriesAdded === 0) {
                    message = '‚ö†Ô∏è Aucune donn√©e ajout√©e (tous les noms existent d√©j√†).';
                }
                
                await customAlert(message);
                
                // Rafra√Æchir uniquement les tables (sans mettre √† jour les textareas)
                if (candidatesAdded > 0) {
                    // Recharger les candidats en m√©moire
                    const snap = await getDoc(doc(db, "candidats", "liste_actuelle"));
                    if (snap.exists()) {
                        CANDIDATES = snap.data().candidates || [];
                        CANDIDATES = CANDIDATES.map(c => ({
                            ...c,
                            tour: c.tour || activeRoundId || 'round1',
                            status: c.status || 'Actif'
                        }));
                    }
                    // Rafra√Æchir seulement la table
                    renderCandidateTable();
                }
                
                if (juriesAdded > 0) {
                    // Recharger les jurys en m√©moire
                    const accountsSnap = await getDocs(collection(db, "accounts"));
                    JURIES = [];
                    accountsSnap.forEach(docSnap => {
                        const data = docSnap.data();
                        JURIES.push({
                            id: docSnap.id,
                            name: data.name || docSnap.id,
                            password: data.password || '',
                            theme: data.theme || 'light',
                            createdAt: data.createdAt,
                            rounds: data.rounds || [],
                            isPresident: data.isPresident || false
                        });
                    });
                    JURIES.sort((a, b) => {
                        const numA = parseInt(a.id.replace('jury', ''));
                        const numB = parseInt(b.id.replace('jury', ''));
                        return numA - numB;
                    });
                    // Rafra√Æchir seulement la table
                    renderJuryTable();
                }
            } catch (e) {
                console.error('Erreur:', e);
                await customAlert('‚ùå Erreur lors de l\'insertion des donn√©es de test:\n' + e.message);
            }
        };

        window.autoFillActiveRound = async () => {
            try {
                // V√©rifier qu'il y a un tour actif
                if (!activeRoundId) {
                    await customAlert("Aucun tour actif d√©fini. Veuillez s√©lectionner un tour actif dans l'onglet 'Tours'.");
                    return;
                }
                
                // Trouver le nom du tour actif
                const activeRound = ROUNDS.find(r => r.id === activeRoundId);
                const roundName = activeRound ? activeRound.name : activeRoundId;
                
                if (!await customConfirm(`Auto-remplir les notes des candidats actifs du tour "${roundName}" avec des notes de test ?\n\nüìä Notes : 5, 10, 15 ou 20\n‚ö†Ô∏è ~15% des candidats seront √©limin√©s (note "EL")`)) {
                    return;
                }
                
                console.log(`üîÑ Auto-remplissage pour le tour: ${roundName} (${activeRoundId})`);
                
                // D√©sactiver temporairement le listener pour √©viter les rafra√Æchissements multiples
                console.log('‚è∏Ô∏è D√©sactivation temporaire du listener...');
                const wasListenerActive = !!scoresListener;
                if (scoresListener) {
                    scoresListener(); // Unsubscribe
                    scoresListener = null;
                }
                
                // Charger les candidats
                const candidatesDoc = await getDoc(doc(db, "candidats", "liste_actuelle"));
                if (!candidatesDoc.exists()) {
                    await customAlert("Aucun candidat trouv√©");
                    if (wasListenerActive) {
                        isFirstSnapshot = true;
                        setupScoresListener();
                    }
                    return;
                }
                const allCandidates = candidatesDoc.data().candidates || [];
                console.log(`üìã Total candidats: ${allCandidates.length}`);
                
                // Filtrer les candidats actifs du tour en cours
                const candidatesInRound = allCandidates.filter(c => c.tour === activeRoundId);
                const activeCandidatesInRound = candidatesInRound.filter(c => 
                    c.status === 'Actif' || c.status === 'Reset'
                );
                console.log(`üéØ Candidats dans le tour "${roundName}": ${candidatesInRound.length} (dont ${activeCandidatesInRound.length} actifs)`);
                console.log(`üìä D√©tail statuts:`, candidatesInRound.map(c => `${c.name}(${c.status})`).join(', '));
                
                if (activeCandidatesInRound.length === 0) {
                    await customAlert(`Aucun candidat actif trouv√© pour le tour "${roundName}".\n\nV√©rifiez que:\n- Des candidats existent\n- Ils sont assign√©s au tour "${roundName}"\n- Leur statut est "Actif" ou "Reset"`);
                    if (wasListenerActive) {
                        isFirstSnapshot = true;
                        setupScoresListener();
                    }
                    return;
                }
                
                // Charger les jurys
                await loadJuries();
                
                // Filtrer les jurys pr√©sents sur le tour actif
                const juriesOnActiveRound = JURIES.filter(jury => {
                    return jury.rounds && jury.rounds.includes(activeRoundId);
                });
                console.log(`üë• Jurys charg√©s: ${JURIES.length}, pr√©sents sur le tour actif: ${juriesOnActiveRound.length}`);
                console.log(`üë• D√©tail des jurys pr√©sents:`, juriesOnActiveRound.map(j => `${j.name} (id=${j.id})`).join(', '));
                
                if (juriesOnActiveRound.length === 0) {
                    await customAlert(`Aucun jury n'est configur√© pour √™tre pr√©sent sur le tour "${roundName}".\n\nVeuillez d'abord configurer les tours de pr√©sence des jurys dans l'onglet 'Jury'.`);
                    if (wasListenerActive) {
                        isFirstSnapshot = true;
                        setupScoresListener();
                    }
                    return;
                }
                
                // Charger tous les scores existants pour ce tour en UNE SEULE requ√™te
                const existingScoresQuery = query(
                    collection(db, "scores"),
                    where("roundId", "==", activeRoundId)
                );
                const existingScoresSnap = await getDocs(existingScoresQuery);
                const existingScoresSet = new Set();
                existingScoresSnap.forEach(docSnap => {
                    const data = docSnap.data();
                    existingScoresSet.add(`${data.candidateId}_${data.juryId}`);
                });
                console.log(`üìä Scores existants dans ce tour: ${existingScoresSet.size}`);
                
                // Pr√©parer les scores √† cr√©er en batch
                const batch = writeBatch(db);
                let scoresCreated = 0;
                let scoresSkipped = 0;
                const qualifiedCandidates = [];
                let eliminatedCount = 0;
                
                // Fonction pour g√©n√©rer une note al√©atoire (5, 10, 15 ou 20)
                const randomScore = () => {
                    const scores = [5, 10, 15, 20];
                    return scores[Math.floor(Math.random() * scores.length)];
                };
                
                // S√©lectionner environ 15% des candidats pour recevoir des notes "EL"
                const eliminationRate = 0.15;
                const eliminatedCandidateIds = new Set();
                const candidateCount = activeCandidatesInRound.length;
                const eliminationCount = Math.floor(candidateCount * eliminationRate);
                
                // M√©langer et s√©lectionner al√©atoirement les candidats qui recevront des "EL"
                const shuffledCandidates = [...activeCandidatesInRound].sort(() => Math.random() - 0.5);
                for (let i = 0; i < eliminationCount && i < shuffledCandidates.length; i++) {
                    eliminatedCandidateIds.add(shuffledCandidates[i].id);
                }
                
                console.log(`üé≤ ${eliminationCount} candidat(s) (${Math.round(eliminationRate * 100)}%) recevront des notes "EL":`, Array.from(eliminatedCandidateIds));
                
                for (const candidate of activeCandidatesInRound) {
                    let candidateHasAllScores = true;
                    
                    for (const jury of juriesOnActiveRound) {
                        const key = `${candidate.id}_${jury.id}`;
                        
                        // V√©rifier si le score existe d√©j√†
                        if (existingScoresSet.has(key)) {
                            scoresSkipped++;
                            console.log(`‚è≠Ô∏è Score existant ignor√©: candidateId=${candidate.id}, juryId=${jury.id}`);
                        } else {
                            // Cr√©er une r√©f√©rence de document avec un nouvel ID auto-g√©n√©r√©
                            const newScoreRef = doc(collection(db, "scores"));
                            
                            // D√©terminer si ce candidat fait partie des candidats s√©lectionn√©s pour √©limination
                            let score1, score2;
                            if (eliminatedCandidateIds.has(candidate.id)) {
                                // Ce candidat re√ßoit des notes "EL" de ce jury
                                // 70% du temps : EL pour score1 (Fond) uniquement
                                // 30% du temps : EL pour les deux scores
                                if (Math.random() < 0.7) {
                                    score1 = 'EL';
                                    score2 = randomScore();
                                } else {
                                    score1 = 'EL';
                                    score2 = 'EL';
                                }
                            } else {
                                // Candidat normal : notes al√©atoires
                                score1 = randomScore();
                                score2 = randomScore();
                            }
                            
                            const scoreData = {
                                juryId: jury.id,
                                juryName: jury.name,
                                candidateId: candidate.id,
                                roundId: activeRoundId,
                                score1: score1,
                                score2: score2,
                                timestamp: new Date()
                            };
                            batch.set(newScoreRef, scoreData);
                            scoresCreated++;
                            console.log(`‚ûï Ajout au batch: ${jury.name} ‚Üí ${candidate.name} (${score1}, ${score2})`);
                            candidateHasAllScores = false; // Au moins un nouveau score cr√©√©
                        }
                    }


                    
                }
                
                // Ex√©cuter le batch en UNE SEULE op√©ration
                console.log(`üíæ Tentative de cr√©ation de ${scoresCreated} scores en batch...`);
                if (scoresCreated > 0) {
                    try {
                        await batch.commit();
                        console.log(`‚úÖ Batch ex√©cut√© avec succ√®s ! ${scoresCreated} scores cr√©√©s.`);
                    } catch (batchError) {
                        console.error('‚ùå Erreur lors du commit du batch:', batchError);
                        throw new Error(`Erreur batch: ${batchError.message}`);
                    }
                } else {
                    console.log('‚ÑπÔ∏è Aucun score √† cr√©er (tous existent d√©j√†)');
                }
                
                // Recharger tous les scores apr√®s le commit pour calculer les scores totaux
                console.log('üìä Calcul des scores totaux pour le classement...');
                const allScoresQuery = query(
                    collection(db, "scores"),
                    where("roundId", "==", activeRoundId)
                );
                const allScoresSnap = await getDocs(allScoresQuery);
                
                // Organiser les scores par candidat et jury
                const scoresByCandidate = {};
                allScoresSnap.forEach(docSnap => {
                    const data = docSnap.data();
                    if (!scoresByCandidate[data.candidateId]) {
                        scoresByCandidate[data.candidateId] = {};
                    }
                    const juryId = data.juryId || data.juryName;
                    scoresByCandidate[data.candidateId][juryId] = {
                        score1: data.score1,
                        score2: data.score2
                    };
                });
                
                // Calculer le score total de chaque candidat
                const candidateScores = [];
                for (const candidate of activeCandidatesInRound) {
                    const candidateScoreData = scoresByCandidate[candidate.id] || {};
                    let totalScore = 0;
                    let hasAllScores = true;
                    
                    for (const jury of juriesOnActiveRound) {
                        const scores = candidateScoreData[jury.id];
                        if (!scores || 
                            !scores.score1 || scores.score1 === '-' ||
                            !scores.score2 || scores.score2 === '-') {
                            hasAllScores = false;
                            break;
                        }
                        
                        // Calculer le score (EL = 0)
                        if (scores.score1 === 'EL' || scores.score2 === 'EL') {
                            totalScore += 0;
                        } else {
                            const s1 = parseFloat(scores.score1) || 0;
                            const s2 = parseFloat(scores.score2) || 0;
                            totalScore += (s1 * 3 + s2);
                        }
                    }
                    
                    if (hasAllScores) {
                        candidateScores.push({
                            id: candidate.id,
                            name: candidate.name,
                            totalScore: totalScore
                        });
                    }
                }
                
                // Trier par score d√©croissant
                candidateScores.sort((a, b) => b.totalScore - a.totalScore);
                
                // D√©terminer le nombre de candidats √† qualifier selon nextRoundCandidates
                let qualifyCount;
                if (activeRound.nextRoundCandidates === 'ALL') {
                    qualifyCount = candidateScores.length;
                } else {
                    qualifyCount = parseInt(activeRound.nextRoundCandidates) || candidateScores.length;
                }
                
                console.log(`üìä Classement: ${candidateScores.length} candidats, ${qualifyCount} √† qualifier`);
                
                // Qualifier les N premiers, √©liminer les autres
                let qualifiedCount = 0;
                let eliminatedByRankCount = 0;
                
                candidateScores.forEach((scoreData, index) => {
                    const candidateIndex = allCandidates.findIndex(c => c.id === scoreData.id);
                    if (candidateIndex >= 0) {
                        if (index < qualifyCount) {
                            allCandidates[candidateIndex].status = 'Qualifie';
                            qualifiedCandidates.push(scoreData.id);
                            qualifiedCount++;
                            console.log(`  ‚úì ${scoreData.name}: ${scoreData.totalScore} pts ‚Üí Qualifi√© (rang ${index + 1})`);
                        } else {
                            allCandidates[candidateIndex].status = 'Elimine';
                            eliminatedByRankCount++;
                            console.log(`  ‚úó ${scoreData.name}: ${scoreData.totalScore} pts ‚Üí √âlimin√© (rang ${index + 1})`);
                        }
                    }
                });
                
                // Sauvegarder les candidats mis √† jour
                await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: allCandidates });
                console.log(`üíæ ${qualifiedCount} qualifi√©(s), ${eliminatedByRankCount} √©limin√©(s) par classement`);
                
                // Mettre √† jour le compteur d'√©limin√©s
                eliminatedCount = eliminatedByRankCount;
                
                const qualifyLimit = activeRound.nextRoundCandidates === 'ALL' ? 'Tous' : activeRound.nextRoundCandidates;
                let message = `‚úì Auto-remplissage termin√© !\n\n`;
                message += `üìä ${scoresCreated} note(s) de test cr√©√©e(s)\n`;
                message += `üèÜ Limite tour suivant: ${qualifyLimit} candidat(s)\n`;
                message += `‚úÖ ${qualifiedCandidates.length} candidat(s) qualifi√©(s) (top ${qualifiedCandidates.length})\n`;
                message += `‚ùå ${eliminatedCount} candidat(s) √©limin√©(s) par classement`;
                if (scoresSkipped > 0) {
                    message += `\n‚ö†Ô∏è ${scoresSkipped} note(s) d√©j√† existante(s) (conserv√©e(s))`;
                }
                
                // Afficher un r√©sum√© d√©taill√© dans la console
                console.log(`
üìä R√©sum√© de l'auto-remplissage:
   - Candidats actifs trouv√©s: ${activeCandidatesInRound.length}
   - Jurys pr√©sents sur ce tour: ${juriesOnActiveRound.length}
   - Scores cr√©√©s: ${scoresCreated}
   - Scores ignor√©s (existants): ${scoresSkipped}
   - Limite pour le tour suivant: ${qualifyLimit}
   - Candidats qualifi√©s: ${qualifiedCandidates.length}
   - Candidats √©limin√©s par classement: ${eliminatedCount}
   - R√®gle: si un jury met "EL", sa contribution = 0 (les autres jurys comptent normalement)
   - Op√©ration en batch: OUI ‚úÖ
                `);
                
                // Attendre un petit d√©lai pour s'assurer que Firestore a propag√© les changements
                console.log('‚è≥ Attente de la propagation Firestore...');
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Forcer le rechargement complet des candidats depuis Firestore
                console.log('üì• Rechargement des candidats depuis Firestore...');
                const refreshedDoc = await getDoc(doc(db, "candidats", "liste_actuelle"));
                if (refreshedDoc.exists()) {
                    CANDIDATES = refreshedDoc.data().candidates || [];
                    console.log(`‚úÖ ${CANDIDATES.length} candidats recharg√©s`);
                }
                
                // S'assurer que le dropdown des notes affiche le tour actif
                notesDisplayRound = activeRoundId;
                populateNotesRoundDropdown();
                
                // Rafra√Æchir l'affichage UNE SEULE FOIS AVANT de r√©activer le listener
                await loadList();
                console.log('üîÑ Rafra√Æchissement du tableau des notes...');
                await renderNotesTable();
                
                await customAlert(message);
                
                // R√©activer le listener APR√àS avoir rafra√Æchi l'affichage
                if (wasListenerActive) {
                    console.log('‚ñ∂Ô∏è R√©activation du listener...');
                    isFirstSnapshot = true; // R√©initialiser le flag pour ignorer le premier snapshot
                    setupScoresListener();
                }
            } catch (e) {
                console.error('‚ùå Erreur:', e);
                // R√©activer le listener en cas d'erreur
                if (!scoresListener) {
                    isFirstSnapshot = true;
                    setupScoresListener();
                }
                await customAlert('‚ùå Erreur lors de l\'auto-remplissage:\n' + e.message);
            }
        };

        window.confirmResetScores = async () => {
            if(!await customConfirm("Supprimer TOUTES les notes (les candidats et jurys seront conserv√©s) ?")) return;
            
            try {
                const snap = await getDocs(collection(db, "scores"));
                const batch = writeBatch(db);
                snap.docs.forEach(d => batch.delete(d.ref));
                await batch.commit();
                
                // R√©initialiser les verrous
                await setDoc(doc(db, "config", "locks"), { locks: {} });
                candidateLocks = {};
                
                await customAlert('‚úì Toutes les notes ont √©t√© supprim√©es');
                location.reload();
            } catch (e) {
                console.error('Erreur:', e);
                await customAlert('‚ùå Erreur lors de la r√©initialisation:\n' + e.message);
            }
        };
        
        window.confirmResetRoundsToDefault = async () => {
            if (!await customConfirm(`Remettre les tours √† la configuration par d√©faut ?\n\n‚ö†Ô∏è Ceci va r√©initialiser la structure des tours (6 tours standards).\n\n‚úÖ Les notes et candidats seront conserv√©s.\n\nContinuer ?`)) {
                return;
            }
            
            try {
                // Cr√©er la configuration par d√©faut des tours
                const defaultRounds = [
                    {
                        id: 'round1',
                        order: 1,
                        name: '1er tour',
                        type: 'Notation individuelle',
                        nextRoundCandidates: 'ALL',
                        active: true
                    },
                    {
                        id: 'round2',
                        order: 2,
                        name: 'Repechage 1er tour',
                        type: 'Rep√™chage',
                        nextRoundCandidates: 18,
                        active: false
                    },
                    {
                        id: 'round3',
                        order: 3,
                        name: '2eme tour',
                        type: 'Duels',
                        nextRoundCandidates: 'ALL',
                        active: false
                    },
                    {
                        id: 'round4',
                        order: 4,
                        name: 'Repechage 2eme tour',
                        type: 'Rep√™chage',
                        nextRoundCandidates: 7,
                        active: false
                    },
                    {
                        id: 'round5',
                        order: 5,
                        name: 'Demi-finale',
                        type: 'Duels',
                        nextRoundCandidates: 3,
                        active: false
                    },
                    {
                        id: 'round6',
                        order: 6,
                        name: 'Finale',
                        type: 'Duels',
                        nextRoundCandidates: 1,
                        active: false
                    }
                ];
                
                // Sauvegarder la configuration par d√©faut
                await setDoc(doc(db, "config", "rounds"), { 
                    rounds: defaultRounds,
                    activeRoundId: 'round1'
                });
                
                // Mettre √† jour les variables locales
                ROUNDS = defaultRounds;
                activeRoundId = 'round1';
                
                console.log('‚úÖ Tours r√©initialis√©s aux valeurs par d√©faut');
                
                await customAlert('‚úì Tours r√©initialis√©s avec succ√®s !\n\n6 tours cr√©√©s :\n- 1er tour (Notation individuelle)\n- Rep√™chage 1er tour\n- 2√®me tour (Duels)\n- Rep√™chage 2√®me tour\n- Demi-finale\n- Finale');
                
                // Recharger la page pour actualiser tout
                location.reload();
            } catch (e) {
                console.error('‚ùå Erreur:', e);
                await customAlert('‚ùå Erreur lors de la r√©initialisation des tours:\n' + e.message);
            }
        };

        window.confirmResetActiveRound = async () => {
            try {
                // V√©rifier qu'il y a un tour actif
                if (!activeRoundId) {
                    await customAlert("Aucun tour actif d√©fini. Veuillez s√©lectionner un tour actif dans l'onglet 'Tours'.");
                    return;
                }
                
                // Trouver le nom du tour actif
                const activeRound = ROUNDS.find(r => r.id === activeRoundId);
                const roundName = activeRound ? activeRound.name : activeRoundId;
                
                if (!await customConfirm(`R√©initialiser le tour "${roundName}" ?\n\n‚ö†Ô∏è Ceci va :\n- Supprimer toutes les notes des candidats de ce tour\n- Remettre leur statut √† "Actif"\n\nCette action est IRR√âVERSIBLE !`)) {
                    return;
                }
                
                console.log(`üîÑ R√©initialisation du tour: ${roundName} (${activeRoundId})`);
                
                // Charger les candidats
                const candidatesDoc = await getDoc(doc(db, "candidats", "liste_actuelle"));
                if (!candidatesDoc.exists()) {
                    await customAlert("Aucun candidat trouv√©");
                    return;
                }
                
                const allCandidates = candidatesDoc.data().candidates || [];
                
                // Filtrer les candidats du tour en cours
                const candidatesInRound = allCandidates.filter(c => c.tour === activeRoundId);
                console.log(`üìã Candidats du tour "${roundName}": ${candidatesInRound.length}`);
                
                if (candidatesInRound.length === 0) {
                    await customAlert(`Aucun candidat trouv√© pour le tour "${roundName}".`);
                    return;
                }
                
                // R√©cup√©rer tous les scores de ce tour
                const scoresQuery = query(
                    collection(db, "scores"),
                    where("roundId", "==", activeRoundId)
                );
                const scoresSnap = await getDocs(scoresQuery);
                console.log(`üìä Scores √† supprimer: ${scoresSnap.size}`);
                
                // Supprimer les scores en batch
                const batch = writeBatch(db);
                scoresSnap.docs.forEach(docSnap => {
                    batch.delete(docSnap.ref);
                });
                
                // Mettre √† jour les statuts des candidats √† "Actif"
                let candidatesReset = 0;
                for (const candidate of candidatesInRound) {
                    const candidateIndex = allCandidates.findIndex(c => c.id === candidate.id);
                    if (candidateIndex >= 0) {
                        allCandidates[candidateIndex].status = 'Actif';
                        candidatesReset++;
                    }
                }
                
                // Ex√©cuter le batch
                await batch.commit();
                console.log(`‚úÖ ${scoresSnap.size} score(s) supprim√©(s)`);
                
                // Sauvegarder les candidats mis √† jour
                await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: allCandidates });
                console.log(`‚úÖ ${candidatesReset} candidat(s) remis √† "Actif"`);
                
                // Supprimer les verrous pour ce tour
                if (candidateLocks) {
                    for (const candidateId of candidatesInRound.map(c => c.id)) {
                        delete candidateLocks[candidateId];
                    }
                    await setDoc(doc(db, "config", "locks"), { locks: candidateLocks });
                }
                
                await customAlert(`‚úì Tour "${roundName}" r√©initialis√© !\n\nüìä ${scoresSnap.size} note(s) supprim√©e(s)\n‚úÖ ${candidatesReset} candidat(s) remis √† "Actif"`);
                
                // Rafra√Æchir l'affichage
                CANDIDATES = allCandidates;
                await loadList();
                await renderNotesTable();
            } catch (e) {
                console.error('‚ùå Erreur:', e);
                await customAlert('‚ùå Erreur lors de la r√©initialisation du tour:\n' + e.message);
            }
        };

        window.confirmResetAllScoresAndRounds = async () => {
            if (!await customConfirm('‚ö†Ô∏è ATTENTION : R√©initialiser tous les scores et tours ?\n\n‚ùå Toutes les notes de tous les tours seront supprim√©es\nüîÑ Tous les candidats seront remis en "Actif" au premier tour\n‚úÖ Les jurys et la liste des candidats seront conserv√©s\n\nCette action est IRR√âVERSIBLE !\n\nContinuer ?')) {
                return;
            }
            
            try {
                console.log('üîÑ R√©initialisation de tous les scores et tours...');
                
                // 1. Supprimer TOUS les scores
                const scoresSnap = await getDocs(collection(db, "scores"));
                console.log(`üìä ${scoresSnap.size} score(s) √† supprimer`);
                
                const batch = writeBatch(db);
                scoresSnap.docs.forEach(docSnap => {
                    batch.delete(docSnap.ref);
                });
                await batch.commit();
                console.log('‚úÖ Tous les scores supprim√©s');
                
                // 2. Charger les candidats
                const candidatesDoc = await getDoc(doc(db, "candidats", "liste_actuelle"));
                if (!candidatesDoc.exists()) {
                    await customAlert('Aucun candidat trouv√©');
                    return;
                }
                
                const allCandidates = candidatesDoc.data().candidates || [];
                console.log(`üìã ${allCandidates.length} candidat(s) trouv√©(s)`);
                
                // 3. Trouver le premier tour (par ordre)
                const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
                const firstRound = sortedRounds.length > 0 ? sortedRounds[0] : { id: 'round1' };
                console.log(`üéØ Premier tour : ${firstRound.id} (${firstRound.name || firstRound.id})`);
                
                // 4. Remettre tous les candidats au premier tour en statut "Actif"
                allCandidates.forEach(candidate => {
                    candidate.tour = firstRound.id;
                    candidate.status = 'Actif';
                });
                
                // 5. Sauvegarder les candidats
                await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: allCandidates });
                console.log(`‚úÖ ${allCandidates.length} candidat(s) remis en "Actif" au tour ${firstRound.id}`);
                
                // 6. R√©initialiser le tour actif au premier tour
                ROUNDS.forEach(r => r.active = (r.id === firstRound.id));
                activeRoundId = firstRound.id;
                await saveRounds();
                console.log(`‚úÖ Tour actif r√©initialis√© √† ${firstRound.id}`);
                
                // 7. R√©initialiser les verrous
                await setDoc(doc(db, "config", "locks"), { locks: {} });
                console.log('‚úÖ Verrous r√©initialis√©s');
                
                await customAlert(`‚úì R√©initialisation termin√©e !\n\n‚ùå ${scoresSnap.size} note(s) supprim√©e(s)\nüîÑ ${allCandidates.length} candidat(s) remis en "Actif" au tour "${firstRound.name || firstRound.id}"\nüéØ Tour actif r√©initialis√© √† "${firstRound.name || firstRound.id}"\n‚úÖ Jurys et candidats conserv√©s`);
                
                // Rafra√Æchir l'affichage
                CANDIDATES = allCandidates;
                await loadList();
                await renderNotesTable();
            } catch (e) {
                console.error('‚ùå Erreur:', e);
                await customAlert('‚ùå Erreur lors de la r√©initialisation:\n' + e.message);
            }
        };

        window.confirmResetAll = async () => {
            const confirmation = await customPrompt('Pour confirmer la r√©initialisation TOTALE, tapez "RESET":');
            if (confirmation !== 'RESET') {
                await customAlert('R√©initialisation annul√©e');
                return;
            }
            
            try {
                // Supprimer les scores
                const scoresSnap = await getDocs(collection(db, "scores"));
                const batch1 = writeBatch(db);
                scoresSnap.docs.forEach(d => batch1.delete(d.ref));
                await batch1.commit();
                
                // Supprimer tous les jurys
                const accountsSnap = await getDocs(collection(db, "accounts"));
                const batch2 = writeBatch(db);
                accountsSnap.docs.forEach(d => batch2.delete(d.ref));
                await batch2.commit();
                
                // Supprimer les candidats
                await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: [] });
                
                // R√©initialiser les verrous
                await setDoc(doc(db, "config", "locks"), { locks: {} });
                
                await customAlert('‚úì R√©initialisation compl√®te effectu√©e\n\n- Tous les jurys supprim√©s\n- Tous les candidats supprim√©s\n- Toutes les notations supprim√©es\n- Tous les verrous supprim√©s');
                location.reload();
            } catch (e) {
                console.error('Erreur:', e);
                await customAlert('‚ùå Erreur lors de la r√©initialisation:\n' + e.message);
            }
        };

        // Export vers CSV
        // Export des notes en CSV (format √©ditable)
        window.exportNotesToCSV = async () => {
            try {
                // R√©cup√©rer les scores du tour actif
                const q = query(
                    collection(db, "scores"),
                    where("roundId", "==", activeRoundId || 'round1')
                );
                const scoresSnap = await getDocs(q);
                const juries = new Set();
                const scoresByCandidate = {};
                
                scoresSnap.forEach(d => {
                    const data = d.data();
                    juries.add(data.juryName);
                    
                    if (!scoresByCandidate[data.candidateId]) {
                        scoresByCandidate[data.candidateId] = {};
                    }
                    scoresByCandidate[data.candidateId][data.juryName] = data;
                });
                
                const sortedJuries = Array.from(juries).sort();
                
                // Cr√©er l'en-t√™te CSV
                let csv = 'CandidatID,CandidatNom';
                sortedJuries.forEach(jury => {
                    csv += `,${jury}_Note1,${jury}_Note2`;
                });
                csv += '\n';
                
                // Ajouter les donn√©es
                CANDIDATES.forEach(c => {
                    let row = `${c.id},"${c.name}"`;
                    
                    sortedJuries.forEach(jury => {
                        const scores = scoresByCandidate[c.id]?.[jury];
                        let note1 = scores?.score1 || '-';
                        let note2 = scores?.score2 || '-';
                        
                        // Remplacer "EL" par "0" dans l'export CSV
                        if (note1 === 'EL') note1 = '0';
                        if (note2 === 'EL') note2 = '0';
                        
                        row += `,${note1},${note2}`;
                    });
                    
                    csv += row + '\n';
                });
                
                // T√©l√©charger
                const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                const date = new Date().toISOString().split('T')[0];
                link.setAttribute('href', url);
                link.setAttribute('download', `notes_${date}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                alert('‚úì Export CSV r√©ussi !');
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de l\'export: ' + e.message);
            }
        };
        
        // Import des notes depuis CSV
        window.importNotesFromCSV = async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!await confirm(`‚ö†Ô∏è ATTENTION ‚ö†Ô∏è\n\nImporter depuis CSV va :\n- V√©rifier le format du fichier\n- Mettre √† jour les notes existantes\n- Cr√©er de nouvelles notes si n√©cessaire\n\nLes notes actuelles seront modifi√©es !\n\nContinuer ?`)) {
                event.target.value = '';
                return;
            }
            
            try {
                const text = await file.text();
                const lines = text.split('\n').filter(l => l.trim());
                
                if (lines.length < 2) {
                    throw new Error('Fichier CSV vide ou invalide');
                }
                
                // Parser l'en-t√™te
                const header = lines[0].split(',').map(h => h.trim());
                
                // V√©rifier le format
                if (header[0] !== 'CandidatID' || header[1] !== 'CandidatNom') {
                    throw new Error('Format CSV invalide. L\'en-t√™te doit commencer par: CandidatID,CandidatNom');
                }
                
                // Extraire les jurys de l'en-t√™te et mapper aux IDs
                await loadJuries();  // S'assurer que JURIES est charg√©
                const juries = [];
                for (let i = 2; i < header.length; i += 2) {
                    const juryName = header[i].replace('_Note1', '');
                    // Chercher le juryId correspondant
                    const jury = JURIES.find(j => j.name === juryName);
                    juries.push({
                        name: juryName,
                        id: jury ? jury.id : null
                    });
                }
                
                if (juries.length === 0) {
                    throw new Error('Aucun jury trouv√© dans le fichier CSV');
                }
                
                let imported = 0;
                let errors = [];
                
                // Parser chaque ligne
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = line.match(/(".*?"|[^,]+)/g).map(v => v.replace(/^"|"$/g, '').trim());
                    
                    const candidatId = values[0];
                    
                    // V√©rifier que le candidat existe
                    const candidate = CANDIDATES.find(c => c.id === candidatId);
                    if (!candidate) {
                        errors.push(`Ligne ${i + 1}: Candidat "${candidatId}" non trouv√©`);
                        continue;
                    }
                    
                    // Importer les notes pour chaque jury
                    for (let j = 0; j < juries.length; j++) {
                        const jury = juries[j];
                        const juryName = jury.name;
                        const juryId = jury.id;
                        const note1 = values[2 + j * 2];
                        const note2 = values[3 + j * 2];
                        
                        // V√©rifier que le jury existe
                        if (!juryId) {
                            errors.push(`Ligne ${i + 1}: Jury "${juryName}" non trouv√© dans la base de donn√©es`);
                            continue;
                        }
                        
                        // Valider les notes
                        // Accepter: '-', '5', '10', '15', '20', 'EL', 'Elimine' pour les tours normaux
                        // Accepter aussi '0' et '1' pour les tours de rep√™chage
                        const validValues = ['-', '5', '10', '15', '20', 'EL', 'Elimine', '0', '1'];
                        if (!validValues.includes(note1) || !validValues.includes(note2)) {
                            errors.push(`Ligne ${i + 1}, ${juryName}: Notes invalides (${note1}, ${note2})`);
                            continue;
                        }
                        
                        // Chercher si un score existe d√©j√† pour ce tour (par juryId)
                        const q = query(
                            collection(db, "scores"),
                            where("candidateId", "==", candidatId),
                            where("juryId", "==", juryId),
                            where("roundId", "==", activeRoundId || 'round1')
                        );
                        const existingScores = await getDocs(q);
                        
                        const scoreData = {
                            candidateId: candidatId,
                            juryId: juryId,
                            juryName: juryName,
                            roundId: activeRoundId || 'round1',
                            score1: note1,
                            score2: note2,
                            timestamp: new Date()
                        };
                        
                        if (!existingScores.empty) {
                            // Mettre √† jour
                            await setDoc(doc(db, "scores", existingScores.docs[0].id), scoreData);
                        } else {
                            // Cr√©er
                            await addDoc(collection(db, "scores"), scoreData);
                        }
                        
                        imported++;
                    }
                }
                
                event.target.value = '';
                
                let message = `‚úì Import termin√© !\n\n${imported} note(s) import√©e(s)`;
                if (errors.length > 0) {
                    message += `\n\n‚ö†Ô∏è ${errors.length} erreur(s) :\n${errors.slice(0, 5).join('\n')}`;
                    if (errors.length > 5) {
                        message += `\n... et ${errors.length - 5} autre(s)`;
                    }
                }
                
                alert(message);
                
                // Rafra√Æchir l'affichage (les deux fonctions sont async)
                await renderNotesTable();
                await loadResults();
                
                console.log('‚úÖ Tableau recharg√© apr√®s import CSV');
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de l\'import: ' + e.message);
                event.target.value = '';
            }
        };

        window.exportToExcel = async () => {
            if (!CANDIDATES.length || !Object.keys(aggregatedData).length) {
                await alert('Veuillez d\'abord charger les r√©sultats (bouton "Charger et Calculer")');
                return;
            }

            // R√©cup√©rer les jurys
            const juries = new Set();
            Object.values(aggregatedData).forEach(candidate => {
                Object.keys(candidate.juryScores).forEach(jury => juries.add(jury));
            });
            const sortedJuries = Array.from(juries).sort();

            // Cr√©er l'en-t√™te CSV
            let csv = 'Candidat,' + sortedJuries.join(',') + ',Total\n';

            // Ajouter les donn√©es des candidats
            CANDIDATES.forEach(c => {
                const data = aggregatedData[c.id];
                if (!data.hasScores) return;

                let row = `"${c.name}",`;
                
                // Scores par jury
                sortedJuries.forEach((jury, index) => {
                    const scoreObj = data.juryScores[jury];
                    if (scoreObj) {
                        // Remplacer "EL" par "0" dans l'export
                        let score1Display = scoreObj.score1 === 'EL' ? '0' : scoreObj.score1;
                        let score2Display = scoreObj.score2 === 'EL' ? '0' : scoreObj.score2;
                        
                        // Recalculer le score pond√©r√© pour l'export
                        let weightedScore = 0;
                        if (scoreObj.score1 && scoreObj.score1 !== '-' && 
                            scoreObj.score2 && scoreObj.score2 !== '-') {
                            // Si un score est "EL", le score pond√©r√© = 0
                            if (scoreObj.score1 === 'EL' || scoreObj.score2 === 'EL') {
                                weightedScore = 0;
                            } else {
                                weightedScore = (parseInt(scoreObj.score1) * 3) + parseInt(scoreObj.score2);
                            }
                        }
                        row += `"${score1Display}|${score2Display} (${weightedScore})"`;
                    } else {
                        row += '-';
                    }
                    if (index < sortedJuries.length - 1) row += ',';
                });

                // Total
                row += `,${data.total}`;
                csv += row + '\n';
            });

            // T√©l√©charger le fichier
            const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            const date = new Date().toISOString().split('T')[0];
            link.setAttribute('href', url);
            link.setAttribute('download', `resultats_concours_${date}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };

        // Export du podium en image
        window.exportPodiumToImage = async () => {
            const podiumTable = document.getElementById('podium-table');
            
            if (!podiumTable || !podiumTable.querySelector('tbody').children.length) {
                alert('Veuillez d\'abord charger les r√©sultats (bouton "Charger et Calculer")');
                return;
            }

            try {
                // V√©rifier si html2canvas est charg√©
                if (typeof html2canvas === 'undefined') {
                    alert('Erreur: html2canvas n\'est pas charg√©');
                    return;
                }

                // Cr√©er un conteneur temporaire avec le titre
                const container = document.createElement('div');
                container.style.padding = '30px';
                container.style.background = 'white';
                container.style.width = 'fit-content';
                
                const title = document.createElement('h1');
                title.textContent = 'Classement Officiel - Concours d\'√âloquence';
                title.style.color = '#007bff';
                title.style.textAlign = 'center';
                title.style.marginBottom = '20px';
                title.style.fontSize = '24px';
                
                const tableClone = podiumTable.cloneNode(true);
                tableClone.style.fontSize = '16px';
                
                container.appendChild(title);
                container.appendChild(tableClone);
                
                // Ajouter temporairement au document
                container.style.position = 'absolute';
                container.style.left = '-9999px';
                document.body.appendChild(container);

                // Capturer avec html2canvas
                const canvas = await html2canvas(container, {
                    backgroundColor: '#ffffff',
                    scale: 2, // Haute r√©solution
                    logging: false
                });

                // Supprimer le conteneur temporaire
                document.body.removeChild(container);

                // T√©l√©charger l'image
                const date = new Date().toISOString().split('T')[0];
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `podium_concours_${date}.png`;
                    link.click();
                    URL.revokeObjectURL(url);
                });

            } catch (e) {
                console.error('Erreur lors de l\'export:', e);
                alert('Erreur lors de la g√©n√©ration de l\'image: ' + e.message);
            }
        };

        // Modal pour changement de mot de passe
        window.showPasswordModal = async function() {
            try {
                // 1. Demander le mot de passe actuel
                const currentPassword = await prompt('√âtape 1/3: Entrez le mot de passe actuel:');
                
                if (!currentPassword) {
                    return; // Annul√©
                }

                // V√©rifier le mot de passe actuel
                const adminDoc = await getDoc(doc(db, "config", "admin"));
                const storedPassword = adminDoc.exists() ? adminDoc.data().password : 'admin';

                if (currentPassword !== storedPassword) {
                    alert('Mot de passe actuel incorrect !');
                    return;
                }

                // 2. Demander le nouveau mot de passe
                const newPassword = await prompt('√âtape 2/3: Entrez le nouveau mot de passe:\n(minimum 4 caract√®res)');
                
                if (!newPassword) {
                    return; // Annul√©
                }

                if (newPassword.length < 4) {
                    alert('Le mot de passe doit contenir au moins 4 caract√®res');
                    return;
                }

                // 3. Demander la confirmation
                const confirmPassword = await prompt('√âtape 3/3: Confirmez le nouveau mot de passe:');
                
                if (!confirmPassword) {
                    return; // Annul√©
                }

                if (newPassword !== confirmPassword) {
                    alert('Les mots de passe ne correspondent pas !');
                    return;
                }

                // Tout est OK, changer le mot de passe
                await changeAdminPassword(newPassword);
                
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la v√©rification du mot de passe');
            }
        };

        // Changement du mot de passe administrateur
        async function changeAdminPassword(newPassword) {
            try {
                await setDoc(doc(db, "config", "admin"), { password: newPassword });
                alert('Mot de passe chang√© avec succ√®s !');
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors du changement de mot de passe');
            }
        }

        // D√©connexion admin
        window.adminLogout = async function() {
            if (await confirm('Voulez-vous vous d√©connecter ?')) {
                window.location.href = 'index.html';
            }
        };

        // Theme Toggle Logic - Propre √† l'admin
        function initTheme() {
            const savedTheme = localStorage.getItem('theme_admin') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            const toggle = document.getElementById('theme-toggle');
            if (toggle) {
                if (savedTheme === 'dark') {
                    toggle.classList.add('active');
                }
            }
        }

        window.toggleTheme = async function() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            
            // Sauvegarder avec une cl√© sp√©cifique √† l'admin
            localStorage.setItem('theme_admin', newTheme);
            
            // Sauvegarder aussi dans Firebase avec merge pour pr√©server le mot de passe
            try {
                await setDoc(doc(db, "config", "admin"), {
                    theme: newTheme
                }, { merge: true });
            } catch (e) {
                console.log('Impossible de sauvegarder le th√®me admin dans Firebase:', e);
            }
            
            const toggle = document.getElementById('theme-toggle');
            if (toggle) {
                if (newTheme === 'dark') {
                    toggle.classList.add('active');
                } else {
                    toggle.classList.remove('active');
                }
            }
        };

        window.toggleMenu = function() {
            const menu = document.getElementById('menu-content');
            if (menu) {
                menu.classList.toggle('active');
            }
        };

        // Close menu when clicking outside
        document.addEventListener('click', function(event) {
            const menu = document.getElementById('menu-content');
            const burgerIcon = document.querySelector('.burger-icon');
            if (menu && burgerIcon && !menu.contains(event.target) && !burgerIcon.contains(event.target)) {
                menu.classList.remove('active');
            }
        });

        // Initialize theme on page load
        initTheme();
    </script>
    
    <script>window.useCustomModals = true;</script>
    <script src="modal.js"></script>
</body>
</html>