<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="description" content="Tableau de bord administrateur - Gestion des r√©sultats du concours">
    <meta name="theme-color" content="#667eea">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <title>üèÜ Administration - R√©sultats Concours</title>
    <style>
        /* Modern Admin Dashboard Styles - Responsive */
        :root {
            /* Light Mode (Default) */
            --primary: #007bff;
            --success: #28a745;
            --warning: #ffc107;
            --danger: #dc3545;
            --danger-color: #dc3545;
            --danger-dark: #c82333;
            --neutral: #6c757d;
            --neutral-color: #6c757d;
            --success-color: #28a745;
            --bg-secondary: #e9ecef;
            --white: #ffffff;
            --text-color: #333;
            --text-secondary: #666;
            --border-color: #ddd;
            --bg-gradient-start: #667eea;
            --bg-gradient-end: #764ba2;
            --card-bg: #ffffff;
            --input-bg: #ffffff;
            --info-bg-start: #e3f2fd;
            --info-bg-end: #bbdefb;
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 8px rgba(0,0,0,0.12);
            --shadow-lg: 0 8px 16px rgba(0,0,0,0.15);
            --radius: 10px;
            --spacing: 20px;
        }

        /* Dark Mode */
        [data-theme="dark"] {
            --primary: #4da3ff;
            --success: #4caf50;
            --warning: #ffa726;
            --danger: #f44336;
            --danger-color: #f44336;
            --danger-dark: #d32f2f;
            --neutral: #9e9e9e;
            --neutral-color: #9e9e9e;
            --success-color: #4caf50;
            --bg-secondary: #3a3a4a;
            --white: #ffffff;
            --text-color: #e0e0e0;
            --text-secondary: #b0b0b0;
            --border-color: #444;
            --bg-gradient-start: #3d5266;
            --bg-gradient-end: #1a252f;
            --card-bg: #2d2d3a;
            --input-bg: #3a3a4a;
            --info-bg-start: #1e3a5f;
            --info-bg-end: #2c4f7c;
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.5);
        }

        * {
            box-sizing: border-box;
        }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            padding: clamp(12px, 3vw, 20px);
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            margin: 0;
            min-height: 100vh;
            line-height: 1.6;
            transition: background 0.3s ease;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--card-bg);
            padding: clamp(15px, 4vw, 40px);
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            position: relative;
        }

        h1 { 
            color: var(--primary);
            border-bottom: 3px solid var(--primary);
            padding-bottom: 15px;
            margin-top: 0;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            font-weight: 700;
        }

        h2 { 
            color: var(--primary);
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
            margin-top: var(--spacing);
            font-size: clamp(1.2rem, 3vw, 1.8rem);
            font-weight: 600;
        }

        /* Action Buttons */
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: var(--spacing);
        }

        .action-button { 
            padding: clamp(10px, 2vw, 14px) clamp(16px, 3vw, 24px);
            font-size: clamp(0.95rem, 2vw, 1.1rem);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-sm);
            flex: 1 1 auto;
            min-width: 140px;
        }

        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .action-button:active {
            transform: translateY(0);
        }

        .load-button { 
            background: linear-gradient(135deg, var(--success) 0%, #1e7e34 100%);
            color: white;
        }

        .export-button { 
            background: linear-gradient(135deg, var(--warning) 0%, #e0a800 100%);
            color: #212529;
        }

        .export-button.excel { 
            background: linear-gradient(135deg, var(--primary) 0%, #0056b3 100%);
            color: white;
        }
        
        .import-button {
            background: linear-gradient(135deg, #ff8c00 0%, #ff6b00 100%) !important;
            color: white !important;
        }

        /* Candidate Zone */
        .candidate-zone { 
            margin-top: 10px;
            padding: clamp(15px, 3vw, 25px);
            border: 2px solid var(--border-color);
            background: var(--input-bg);
            border-radius: var(--radius);
            box-shadow: var(--shadow-sm);
        }

        .candidate-zone h2 {
            margin-top: 0;
            color: var(--primary);
        }

        .candidate-zone h3 {
            margin-top: 0;
            margin-bottom: 10px;
        }

        .candidate-zone textarea { 
            width: 100%;
            min-height: 120px;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-family: inherit;
            font-size: clamp(0.95rem, 2vw, 1.05rem);
            transition: all 0.3s ease;
            resize: vertical;
            background: var(--card-bg);
            color: var(--text-color);
        }

        .candidate-zone textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
        }

        /* Tables */
        .table-container {
            overflow-x: auto;
            overflow-y: visible;
            max-width: 100%;
            margin: var(--spacing) 0;
            border-radius: var(--radius);
            box-shadow: var(--shadow-md);
            /* Permettre le d√©filement horizontal pour les tableaux avec beaucoup de colonnes */
            -webkit-overflow-scrolling: touch;
        }
        
        /* S'assurer que les tableaux ne sont pas tronqu√©s */
        .table-container table {
            min-width: max-content;
        }

        #scores-matrix { 
            width: 100%;
            border-collapse: collapse;
            background: var(--card-bg);
            font-size: clamp(0.8rem, 1.5vw, 0.95rem);
        }

        #scores-matrix th, #scores-matrix td { 
            border: 1px solid var(--border-color);
            padding: clamp(8px, 2vw, 12px);
            text-align: center;
            color: var(--text-color);
        }

        #scores-matrix th { 
            background: var(--input-bg);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            color: var(--text-color);
            cursor: pointer;
            user-select: none;
        }
        
        #scores-matrix th:hover {
            background: var(--border-color);
        }
        
        #scores-matrix th.sorted-asc::after {
            content: ' ‚ñ≤';
            font-size: 0.7em;
        }
        
        #scores-matrix th.sorted-desc::after {
            content: ' ‚ñº';
            font-size: 0.7em;
        }

        .detail-note { 
            font-size: 0.85em;
            color: var(--text-secondary);
            display: block;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 3px;
            margin-bottom: 5px;
        }

        .weighted-total { 
            font-weight: bold;
            color: var(--primary);
            font-size: 1.1em;
        }

        .total-score { 
            background: linear-gradient(135deg, #ffc107 0%, #ffb300 100%);
            font-weight: bold;
            font-size: 1.15em;
            color: #212529;
        }

        .eliminado { 
            background: linear-gradient(135deg, var(--danger) 0%, #c82333 100%);
            color: white;
            font-weight: 600;
        }

        /* Podium Table */
        #podium-table { 
            width: 100%;
            max-width: 800px;
            border-collapse: collapse;
            background: var(--card-bg);
            box-shadow: var(--shadow-md);
            border-radius: var(--radius);
            overflow: hidden;
        }

        #podium-table th, #podium-table td { 
            border: 1px solid var(--border-color);
            padding: clamp(10px, 2.5vw, 15px);
            text-align: center;
            color: var(--text-color);
        }

        #podium-table th {
            background: var(--neutral-color);
            color: var(--white);
            font-weight: 600;
        }

        #podium-table td {
            color: var(--text-color);
        }

        .rank-1 { 
            background: linear-gradient(135deg, gold 0%, #ffed4e 100%);
            font-weight: bold;
            font-size: 1.1em;
        }
        
        .rank-1 td {
            color: #212529 !important;
        }

        .rank-2 { 
            background: linear-gradient(135deg, silver 0%, #e0e0e0 100%);
            font-weight: bold;
            font-size: 1.05em;
        }
        
        .rank-2 td {
            color: #212529 !important;
        }

        .rank-3 { 
            background: linear-gradient(135deg, #cd7f32 0%, #b87333 100%);
            font-weight: bold;
        }
        
        .rank-3 td {
            color: white !important;
        }

        .eliminated-row { 
            background: linear-gradient(135deg, var(--neutral) 0%, #5a6268 100%);
            color: white;
            opacity: 0.8;
        }

        /* Reset Zone */
        .reset-zone { 
            margin-top: 50px;
            padding: clamp(15px, 3vw, 25px);
            border: 3px solid var(--danger-color);
            background: rgba(220, 53, 69, 0.1);
            border-radius: var(--radius);
            box-shadow: var(--shadow-sm);
        }

        .reset-zone h2 {
            color: var(--danger-color);
            margin-top: 0;
        }
        
        .reset-zone p {
            color: var(--text-color);
        }

        .reset-zone .action-button {
            background: linear-gradient(135deg, var(--danger-color) 0%, var(--danger-dark) 100%);
            color: white;
        }

        hr {
            border: none;
            border-top: 2px solid var(--border-color);
            margin: calc(var(--spacing) * 1.5) 0;
        }

        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            gap: 5px;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: var(--spacing);
            flex-wrap: wrap;
        }

        .tab-btn {
            padding: 12px 24px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .tab-btn:hover {
            color: var(--primary);
            background: rgba(0, 123, 255, 0.05);
        }

        .tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Candidate Table */
        .candidate-table {
            width: 100%;
            border-collapse: collapse;
            margin: var(--spacing) 0;
        }

        .candidate-table th,
        .candidate-table td {
            border: 1px solid var(--border-color);
            padding: 12px;
            text-align: left;
            color: var(--text-color);
        }

        .candidate-table th {
            background: var(--input-bg);
            font-weight: 600;
            color: var(--text-color);
        }

        .candidate-table input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background: var(--card-bg);
            color: var(--text-color);
            font-family: inherit;
        }

        .candidate-table .actions {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2em;
            padding: 4px 8px;
            transition: all 0.3s ease;
        }

        .icon-btn:hover {
            transform: scale(1.2);
        }

        .icon-btn.delete {
            color: var(--danger-color);
        }

        .icon-btn.reset {
            color: var(--warning);
        }

        .icon-btn.lock {
            color: var(--neutral-color);
        }

        .icon-btn.lock.locked {
            color: var(--danger-color);
        }

        /* Notes Table */
        .notes-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
            table-layout: auto;
        }
        
        #notes-table {
            width: max-content;
            min-width: 100%;
        }

        .notes-table th,
        .notes-table td {
            border: 1px solid var(--border-color);
            padding: 8px;
            text-align: center;
            overflow: visible;
            color: var(--text-color);
        }

        .notes-table th {
            background: var(--input-bg);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            color: var(--text-color);
        }

        .notes-table select {
            width: 100%;
            min-width: 80px;
            max-width: 90px;
            padding: 6px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: var(--card-bg);
            color: var(--text-color);
            text-align: center;
            font-size: 14px;
            font-family: inherit;
        }

        .notes-table .candidate-name {
            text-align: left;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .notes-table .locked-cell {
            background: rgba(220, 53, 69, 0.1);
        }

        .notes-table .col-actions {
            width: 100px;
        }

        .notes-table .col-candidate {
            width: 150px;
        }

        .notes-table .col-score {
            min-width: 90px;
            width: 90px;
            text-align: center;
        }

        /* Burger Menu & Theme Toggle */
        .burger-menu {
            position: absolute;
            top: var(--spacing);
            right: var(--spacing);
            z-index: 9999;
        }

        .burger-icon {
            width: 36px;
            height: 36px;
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 4px;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-sm);
        }

        .burger-icon:hover {
            box-shadow: var(--shadow-md);
        }

        .burger-icon span {
            width: 20px;
            height: 2px;
            background: var(--text-color);
            transition: all 0.3s ease;
        }

        .burger-menu-content {
            position: absolute;
            top: 45px;
            right: 0;
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 5px;
            box-shadow: var(--shadow-lg);
            padding: 0;
            min-width: 200px;
            display: none;
            overflow: hidden;
            z-index: 10000;
        }

        .burger-menu-content.active {
            display: block;
        }

        .burger-menu-content > * {
            padding: 12px;
        }

        .burger-menu-content > *:not(:last-child) {
            border-bottom: 1px solid var(--border-color);
        }

        .theme-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: var(--text-color);
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: var(--neutral-color);
            border-radius: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-switch.active {
            background: var(--primary);
        }

        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(24px);
        }

        .menu-item {
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 12px;
            color: var(--text-color);
            border: none;
            background: transparent;
            width: 100%;
            text-align: left;
            font-size: clamp(0.9rem, 2vw, 1rem);
            font-family: inherit;
            margin: 0;
        }

        .menu-item:hover {
            background: var(--info-bg-start, rgba(0, 123, 255, 0.1));
        }

        #menu-content .menu-item {
            padding: 12px;
        }

        /* Responsive Design */
        @media (max-width: 767px) {
            .button-group {
                flex-direction: column;
            }

            .action-button {
                width: 100%;
                min-width: unset;
            }

            #scores-matrix {
                font-size: 0.75rem;
            }

            #scores-matrix th,
            #scores-matrix td {
                padding: 6px;
            }

            #podium-table {
                font-size: 0.85rem;
            }
        }

        @media (min-width: 768px) and (max-width: 1023px) {
            .button-group {
                justify-content: flex-start;
            }

            .action-button {
                flex: 0 1 calc(50% - 6px);
            }
        }

        @media (min-width: 1024px) {
            .action-button {
                flex: 0 1 auto;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .action-button {
                min-height: 44px;
            }
        }

        /* Print styles */
        @media print {
            body {
                background: white;
            }

            .container {
                box-shadow: none;
            }

            .candidate-zone,
            .reset-zone,
            .action-button {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="burger-menu">
            <div class="burger-icon" onclick="toggleMenu()">
                <span></span>
                <span></span>
                <span></span>
            </div>
            <div class="burger-menu-content" id="menu-content">
                <div class="theme-toggle">
                    <span>Mode sombre</span>
                    <div class="toggle-switch" id="theme-toggle" onclick="toggleTheme()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
                <div class="menu-item" onclick="showPasswordModal()">
                    <span>Changer le mot de passe</span>
                </div>
                <div class="menu-item" onclick="adminLogout()" style="color: var(--danger-color); font-weight: 600;">
                    <span>D√©connexion</span>
                </div>
            </div>
        </div>

    <h1>Tableau de bord Administrateur</h1>
    
        <!-- Tab Navigation -->
        <div class="tab-navigation">
            <button class="tab-btn active" onclick="switchTab('candidats')">Candidats</button>
            <button class="tab-btn" onclick="switchTab('jury')">Jury</button>
            <button class="tab-btn" onclick="switchTab('tours')">Tours</button>
            <button class="tab-btn" onclick="switchTab('notes')">Notes</button>
            <button class="tab-btn" onclick="switchTab('podium')">Podium</button>
            <button class="tab-btn" onclick="switchTab('duels')">Duels</button>
            <button class="tab-btn" onclick="switchTab('activation-classements')">Activation classements</button>
            <button class="tab-btn" onclick="switchTab('reinitialiser')">R√©initialiser</button>
        </div>

        <!-- TAB 1: CANDIDATS -->
        <div id="tab-candidats" class="tab-content active">
    <div class="candidate-zone">
                <h3 style="color: var(--text-color);">Import rapide (copier-coller)</h3>
                <p style="color: var(--text-color); font-size: 0.9em; margin: 5px 0;">Les candidats de la liste seront <strong>ajout√©s</strong> aux candidats existants (pas de remplacement).</p>
                <textarea id="candidate-names" placeholder="Un nom par ligne...&#10;Exemple:&#10;Alice Martin&#10;Bob Dupont&#10;Claire Bernard"></textarea>
                <div style="display: flex; align-items: center; gap: 8px; margin: 10px 0;">
                    <input type="checkbox" id="random-ids-checkbox" style="width: 18px; height: 18px; cursor: pointer;">
                    <label for="random-ids-checkbox" style="color: var(--text-color); cursor: pointer; font-size: 0.95em;">D√©finir des IDs al√©atoires (sinon 001, 002, 003...)</label>
                </div>
                <button onclick="importCandidates()" class="action-button" style="background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); color:white;">Ajouter les nouveaux candidats</button>
    </div>

            <h3 style="color: var(--text-color);">Liste des candidats</h3>
            <button onclick="addCandidate()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); color:white;">+ Ajouter un candidat</button>
            
            <table class="candidate-table" id="candidate-table">
                <thead>
                    <tr>
                        <th style="width: 80px;">ID</th>
                        <th>Nom du candidat</th>
                        <th style="width: 100px;">Actions</th>
                    </tr>
                </thead>
                <tbody id="candidate-table-body">
                    <!-- Rempli dynamiquement -->
                </tbody>
            </table>
    </div>

        <!-- TAB 2: JURY -->
        <div id="tab-jury" class="tab-content">
            <div class="candidate-zone" style="background: var(--primary-light, #e3f2fd); border: 2px solid var(--primary-color, #2196f3); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <h3 style="color: var(--primary-color, #1565c0);">üîë Mot de passe par d√©faut</h3>
                <p style="color: var(--text-color); font-size: 0.9em; margin: 5px 0;">Ce mot de passe sera requis pour cr√©er un nouveau compte jury et sera d√©fini par d√©faut lors de la cr√©ation.</p>
                <div style="display: flex; gap: 10px; align-items: center; margin-top: 10px;">
                    <input type="text" id="default-jury-password" placeholder="Mot de passe par d√©faut" style="flex: 1; padding: 10px; border: 2px solid var(--primary-color, #2196f3); border-radius: 6px; background: var(--input-bg); color: var(--text-color); font-size: 1em;">
                    <button onclick="saveDefaultJuryPassword()" class="action-button" style="background: linear-gradient(135deg, #2196f3 0%, #1565c0 100%); color: white;">üíæ Enregistrer</button>
                </div>
                <p style="color: var(--text-secondary); font-size: 0.85em; margin-top: 8px;">üí° Astuce : Communiquez ce mot de passe aux jurys avant le concours.</p>
            </div>

            <div class="candidate-zone" style="background: var(--info-bg-start, #fff3e0); border: 2px solid var(--warning-color, #ff9800); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <h3 style="color: var(--text-color);">üîí Verrouillage des sessions</h3>
                <p style="color: var(--text-secondary); font-size: 0.9em; margin: 5px 0;">Verrouiller emp√™che tout changement apr√®s coup : les jurys sont expuls√©s de leur session et ne peuvent plus se reconnecter tant que la session est verrouill√©e.</p>
                <p id="session-lock-status" style="color: var(--text-color); font-size: 0.9em; margin: 8px 0; font-weight: 600;"></p>
                <button type="button" id="session-lock-btn" onclick="toggleSessionLock()" class="action-button" style="padding: 10px 20px;">Chargement‚Ä¶</button>
            </div>
            
            <div class="candidate-zone">
                <h3 style="color: var(--text-color);">Import rapide (copier-coller)</h3>
                <p style="color: var(--text-color); font-size: 0.9em; margin: 5px 0;">Les jurys de la liste seront <strong>ajout√©s</strong> aux jurys existants (pas de remplacement).</p>
                <textarea id="jury-names" placeholder="Un nom par ligne...&#10;Exemple:&#10;Pierre Dubois&#10;Marie Martin&#10;Jacques Bernard"></textarea>
                <button onclick="importJuries()" class="action-button" style="background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); color:white;">Ajouter les nouveaux jurys</button>
            </div>

            <h3 style="color: var(--text-color);">Liste des jurys</h3>
            <button onclick="addJury()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); color:white;">+ Ajouter un jury</button>
            
            <table class="candidate-table" id="jury-table">
                <thead>
                    <tr>
                        <th style="width: 60px;">ID</th>
                        <th>Nom du jury</th>
                        <th style="width: 100px;">Mot de passe</th>
                        <th style="width: 150px;">Actions</th>
                    </tr>
                </thead>
                <tbody id="jury-table-body">
                    <!-- Rempli dynamiquement -->
                </tbody>
    </table>
        </div>

        <!-- TAB 3: TOURS -->
        <div id="tab-tours" class="tab-content">
            <p style="color: var(--text-secondary); margin-bottom: 20px;">
                D√©finissez les diff√©rents tours du concours. Chaque tour peut avoir un type diff√©rent.
            </p>
            
            <div style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">
                <button onclick="addRound()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); color:white;">+ Ajouter un tour</button>
                
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="active-round-select" style="color: var(--text-color); font-weight: 600;">Tour actif :</label>
                    <select id="active-round-select" onchange="setActiveRound(this.value)" style="padding: 8px 12px; border: 2px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-color); font-size: 1em; font-family: inherit; min-width: 200px;">
                        <!-- Rempli dynamiquement -->
                    </select>
                    <button onclick="finishRound()" class="action-button" style="background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); color:white; padding: 8px 16px;">‚úì Terminer le tour</button>
                </div>
            </div>
            
            <div class="table-container">
                <table class="notes-table" id="rounds-table">
                    <thead>
                        <tr>
                            <th style="width: 70px;">Actions</th>
                            <th style="width: 60px;">Ordre</th>
                            <th style="width: 20%;">Nom du tour</th>
                            <th style="min-width: 220px; width: 35%;">Type</th>
                            <th style="width: 140px;">Candidats suivants</th>
                        </tr>
                    </thead>
                    <tbody id="rounds-table-body">
                        <!-- Rempli dynamiquement -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- TAB 4: NOTES -->
        <div id="tab-notes" class="tab-content">
            <p style="color: var(--text-secondary); margin-bottom: 10px;">
                Saisie <strong>Fond</strong> et <strong>Forme</strong> (5, 10, 15, 20 ou √âlimin√©). Les notes peuvent √™tre identiques (Fond = Forme). Modifications sauvegard√©es automatiquement.
            </p>
            <p id="notes-validated-message" style="display: none; margin-bottom: 15px; padding: 12px; background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); border: 1px solid var(--success); border-radius: 8px; color: #1e7e34; font-weight: 600;">
                ‚úì Tour valid√© ‚Äî verrouillage d√©finitif (plus de modification possible).
            </p>
            <div style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 15px;">
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <label for="notes-round-select" style="color: var(--text-color); font-weight: 600;">Tour √† afficher :</label>
                        <select id="notes-round-select" onchange="changeNotesRound(this.value)" style="padding: 8px 12px; border: 2px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-color); font-size: 1em; font-family: inherit; min-width: 200px;">
                            <!-- Rempli dynamiquement -->
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="notes-filter-current-round" checked style="width: 18px; height: 18px; cursor: pointer;">
                        <label for="notes-filter-current-round" style="color: var(--text-color); cursor: pointer;">Candidats en cours sur ce tour</label>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                        <button id="notes-validate-round-btn" onclick="validateRoundGlobally()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); color: white;">‚úì Valider tout le tour</button>
                    </div>
                </div>
                
                <div class="button-group">
                    <button onclick="exportNotesToCSV()" class="action-button export-button excel">üì• Exporter en CSV</button>
                    <input type="file" id="csv-import-file" accept=".csv" style="display: none;" onchange="importNotesFromCSV(event)">
                    <button onclick="document.getElementById('csv-import-file').click()" class="action-button import-button">üì§ Importer depuis CSV</button>
                </div>
            </div>
            
            <div class="table-container">
                <table class="notes-table" id="notes-table">
                    <thead>
                        <tr>
                            <!-- En-t√™te g√©n√©r√© dynamiquement -->
                        </tr>
                    </thead>
                    <tbody id="notes-table-body">
                        <!-- Rempli dynamiquement -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- TAB 5: PODIUM -->
        <div id="tab-podium" class="tab-content">
    <h2>Classement Officiel</h2>
            <p style="margin: 0 0 15px 0; font-size: 0.95em; color: var(--text-secondary);">Classement final pour la r√©gie : points ¬´ Mon classement ¬ª et bonus duel (+10%) directement comptabilis√©s (ind√©pendant de l‚Äôonglet Activation classements).</p>
            
            <div style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="podium-round-select" style="color: var(--text-color); font-weight: 600;">Tour √† afficher :</label>
                    <select id="podium-round-select" onchange="changePodiumRound(this.value)" style="padding: 8px 12px; border: 2px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-color); font-size: 1em; font-family: inherit; min-width: 200px;">
                        <!-- Rempli dynamiquement -->
                    </select>
                </div>
                
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="result-limit" style="font-weight: 600; color: var(--text-color);">Nombre de candidats :</label>
                    <input type="number" id="result-limit" value="3" min="1" oninput="renderPodium()" style="width: 80px; padding: 8px; border: 2px solid var(--border-color); border-radius: 5px; background: var(--card-bg); color: var(--text-color);">
                    <button onclick="exportPodiumToImage()" class="action-button export-button">Exporter en image</button>
                </div>
            </div>
            
            <div style="margin-bottom: 20px; padding: 15px; background: var(--info-bg-start); border-radius: 8px; border: 1px solid var(--border-color);">
                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; color: var(--text-color);">
                    <input type="checkbox" id="show-podium-after-repechage" onchange="saveShowPodiumAfterRepechage(this.checked)" style="width: 18px; height: 18px; cursor: pointer;">
                    <span style="font-weight: 600;">üìä Afficher le podium au Pr√©sident apr√®s la validation du rep√™chage</span>
                </label>
                <p style="margin: 8px 0 0 28px; font-size: 0.9em; color: var(--text-muted);">
                    Si activ√©, le Pr√©sident verra le classement final apr√®s avoir valid√© les r√©sultats du rep√™chage.
                </p>
            </div>

            <div class="table-container">
    <table id="podium-table">
        <thead>
            <tr><th>Rang</th><th>Candidat</th><th>Score</th></tr>
        </thead>
        <tbody id="podium-body"></tbody>
    </table>
            </div>
        </div>

        <!-- TAB 6: DUELS -->
        <div id="tab-duels" class="tab-content">
            <h2>Duels</h2>
            <p style="color: var(--text-secondary); margin-bottom: 20px;">
                S√©lectionnez un tour de type Duels, puis ajoutez des duels un par un. Pour chaque duel, choisissez manuellement les deux candidats et le gagnant. Vous pouvez supprimer un duel individuellement.
            </p>
            <div style="margin-bottom: 20px; display: flex; flex-wrap: wrap; align-items: center; gap: 15px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="duels-round-select" style="color: var(--text-color); font-weight: 600;">Tour (Duels) :</label>
                    <select id="duels-round-select" onchange="changeDuelsRound(this.value)" style="padding: 8px 12px; border: 2px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-color); font-size: 1em; min-width: 200px;">
                        <option value="">-- S√©lectionner un tour --</option>
                    </select>
                </div>
                <button id="duels-add-btn" onclick="addDuel()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); color: white;">Ajouter un duel</button>
            </div>
            <div id="duels-list-container" style="margin-top: 20px;">
                <p id="duels-empty-msg" style="color: var(--text-secondary);">S√©lectionnez un tour de type Duels puis cliquez sur "Ajouter un duel".</p>
                <div id="duels-list" style="display: none;"></div>
            </div>
        </div>

        <!-- TAB: ACTIVATION CLASSEMENTS -->
        <div id="tab-activation-classements" class="tab-content">
            <h2>Activation classements</h2>
            <p style="color: var(--text-secondary); margin-bottom: 20px;">
                Pour chaque jur√© et chaque candidat qu'il a class√© (Mon classement), vous pouvez activer l'ajout des points au score du classement. Chaque activation est ind√©pendante. Bouton gris√© si le jur√© n'a pas attribu√© de points √† ce candidat ; d√©sactiv√© apr√®s activation.
            </p>
            <div style="margin-bottom: 20px; display: flex; flex-wrap: wrap; align-items: center; gap: 15px;">
                <label for="activation-classement-round" style="color: var(--text-color); font-weight: 600;">Tour (pour les jurys √† afficher) :</label>
                <select id="activation-classement-round" onchange="changeActivationClassementRound(this.value)" style="padding: 8px 12px; border: 2px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-color); font-size: 1em; min-width: 220px;"></select>
                <button type="button" onclick="refreshClassementFully()" class="action-button" style="margin-left: 12px; padding: 8px 16px; background: linear-gradient(135deg, #17a2b8 0%, #138496 100%); color: white;" title="Recalcule le classement √† partir des notes et candidats actuels (utile apr√®s suppression d‚Äôun candidat).">üîÑ Actualiser enti√®rement le classement</button>
            </div>
            <div id="activation-classements-loading" style="display: none; text-align: center; color: var(--text-secondary); padding: 20px;">Chargement‚Ä¶</div>
            <div id="activation-classements-empty" style="display: none; text-align: center; color: var(--text-secondary); padding: 20px;">S√©lectionnez un tour.</div>
            <div class="table-container" id="activation-classements-container" style="display: none;">
                <table class="notes-table" id="activation-classements-table" style="table-layout: auto;">
                    <thead><tr id="activation-classements-thead"></tr></thead>
                    <tbody id="activation-classements-tbody"></tbody>
                </table>
            </div>
        </div>

        <!-- TAB 7: REINITIALISER -->
        <div id="tab-reinitialiser" class="tab-content">
        <h2>Zone de Danger</h2>
            <p style="color: var(--danger-color); font-weight: 600; margin-bottom: 20px;">
                ‚ö†Ô∏è Attention: Ces actions sont irr√©versibles !
            </p>

            <div class="reset-zone" style="background: var(--info-bg-start); border: 2px solid var(--primary);">
                <h3 style="color: var(--primary);">üîß Utilitaires</h3>
                <p>V√©rifier et nettoyer la base de donn√©es : supprime les doublons, les scores orphelins (candidats/jurys supprim√©s), et les valeurs calcul√©es obsol√®tes.</p>
                <p style="font-weight: 600; color: var(--warning-color); margin-top: 10px;">‚ö†Ô∏è Recommand√© : Sauvegardez votre base de donn√©es avant de lancer cette op√©ration.</p>
                <button onclick="cleanDatabase()" class="action-button" style="background: var(--primary);">Nettoyer la base de donn√©es</button>
            </div>

            <div class="reset-zone" style="background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%); border: 2px solid #ffc107;">
                <h3 style="color: #856404;">üß™ Tests</h3>
                <p style="color: #212529;">Ins√©rer des candidats et jurys de test pour simuler rapidement un concours.</p>
                <button onclick="insertTestData()" class="action-button" style="background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%); color: #212529; margin-bottom: 10px;">üìã Ins√©rer candidats et jurys de test</button>
                
                <p style="color: #212529; margin-top: 15px;">Auto-remplir les notes des candidats actifs du tour en cours avec des <strong>notes al√©atoires de test (5, 10, 15 ou 20)</strong>.</p>
                <p style="font-weight: 600; color: #856404; margin-top: 10px;">‚ö†Ô∏è Les candidats seront <strong>qualifi√©s ou √©limin√©s</strong> selon leur classement et la limite "Candidats suivants" du tour actif.</p>
                <button onclick="autoFillActiveRound()" class="action-button" style="background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%); color: #212529;">‚úì Auto-remplir et qualifier le tour actif</button>
                <p style="color: #212529; margin-top: 15px;">Remplir <strong>tous les scores</strong> (tous tours, tous jurys, tous candidats) et <strong>bonus</strong> des classements avec des valeurs al√©atoires ‚Äî pour tests uniquement.</p>
                <button onclick="fillAllScoresAndBonusesRandomly()" class="action-button" style="background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%); color: white; margin-top: 8px;">üé≤ Remplir tous les scores et bonus al√©atoirement (tests)</button>
            </div>

            <div class="reset-zone" style="background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); border: 2px solid #28a745;">
                <h3 style="color: #1e7e34;">üíæ Sauvegarde & Restauration</h3>
                <p style="color: #212529;">T√©l√©charger toutes les donn√©es (candidats, scores, verrous, configuration) en format JSON.</p>
                <button onclick="downloadDatabase()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); color: white;">üì• T√©l√©charger la base de donn√©es</button>
                
                <p style="margin-top: 15px; color: #212529;">Restaurer les donn√©es depuis un fichier JSON de sauvegarde.</p>
                <input type="file" id="db-upload-file" accept=".json" style="display: none;" onchange="uploadDatabase(event)">
                <button onclick="document.getElementById('db-upload-file').click()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); color: white;">üì§ Restaurer depuis un fichier</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">Supprimer TOUS les jurys</h3>
                <p>Supprime tous les comptes jurys ET toutes leurs notations (mais conserve la liste des candidats).</p>
                <button onclick="confirmDeleteAllJuries()" class="action-button" style="background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); color: white;">Supprimer tous les jurys</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">R√©initialiser les scores</h3>
                <p>Remet toutes les notations √† "-" mais conserve la structure (jurys et candidats).</p>
                <button onclick="confirmResetScores()" class="action-button">R√©initialiser les scores uniquement</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">Supprimer tous les duels</h3>
                <p>Supprime tous les duels cr√©√©s pour tous les tours (2√®me tour, Demi-finale, Finale, etc.). Les jurys, candidats et notes sont conserv√©s.</p>
                <button onclick="confirmDeleteAllDuels()" class="action-button" style="background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); color: white;">Supprimer tous les duels</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">Supprimer tous les points de classement</h3>
                <p>Supprime tous les classements des jurys (Mon classement) et les points activ√©s dans les classements. Les jurys, candidats, notes et duels sont conserv√©s.</p>
                <button onclick="confirmDeleteAllClassementPoints()" class="action-button" style="background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); color: white;">Supprimer tous les points de classement</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">Supprimer les gagnants des duels</h3>
                <p>Remet tous les gagnants des duels √† ¬´ non renseign√© ¬ª (boutons repassent en blanc). Les duels et candidats restent en place, seuls les gagnants sont effac√©s.</p>
                <button onclick="confirmResetDuelWinners()" class="action-button" style="background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%); color: white;">Supprimer les gagnants des duels</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px; border: 2px solid var(--danger); border-radius: 8px; padding: 15px;">
                <h3 style="color: var(--text-color);">üóëÔ∏è Vider tout le classement (notes et bonus)</h3>
                <p>Supprime <strong>toutes les notes</strong> (scores) et <strong>tous les bonus</strong> : scores, classements affich√©s, points activ√©s, ¬´ Mon classement ¬ª des jurys, gagnants des duels. Il faudra tout rentrer √† nouveau. Les jurys et la liste des candidats sont conserv√©s.</p>
                <button onclick="confirmClearAllNotesAndClassement()" class="action-button" style="background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); color: white;">üóëÔ∏è Vider tout (notes + classement + bonus)</button>
            </div>
            
            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">R√©initialiser les tours par d√©faut</h3>
                <p>Remet la configuration des tours aux valeurs par d√©faut (6 tours : 1er tour, Rep√™chage 1, 2√®me tour, Rep√™chage 2, Demi-finale, Finale).</p>
                <p style="font-weight: 600; color: var(--warning-color); margin-top: 10px;">‚ö†Ô∏è Les notes et candidats sont conserv√©s, seule la structure des tours est r√©initialis√©e.</p>
                <button onclick="confirmResetRoundsToDefault()" class="action-button" style="background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%); color: white;">üîÑ Remettre les tours par d√©faut</button>
            </div>
            
            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">R√©initialiser le tour en cours</h3>
                <p>Supprime toutes les notes des candidats du tour actif et remet leur statut √† "Actif".</p>
                <button onclick="confirmResetActiveRound()" class="action-button" style="background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%); color: white;">üîÑ R√©initialiser les notes du tour actif</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">Qualifier les candidats du tour</h3>
                <p>Qualifie ou √©limine les candidats du tour actif sur la base de leurs scores actuels et du nombre de candidats configur√© pour le tour suivant.</p>
                <p style="font-weight: 600; color: var(--info-color); margin-top: 10px;">‚ÑπÔ∏è Les candidats seront class√©s par score total et les N premiers seront qualifi√©s.</p>
                <button onclick="qualifyCandidatesOfRound()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #218838 100%); color: white;">‚úÖ Qualifier les candidats du tour actif</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">R√©initialiser tous les scores et tours</h3>
                <p>Supprime TOUTES les notes de TOUS les tours et remet TOUS les candidats en statut "Actif" au premier tour. Les jurys et candidats sont conserv√©s.</p>
                <p style="font-weight: 600; color: var(--warning-color); margin-top: 10px;">‚ö†Ô∏è Cette action efface toutes les notations mais garde les jurys et la liste des candidats.</p>
                <button onclick="confirmResetAllScoresAndRounds()" class="action-button" style="background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); color: white;">üîÑ R√©initialiser tous les scores et tours</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">R√©initialisation compl√®te</h3>
                <p>Supprime TOUS les jurys, TOUS les candidats, toutes les notations, tous les duels ET tous les points de classement. Remet l'application √† z√©ro.</p>
                <button onclick="confirmResetAll()" class="action-button">R√âINITIALISER TOUT (Jurys + Candidats + Scores + Duels + Classements)</button>
            </div>
        </div>
    </div>

    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script type="module">
        import { db } from './firebase-init.js';
        import { collection, getDocs, deleteDoc, doc, setDoc, getDoc, addDoc, query, where, writeBatch, onSnapshot } from "https://www.gstatic.com/firebasejs/10.1.0/firebase-firestore.js";

        let CANDIDATES = [];
        let ROUNDS = [];
        let activeRoundId = null;
        let aggregatedData = {};
        let candidateLocks = {}; // {candidateId: {juryId: boolean}}
        let validatedRounds = {}; // {roundId: true} ‚Äî verrouillage d√©finitif apr√®s validation globale
        let scoresListener = null; // Pour stocker le listener en temps r√©el
        let candidatesListener = null; // Pour stocker le listener sur les candidats
        let duelsListener = null; // Listener temps r√©el sur duel_results (mise √† jour auto quand un jur√© enregistre un gagnant)
        let activationClassementUnsubscribes = []; // Unsubscribe des listeners Activation classements (mise √† jour auto)

        // --- REAL-TIME SCORES LISTENER ---
        let refreshTimeout = null;
        let isFirstSnapshot = true;
        let isFirstCandidatesSnapshot = true;
        let pendingRefresh = false;
        let isManualChange = false; // Flag pour ignorer les listeners pendant un changement manuel
        let isRenderingNotesTable = false; // Flag pour √©viter les appels multiples √† renderNotesTable

        /** Score base = fond√ócoef + forme ; pour l'√©preuve duel : coef 1 (fond+forme), sinon fond√ó3 + forme. EL ou - = 0. */
        function computeScoreBase(score1, score2, roundId) {
            if (score1 === 'EL' || score2 === 'EL' || score1 === '-' || score2 === '-') return 0;
            const s1 = parseInt(score1, 10);
            const s2 = parseInt(score2, 10);
            if (isNaN(s1) || isNaN(s2)) return 0;
            const r = (typeof ROUNDS !== 'undefined' && Array.isArray(ROUNDS)) ? ROUNDS.find(x => x.id === roundId) : null;
            const isDuel = r && (r.type === 'Duels' || r.type_epreuve === 'duels');
            if (isDuel) return s1 + s2;  // duel : fond et forme en coef 1
            return (s1 * 3) + s2;
        }
        
        function setupScoresListener() {
            // Si un listener existe d√©j√†, ne pas en cr√©er un nouveau
            if (scoresListener) {
                console.log('üì° Scores listener already active');
                return;
            }
            
            console.log('üîÑ Setting up real-time scores listener...');
            
            // √âcouter les changements dans la collection scores
            const scoresQuery = query(collection(db, "scores"));
            scoresListener = onSnapshot(scoresQuery, async (snapshot) => {
                // Ignorer le premier appel (√©tat initial lors du chargement)
                if (isFirstSnapshot) {
                    console.log('‚è≠Ô∏è Skipping initial snapshot');
                    isFirstSnapshot = false;
                    return;
                }
                
                // Ignorer si un changement manuel est en cours (handleScoreChange g√®re le rendu)
                if (isManualChange) {
                    console.log('‚è≠Ô∏è Skipping listener refresh during manual change');
                    return;
                }
                
                // V√©rifier les changements r√©els (ignorer les snapshots sans changement r√©el, ex. reconnexion)
                const changes = snapshot.docChanges();
                if (changes.length === 0) {
                    return;
                }
                const hasRelevantChange = changes.some(c => c.type === 'added' || c.type === 'modified' || c.type === 'removed');
                if (!hasRelevantChange) {
                    return;
                }
                
                console.log('[CLASSEMENT] Listener scores: changements', changes.length, changes.map(c => `${c.type}:${c.doc.id}`).join(', '));
                
                const notesTab = document.getElementById('tab-notes');
                const isNotesActive = notesTab && notesTab.classList.contains('active');
                console.log('[CLASSEMENT] Listener scores: onglet Notes actif ?', isNotesActive);
                // Ne jamais mettre √† jour le classement depuis le listener quand l'onglet Notes est affich√© : sinon on √©crase les points d'activation (bonus). Les changements de notes dans l'admin sont g√©r√©s par handleScoreChange qui appelle updateClassementFromScoresForRound.
                if (isNotesActive) {
                    console.log('[CLASSEMENT] Listener scores: SKIP updateClassementFromScoresForRound (onglet Notes actif), refresh tableau Notes uniquement');
                    pendingRefresh = true;
                    if (refreshTimeout) clearTimeout(refreshTimeout);
                    refreshTimeout = setTimeout(async () => {
                        console.log('[CLASSEMENT] Refreshing Notes table...');
                        await renderNotesTable();
                        await loadResults();
                        pendingRefresh = false;
                    }, 300);
                    return;
                }
                
                const affectedRoundIds = new Set();
                const affectedCandidateIds = new Set();
                changes.forEach(change => {
                    const data = change.doc.data();
                    if (data && data.roundId) affectedRoundIds.add(data.roundId);
                    if (data && data.candidateId && data.roundId === activeRoundId) {
                        affectedCandidateIds.add(data.candidateId);
                    }
                });
                // Debounce : √©viter plusieurs √©critures en rafale
                if (window._scoreChangeDebounceTimer) clearTimeout(window._scoreChangeDebounceTimer);
                console.log('[CLASSEMENT] Listener scores: planification updateClassementFromScoresForRound pour rounds', [...affectedRoundIds]);
                window._scoreChangeDebounceTimer = setTimeout(() => {
                    window._scoreChangeDebounceTimer = null;
                    affectedRoundIds.forEach(roundId => {
                        updateClassementFromScoresForRound(roundId);
                    });
                }, 400);
                
                pendingRefresh = true;
            }, (error) => {
                console.error('[CLASSEMENT] ‚ùå Error listening to scores:', error);
            });
            
            console.log('‚úÖ Scores listener setup complete');
        }
        
        function setupCandidatesListener() {
            // Si un listener existe d√©j√†, ne pas en cr√©er un nouveau
            if (candidatesListener) {
                console.log('üì° Candidates listener already active');
                return;
            }
            
            console.log('üîÑ Setting up real-time candidates listener...');
            
            // √âcouter les changements dans le document des candidats
            const candidatesDocRef = doc(db, "candidats", "liste_actuelle");
            candidatesListener = onSnapshot(candidatesDocRef, (snapshot) => {
                // Ignorer le premier appel (√©tat initial lors du chargement)
                if (isFirstCandidatesSnapshot) {
                    console.log('‚è≠Ô∏è Skipping initial candidates snapshot');
                    isFirstCandidatesSnapshot = false;
                    return;
                }
                
                if (!snapshot.exists()) {
                    return;
                }
                
                // Ignorer si un changement manuel est en cours (handleScoreChange g√®re le rendu)
                if (isManualChange) {
                    console.log('‚è≠Ô∏è Skipping candidates listener refresh during manual change');
                    // Mais on met quand m√™me √† jour CANDIDATES pour avoir les donn√©es fra√Æches
                    CANDIDATES = snapshot.data().candidates || [];
                    return;
                }
                
                console.log('‚ú® Candidates status changes detected');
                
                // Recharger les candidats
                CANDIDATES = snapshot.data().candidates || [];
                
                // Marquer qu'il y a un rafra√Æchissement en attente
                pendingRefresh = true;
                
                // V√©rifier si l'onglet Notes est actif
                const notesTab = document.getElementById('tab-notes');
                const isNotesActive = notesTab && notesTab.classList.contains('active');
                
                if (isNotesActive) {
                    // D√©bounce: attendre 300ms avant de rafra√Æchir
                    if (refreshTimeout) {
                        clearTimeout(refreshTimeout);
                    }
                    refreshTimeout = setTimeout(() => {
                        console.log('üîÑ Refreshing Notes table after candidate status change...');
                        renderNotesTable();
                        pendingRefresh = false;
                    }, 300);
                } else {
                    console.log('üìã Notes tab not active, refresh pending');
                }
            }, (error) => {
                console.error('‚ùå Error listening to candidates:', error);
            });
            
            console.log('‚úÖ Candidates listener setup complete');
        }

        // --- TAB SWITCHING ---
        window.switchTab = function(tabName) {
            console.log('[CLASSEMENT] switchTab ‚Üí', tabName);
            // En quittant l'onglet Activation classements, d√©sabonner les listeners pour √©viter des rechargements en arri√®re-plan qui pourraient interf√©rer avec les donn√©es
            if (tabName !== 'activation-classements') {
                if (activationClassementUnsubscribes.length > 0) {
                    console.log('[CLASSEMENT] switchTab: d√©sabonnement de', activationClassementUnsubscribes.length, 'listener(s) Activation');
                }
                activationClassementUnsubscribes.forEach(fn => { if (typeof fn === 'function') fn(); });
                activationClassementUnsubscribes = [];
            }
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(`tab-${tabName}`).classList.add('active');
            event.target.classList.add('active');
            
            // Load tab-specific data
            if (tabName === 'candidats') {
                renderCandidateTable();
            } else if (tabName === 'jury') {
                renderJuryTable();
                loadSessionLockState();
            } else if (tabName === 'tours') {
                renderRoundsTable();
            } else if (tabName === 'notes') {
                populateNotesRoundDropdown();
                const notesSelect = document.getElementById('notes-round-select');
                if (notesSelect && notesSelect.value) {
                    notesDisplayRound = notesSelect.value;
                }
                renderNotesTable();
                // Rafra√Æchir si des changements sont en attente
                if (pendingRefresh) {
                    console.log('üîÑ Applying pending refresh...');
                    pendingRefresh = false;
                }
            } else if (tabName === 'podium') {
                populatePodiumRoundDropdown();
                loadResults();
            } else if (tabName === 'duels') {
                populateDuelsRoundDropdown();
                loadDuelsData();
            } else if (tabName === 'activation-classements') {
                populateActivationClassementRoundDropdown();
                loadActivationClassementsData();
            }
        };

        // --- GESTION CANDIDATS ---
        
        // G√©n√®re un ID al√©atoire unique entre 001 et 999
        function generateUniqueCandidateId() {
            const existingIds = new Set(CANDIDATES.map(c => c.id));
            let attempts = 0;
            const maxAttempts = 1000;
            
            while (attempts < maxAttempts) {
                // G√©n√©rer un nombre al√©atoire entre 1 et 999
                const randomNum = Math.floor(Math.random() * 999) + 1;
                // Formater avec des z√©ros devant (001, 002, etc.)
                const id = String(randomNum).padStart(3, '0');
                
                if (!existingIds.has(id)) {
                    return id;
                }
                attempts++;
            }
            
            // Si tous les IDs sont pris (tr√®s improbable), chercher le premier disponible
            for (let i = 1; i <= 999; i++) {
                const id = String(i).padStart(3, '0');
                if (!existingIds.has(id)) {
                    return id;
                }
            }
            
            // Si vraiment tous les IDs sont pris (999 candidats), retourner null
            return null;
        }

        const loadList = async () => {
            const snap = await getDoc(doc(db, "candidats", "liste_actuelle"));
            if (snap.exists()) {
                CANDIDATES = snap.data().candidates || [];
                
                // Initialiser les nouveaux champs tour et status s'ils n'existent pas
                CANDIDATES = CANDIDATES.map(c => ({
                    ...c,
                    tour: c.tour || activeRoundId || 'round1',
                    status: c.status || 'Actif'
                }));
                
                document.getElementById('candidate-names').value = CANDIDATES.map(c => c.name).join('\n');
                renderCandidateTable();
            }
            
            // Charger les verrous
            const lockSnap = await getDoc(doc(db, "config", "locks"));
            if (lockSnap.exists()) {
                candidateLocks = lockSnap.data().locks || {};
            }
        };

        function generateSequentialCandidateId() {
            // Trouver le prochain ID s√©quentiel disponible
            const usedIds = new Set(CANDIDATES.map(c => c.id));
            for (let i = 1; i <= 999; i++) {
                const id = String(i).padStart(3, '0');
                if (!usedIds.has(id)) {
                    return id;
                }
            }
            return null; // Tous les IDs sont utilis√©s
        }

        window.importCandidates = async () => {
            const names = document.getElementById('candidate-names').value.split('\n').map(n => n.trim()).filter(n => n !== "");
            if (names.length === 0) {
                await customAlert("Veuillez entrer au moins un candidat");
                return;
            }
            
            // V√©rifier si l'utilisateur veut des IDs al√©atoires ou s√©quentiels
            const useRandomIds = document.getElementById('random-ids-checkbox').checked;
            
            // Charger les candidats existants
            const docSnap = await getDoc(doc(db, "candidats", "liste_actuelle"));
            const existingCandidates = docSnap.exists() ? (docSnap.data().candidates || []) : [];
            
            // Cr√©er une copie de CANDIDATES pour la g√©n√©ration d'ID (√©viter les modifications par r√©f√©rence)
            CANDIDATES = [...existingCandidates];
            
            // Cr√©er un Set des noms existants pour v√©rification rapide
            const existingNames = new Set(existingCandidates.map(c => c.name.toLowerCase()));
            
            // Ajouter uniquement les nouveaux candidats
            const newCandidates = [];
            const duplicates = [];
            
            names.forEach(name => {
                if (existingNames.has(name.toLowerCase())) {
                    duplicates.push(name);
                } else {
                    // G√©n√©rer l'ID selon le choix de l'utilisateur
                    const newId = useRandomIds ? generateUniqueCandidateId() : generateSequentialCandidateId();
                    if (newId) {
                        const newCandidate = { 
                            id: newId, 
                            name: name,
                            tour: activeRoundId || 'round1',
                            status: 'Actif'
                        };
                        newCandidates.push(newCandidate);
                        existingNames.add(name.toLowerCase());
                        // Ajouter temporairement √† CANDIDATES pour les prochaines g√©n√©rations d'ID
                        CANDIDATES.push(newCandidate);
                    }
                }
            });
            
            // Fusionner avec les candidats existants
            const updatedList = [...existingCandidates, ...newCandidates];
            
            // Sauvegarder
            await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: updatedList });
            
            // Message de confirmation
            let message = `‚úì ${newCandidates.length} nouveau(x) candidat(s) ajout√©(s)`;
            if (useRandomIds) {
                message += '\n(IDs al√©atoires)';
            } else {
                message += '\n(IDs s√©quentiels)';
            }
            if (duplicates.length > 0) {
                message += `\n‚ö†Ô∏è ${duplicates.length} candidat(s) d√©j√† existant(s) ignor√©(s):\n${duplicates.join(', ')}`;
            }
            await customAlert(message);
            
            CANDIDATES = updatedList;
            renderCandidateTable();
        };

        window.addCandidate = async () => {
            // G√©n√©rer un ID al√©atoire unique
            const newId = generateUniqueCandidateId();
            if (!newId) {
                await customAlert("Impossible d'ajouter un candidat : tous les IDs (001-999) sont utilis√©s.");
                return;
            }
            
            CANDIDATES.push({ 
                id: newId, 
                name: `Candidat ${newId}`,
                tour: activeRoundId || 'round1',
                status: 'Actif'
            });
            saveCandidates();
        };

        window.deleteCandidate = async (candidateId) => {
            if (!await confirm(`Supprimer ce candidat et toutes ses notes ?`)) return;
            
            CANDIDATES = CANDIDATES.filter(c => c.id !== candidateId);
            
            // Supprimer aussi les scores de ce candidat
            const scoresQuery = query(collection(db, "scores"), where("candidateId", "==", candidateId));
            const scoresSnap = await getDocs(scoresQuery);
            for (const scoreDoc of scoresSnap.docs) {
                await deleteDoc(doc(db, "scores", scoreDoc.id));
            }
            
            saveCandidates();
        };

        window.updateCandidateId = async (oldId, newId) => {
            // Nettoyer et valider le nouvel ID
            newId = newId.trim();
            
            // V√©rifier le format (doit √™tre un nombre entre 001 et 999)
            if (!/^\d{3}$/.test(newId)) {
                await customAlert("L'ID doit √™tre un nombre √† 3 chiffres (001 √† 999)");
                renderCandidateTable(); // Restaurer l'ancien ID
                return;
            }
            
            const numericId = parseInt(newId);
            if (numericId < 1 || numericId > 999) {
                await customAlert("L'ID doit √™tre entre 001 et 999");
                renderCandidateTable();
                return;
            }
            
            // V√©rifier l'unicit√©
            if (oldId !== newId && CANDIDATES.some(c => c.id === newId)) {
                await customAlert(`L'ID ${newId} est d√©j√† utilis√© par un autre candidat`);
                renderCandidateTable();
                return;
            }
            
            // Si l'ID n'a pas chang√©, ne rien faire
            if (oldId === newId) {
                return;
            }
            
            // Mettre √† jour l'ID du candidat
            const candidate = CANDIDATES.find(c => c.id === oldId);
            if (candidate) {
                candidate.id = newId;
                
                // Mettre √† jour tous les scores associ√©s √† ce candidat
                const scoresQuery = query(collection(db, "scores"), where("candidateId", "==", oldId));
                const scoresSnap = await getDocs(scoresQuery);
                
                for (const scoreDoc of scoresSnap.docs) {
                    await updateDoc(doc(db, "scores", scoreDoc.id), {
                        candidateId: newId
                    });
                }
                
                // Mettre √† jour les verrous si n√©cessaire
                if (candidateLocks[oldId]) {
                    candidateLocks[newId] = candidateLocks[oldId];
                    delete candidateLocks[oldId];
                    await setDoc(doc(db, "config", "locks"), { locks: candidateLocks });
                }
                
                await saveCandidates();
                await customAlert(`ID mis √† jour : ${oldId} ‚Üí ${newId}`);
            }
        };
        
        window.updateCandidateName = (candidateId, newName) => {
            const candidate = CANDIDATES.find(c => c.id === candidateId);
            if (candidate) {
                candidate.name = newName;
                saveCandidates();
            }
        };

        async function saveCandidates() {
            // D√©dupliquer les candidats par ID avant de sauvegarder
            const seenIds = new Set();
            const uniqueCandidates = [];
            let duplicatesRemoved = 0;
            
            for (const candidate of CANDIDATES) {
                if (!seenIds.has(candidate.id)) {
                    seenIds.add(candidate.id);
                    uniqueCandidates.push(candidate);
                } else {
                    console.warn(`‚ö†Ô∏è Doublon d√©tect√© et supprim√©: ${candidate.name} (ID: ${candidate.id})`);
                    duplicatesRemoved++;
                }
            }
            
            if (duplicatesRemoved > 0) {
                console.log(`üßπ ${duplicatesRemoved} doublon(s) de candidat(s) supprim√©(s)`);
                CANDIDATES = uniqueCandidates;
            }
            
            await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: CANDIDATES });
            renderCandidateTable();
        }

        function renderCandidateTable() {
            const tbody = document.getElementById('candidate-table-body');
            tbody.innerHTML = '';
            
            // Trier les candidats par ID (num√©riquement)
            const sortedCandidates = [...CANDIDATES].sort((a, b) => {
                const idA = parseInt(a.id) || 0;
                const idB = parseInt(b.id) || 0;
                return idA - idB;
            });
            
            sortedCandidates.forEach(candidate => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td><input type="text" id="candidate-id-${candidate.id}" name="candidate-id-${candidate.id}" value="${candidate.id}" onchange="updateCandidateId('${candidate.id}', this.value)" style="width: 70px; padding: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px; text-align: center; font-family: monospace;"></td>
                    <td><input type="text" id="candidate-name-${candidate.id}" name="candidate-name-${candidate.id}" value="${(candidate.name || '').replace(/"/g, '&quot;')}" onchange="updateCandidateName('${candidate.id}', this.value)" style="width: 100%; padding: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px;"></td>
                    <td class="actions">
                        <button class="icon-btn delete" onclick="deleteCandidate('${candidate.id}')" title="Supprimer">üóëÔ∏è</button>
                    </td>
                `;
            });
        }

        loadList();

        // --- GESTION JURY ---
        let JURIES = [];
        
        const loadJuries = async () => {
            console.log('üìã loadJuries() appel√©');
            const accountsSnap = await getDocs(collection(db, "accounts"));
            JURIES = [];
            accountsSnap.forEach(docSnap => {
                const data = docSnap.data();
                console.log(`üìã Charg√© jury ${docSnap.id}:`, JSON.stringify(data));
                JURIES.push({
                    id: docSnap.id,  // ID num√©rique (jury1, jury2, etc.)
                    name: data.name || docSnap.id,  // Nom affich√©
                    password: data.password || '',
                    theme: data.theme || 'light',
                    createdAt: data.createdAt,
                    rounds: data.rounds || [],  // Tours o√π le jury est pr√©sent
                    isPresident: data.isPresident || false  // Pr√©sident du jury
                });
            });
            console.log('üìã Total jurys charg√©s:', JURIES.length);
            
            // Trier par ID
            JURIES.sort((a, b) => {
                const numA = parseInt(a.id.replace('jury', ''));
                const numB = parseInt(b.id.replace('jury', ''));
                return numA - numB;
            });
            
            // Mettre √† jour le textarea avec la liste des noms de jurys
            const textarea = document.getElementById('jury-names');
            if (textarea) {
                textarea.value = JURIES.map(j => j.name).join('\n');
            }
            
            await renderJuryTable();
        };
        
        // --- GESTION MOT DE PASSE PAR D√âFAUT JURY ---
        let DEFAULT_JURY_PASSWORD = '';
        
        const loadDefaultJuryPassword = async () => {
            try {
                const configDoc = await getDoc(doc(db, "config", "juryDefaults"));
                if (configDoc.exists()) {
                    DEFAULT_JURY_PASSWORD = configDoc.data().defaultPassword || '';
                    const input = document.getElementById('default-jury-password');
                    if (input) {
                        input.value = DEFAULT_JURY_PASSWORD;
                    }
                }
            } catch (e) {
                console.log('Aucun mot de passe par d√©faut configur√©');
            }
        };
        
        window.saveDefaultJuryPassword = async () => {
            const input = document.getElementById('default-jury-password');
            const password = input.value.trim();
            
            if (!password) {
                await customAlert('‚ö†Ô∏è Le mot de passe par d√©faut ne peut pas √™tre vide.\n\nSi vous souhaitez autoriser les jurys √† se connecter sans mot de passe, laissez simplement ce champ vide lors de la cr√©ation du compte.');
                return;
            }
            
            try {
                await setDoc(doc(db, "config", "juryDefaults"), {
                    defaultPassword: password,
                    updatedAt: new Date()
                });
                
                DEFAULT_JURY_PASSWORD = password;
                await customAlert('‚úì Mot de passe par d√©faut enregistr√© avec succ√®s !\n\nCe mot de passe sera maintenant requis pour cr√©er de nouveaux comptes jury.');
            } catch (e) {
                console.error('Erreur:', e);
                await customAlert('‚ùå Erreur lors de l\'enregistrement : ' + e.message);
            }
        };
        
        // Charger le mot de passe par d√©faut au d√©marrage
        loadDefaultJuryPassword();

        // --- VERROUILLAGE SESSIONS JURY ---
        window.loadSessionLockState = async () => {
            const btn = document.getElementById('session-lock-btn');
            const statusEl = document.getElementById('session-lock-status');
            if (!btn || !statusEl) return;
            try {
                const snap = await getDoc(doc(db, "config", "session"));
                const data = snap.exists() ? snap.data() : {};
                const locked = data.sessionLocked === true;
                statusEl.textContent = locked ? '√âtat : sessions verrouill√©es (les jurys n\'ont plus acc√®s).' : '√âtat : sessions d√©verrouill√©es.';
                btn.textContent = locked ? 'üîì D√©verrouiller les sessions' : 'üîí Verrouiller les sessions';
                btn.style.background = locked ? 'linear-gradient(135deg, #28a745 0%, #1e7e34 100%)' : 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
                btn.style.color = 'white';
            } catch (e) {
                console.error(e);
                statusEl.textContent = '';
                btn.textContent = 'üîí Verrouiller / D√©verrouiller';
            }
        };

        window.toggleSessionLock = async () => {
            const btn = document.getElementById('session-lock-btn');
            if (!btn) return;
            try {
                const snap = await getDoc(doc(db, "config", "session"));
                const data = snap.exists() ? snap.data() : {};
                const currentlyLocked = data.sessionLocked === true;
                if (currentlyLocked) {
                    await setDoc(doc(db, "config", "session"), { sessionLocked: false, updatedAt: new Date() }, { merge: true });
                    await customAlert('‚úì Sessions d√©verrouill√©es.\n\nLes jurys peuvent √† nouveau se connecter.');
                } else {
                    const newSessionId = String(Date.now());
                    await setDoc(doc(db, "config", "session"), { sessionLocked: true, current_id: newSessionId, updatedAt: new Date() }, { merge: true });
                    await customAlert('‚úì Sessions verrouill√©es.\n\nTous les jurys ont √©t√© expuls√©s et ne peuvent plus se connecter tant que vous ne d√©verrouillez pas.');
                }
                await loadSessionLockState();
            } catch (e) {
                console.error(e);
                await customAlert('Erreur : ' + (e.message || e));
            }
        };
        
        // --- GESTION OPTION PODIUM APR√àS REP√äCHAGE ---
        let SHOW_PODIUM_AFTER_REPECHAGE = false;
        
        const loadShowPodiumAfterRepechage = async () => {
            try {
                const configDoc = await getDoc(doc(db, "config", "podiumSettings"));
                if (configDoc.exists()) {
                    SHOW_PODIUM_AFTER_REPECHAGE = configDoc.data().showPodiumAfterRepechage || false;
                    const checkbox = document.getElementById('show-podium-after-repechage');
                    if (checkbox) {
                        checkbox.checked = SHOW_PODIUM_AFTER_REPECHAGE;
                    }
                }
            } catch (e) {
                console.log('Aucune configuration podium trouv√©e');
            }
        };
        
        window.saveShowPodiumAfterRepechage = async (value) => {
            try {
                await setDoc(doc(db, "config", "podiumSettings"), {
                    showPodiumAfterRepechage: value,
                    updatedAt: new Date()
                });
                
                SHOW_PODIUM_AFTER_REPECHAGE = value;
                console.log(`‚úì Option podium apr√®s rep√™chage: ${value ? 'activ√©e' : 'd√©sactiv√©e'}`);
            } catch (e) {
                console.error('Erreur:', e);
                await customAlert('‚ùå Erreur lors de l\'enregistrement : ' + e.message);
            }
        };
        
        // Charger l'option au d√©marrage
        loadShowPodiumAfterRepechage();
        
        // Fonction utilitaire pour g√©n√©rer le prochain ID de jury
        async function getNextJuryId() {
            const accountsSnap = await getDocs(collection(db, "accounts"));
            let maxNum = 0;
            accountsSnap.forEach(doc => {
                const match = doc.id.match(/^jury(\d+)$/);
                if (match) {
                    const num = parseInt(match[1]);
                    if (num > maxNum) maxNum = num;
                }
            });
            return `jury${maxNum + 1}`;
        }
        
        window.importJuries = async () => {
            const names = document.getElementById('jury-names').value.split('\n').map(n => n.trim()).filter(n => n !== "");
            if (names.length === 0) {
                alert("Veuillez entrer au moins un jury");
                return;
            }
            
            // Charger les jurys existants
            await loadJuries();
            
            // Cr√©er un Set des noms existants pour v√©rification rapide
            const existingNames = new Set(JURIES.map(j => j.name.toLowerCase()));
            
            // Ajouter uniquement les nouveaux jurys
            const newJuries = [];
            const duplicates = [];
            
            // S'assurer que les ROUNDS sont charg√©s
            if (ROUNDS.length === 0) {
                await loadRounds();
            }
            
            for (const name of names) {
                if (existingNames.has(name.toLowerCase())) {
                    duplicates.push(name);
                } else {
                    const juryId = await getNextJuryId();
                    
                    // D√©terminer si c'est le premier jury (pr√©sident)
                    const isFirstJury = JURIES.length === 0 && newJuries.length === 0;
                    
                    // Calculer les tours par d√©faut (comme dans addJury)
                    const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
                    let defaultRounds = [];
                    
                    if (sortedRounds.length > 0) {
                        let activeIdx = sortedRounds.findIndex(r => r.id === activeRoundId);
                        if (activeIdx === -1) activeIdx = 0;
                        
                        for (let i = activeIdx; i < sortedRounds.length; i++) {
                            const round = sortedRounds[i];
                            if (round.type === 'Rep√™chage' && !isFirstJury) {
                                continue;
                            }
                            defaultRounds.push(round.id);
                        }
                    } else {
                        // Fallback
                        defaultRounds = isFirstJury 
                            ? ['round1', 'round2', 'round3', 'round4', 'round5', 'round6']
                            : ['round1', 'round3', 'round5', 'round6'];
                    }
                    
                    await setDoc(doc(db, "accounts", juryId), {
                        name: name,
                        password: DEFAULT_JURY_PASSWORD || '',
                        theme: 'light',
                        createdAt: new Date(),
                        isPresident: isFirstJury,
                        rounds: defaultRounds
                    });
                    newJuries.push(name);
                    existingNames.add(name.toLowerCase());
                }
            }
            
            // Message de confirmation
            let message = `‚úì ${newJuries.length} nouveau(x) jury(s) ajout√©(s)`;
            if (duplicates.length > 0) {
                message += `\n‚ö†Ô∏è ${duplicates.length} jury(s) d√©j√† existant(s) ignor√©(s):\n${duplicates.join(', ')}`;
            }
            alert(message);
            
            await loadJuries();
        };
        
        window.addJury = async () => {
            // Toujours recharger les ROUNDS pour avoir les donn√©es √† jour
            await loadRounds();
            
            // Si toujours pas de rounds, utiliser des IDs par d√©faut
            const fallbackRoundIds = ['round1', 'round2', 'round3', 'round4', 'round5', 'round6'];
            
            console.log('üìä addJury - ROUNDS:', ROUNDS.length, 'activeRoundId:', activeRoundId);
            
            // Ajouter un jury avec un nom par d√©faut unique
            const juryId = await getNextJuryId();
            
            // G√©n√©rer un nom unique pour le jury
            const existingNames = new Set(JURIES.map(j => j.name.toLowerCase()));
            let juryNumber = JURIES.length + 1;
            let juryName = `Jury ${juryNumber}`;
            
            // S'assurer que le nom est unique
            while (existingNames.has(juryName.toLowerCase())) {
                juryNumber++;
                juryName = `Jury ${juryNumber}`;
            }
            
            // D√©terminer si c'est le premier jury (pr√©sident)
            const isFirstJury = JURIES.length === 0;
            
            // D√©terminer les tours par d√©faut
            // Le jury est pr√©sent √† partir du tour actif et tous les suivants
            // Sauf pour le rep√™chage : seul le pr√©sident y acc√®de (sinon passer au tour suivant)
            let defaultRounds = [];
            
            if (ROUNDS.length > 0) {
                const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
                let activeIdx = sortedRounds.findIndex(r => r.id === activeRoundId);
                
                // Si activeRoundId n'est pas trouv√©, commencer au premier tour
                if (activeIdx === -1) activeIdx = 0;
                
                for (let i = activeIdx; i < sortedRounds.length; i++) {
                    const round = sortedRounds[i];
                    
                    // Si c'est un rep√™chage et pas le pr√©sident, sauter ce tour
                    if (round.type === 'Rep√™chage' && !isFirstJury) {
                        continue;
                    }
                    
                    defaultRounds.push(round.id);
                }
                
                console.log('üìä addJury - activeIdx:', activeIdx, 'isFirstJury:', isFirstJury, 'defaultRounds:', defaultRounds);
            } else {
                // Fallback : utiliser tous les IDs par d√©faut
                // Pour le pr√©sident : tous les tours
                // Pour les autres : tours impairs (pas les rep√™chages qui sont pairs: round2, round4)
                if (isFirstJury) {
                    defaultRounds = fallbackRoundIds;
                } else {
                    defaultRounds = ['round1', 'round3', 'round5', 'round6'];
                }
                console.log('üìä addJury - FALLBACK - isFirstJury:', isFirstJury, 'defaultRounds:', defaultRounds);
            }
            
            await setDoc(doc(db, "accounts", juryId), {
                name: juryName,
                password: DEFAULT_JURY_PASSWORD || '',
                theme: 'light',
                createdAt: new Date(),
                isPresident: isFirstJury,
                rounds: defaultRounds
            });
            
            await loadJuries();
        };
        
        window.deleteJury = async (juryId) => {
            const jury = JURIES.find(j => j.id === juryId);
            if (!jury) return;
            
            if (!await confirm(`Supprimer le jury "${jury.name}" et toutes ses notations ?`)) return;
            
            const wasPresident = jury.isPresident;
            
            // Supprimer le compte
            await deleteDoc(doc(db, "accounts", juryId));
            
            // Supprimer toutes les notations de ce jury
            const scoresQuery = query(collection(db, "scores"), where("juryId", "==", juryId));
            const scoresSnap = await getDocs(scoresQuery);
            const batch = writeBatch(db);
            scoresSnap.forEach(doc => batch.delete(doc.ref));
            await batch.commit();
            
            // Si le jury supprim√© √©tait le pr√©sident, assigner un nouveau pr√©sident
            if (wasPresident) {
                await loadJuries(); // Recharger la liste mise √† jour
                
                // Trouver le dernier jury restant pour en faire le pr√©sident
                if (JURIES.length > 0) {
                    const lastJury = JURIES[JURIES.length - 1];
                    console.log(`üîÑ Le pr√©sident a √©t√© supprim√©. Attribution du statut au jury: ${lastJury.name}`);
                    await setJuryPresident(lastJury.id);
                }
            } else {
                await loadJuries();
            }
        };
        
        window.updateJuryName = async (juryId, newName) => {
            if (!newName || !newName.trim()) {
                await loadJuries();
                return;
            }
            
            const trimmedName = newName.trim();
            const jury = JURIES.find(j => j.id === juryId);
            if (!jury || jury.name === trimmedName) {
                await loadJuries();
                return;
            }
            
            // V√©rifier que le nom n'existe pas d√©j√† (ignorer la casse)
            const existingJury = JURIES.find(j => j.id !== juryId && j.name.toLowerCase() === trimmedName.toLowerCase());
            if (existingJury) {
                await customAlert(`‚ö†Ô∏è Un jury avec le nom "${existingJury.name}" existe d√©j√†.\n\nVeuillez choisir un nom diff√©rent.`);
                await loadJuries(); // Recharger pour restaurer l'ancien nom dans l'input
                return;
            }
            
            // Mettre √† jour le nom dans le document
            await setDoc(doc(db, "accounts", juryId), {
                name: trimmedName
            }, { merge: true });
            
            // Mettre √† jour le champ d√©normalis√© juryName dans tous les scores
            const scoresQuery = query(collection(db, "scores"), where("juryId", "==", juryId));
            const scoresSnap = await getDocs(scoresQuery);
            if (!scoresSnap.empty) {
                const batch = writeBatch(db);
                scoresSnap.forEach(docSnap => {
                    batch.update(docSnap.ref, { juryName: trimmedName });
                });
                await batch.commit();
            }
            
            await loadJuries();
        };
        
        window.toggleJuryRound = async (juryId, roundId, isChecked) => {
            const jury = JURIES.find(j => j.id === juryId);
            if (!jury) return;
            
            let updatedRounds = [...(jury.rounds || [])];
            
            if (isChecked) {
                // Ajouter le tour si pas d√©j√† pr√©sent
                if (!updatedRounds.includes(roundId)) {
                    updatedRounds.push(roundId);
                }
            } else {
                // Retirer le tour
                updatedRounds = updatedRounds.filter(r => r !== roundId);
            }
            
            await setDoc(doc(db, "accounts", juryId), {
                rounds: updatedRounds
            }, { merge: true });
            
            await loadJuries();
        };
        
        window.setJuryPresident = async (juryId) => {
            // D√©finir ce jury comme pr√©sident et retirer le statut des autres
            const batch = writeBatch(db);
            const repechageRounds = ROUNDS.filter(r => r.type === 'Rep√™chage').map(r => r.id);
            
            for (const jury of JURIES) {
                const isNewPresident = jury.id === juryId;
                
                // Mettre √† jour le statut de pr√©sident
                const juryRef = doc(db, "accounts", jury.id);
                batch.update(juryRef, { isPresident: isNewPresident });
                
                if (isNewPresident) {
                    // Si ce jury devient pr√©sident, ajouter automatiquement tous les tours de rep√™chage
                    const currentRounds = new Set(jury.rounds || []);
                    repechageRounds.forEach(roundId => currentRounds.add(roundId));
                    batch.update(juryRef, { rounds: Array.from(currentRounds) });
                } else if (!isNewPresident && jury.isPresident) {
                    // Si ce jury n'est plus pr√©sident, retirer les tours de rep√™chage
                    const updatedRounds = (jury.rounds || []).filter(r => !repechageRounds.includes(r));
                    batch.update(juryRef, { rounds: updatedRounds });
                }
            }
            
            await batch.commit();
            await loadJuries();
        };
        
        // Garder l'ancienne fonction pour compatibilit√© (mais elle n'est plus utilis√©e)
        window.toggleJuryPresident = async (juryId, isPresident) => {
            await setDoc(doc(db, "accounts", juryId), {
                isPresident: isPresident
            }, { merge: true });
            
            // Si on retire le statut de pr√©sident, retirer aussi les tours de rep√™chage
            if (!isPresident) {
                const jury = JURIES.find(j => j.id === juryId);
                if (jury) {
                    const repechageRounds = ROUNDS.filter(r => r.type === 'Rep√™chage').map(r => r.id);
                    const updatedRounds = (jury.rounds || []).filter(r => !repechageRounds.includes(r));
                    
                    await setDoc(doc(db, "accounts", juryId), {
                        rounds: updatedRounds
                    }, { merge: true });
                }
            }
            
            await loadJuries();
        };
        
        window.resetJuryPassword = async (juryId) => {
            const jury = JURIES.find(j => j.id === juryId);
            if (!jury) return;
            
            const passwordMsg = DEFAULT_JURY_PASSWORD ? `au mot de passe par d√©faut` : `(vide)`;
            if (!await confirm(`R√©initialiser le mot de passe de "${jury.name}" ${passwordMsg} ?`)) return;
            
            await setDoc(doc(db, "accounts", juryId), {
                password: DEFAULT_JURY_PASSWORD || ''
            }, { merge: true });
            
            const successMsg = DEFAULT_JURY_PASSWORD ? 'r√©initialis√© au mot de passe par d√©faut' : 'r√©initialis√© √† vide';
            await customAlert(`‚úì Mot de passe ${successMsg}`);
            await loadJuries();
        };
        
        async function renderJuryTable() {
            console.log('üé® renderJuryTable() appel√©');
            console.log('üé® ROUNDS.length:', ROUNDS.length);
            console.log('üé® JURIES.length:', JURIES.length);
            
            const tbody = document.getElementById('jury-table-body');
            const thead = document.querySelector('#jury-table thead tr');
            if (!tbody || !thead) {
                console.log('üé® tbody ou thead non trouv√©, return');
                return;
            }
            
            // S'assurer que les ROUNDS sont charg√©s
            if (ROUNDS.length === 0) {
                console.log('üé® ROUNDS vide, appel de loadRounds()...');
                await loadRounds();
                console.log('üé® Apr√®s loadRounds(), ROUNDS.length:', ROUNDS.length);
            }
            
            // Construire l'en-t√™te avec les tours
            const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
            console.log('üé® sortedRounds:', sortedRounds.map(r => r.id));
            thead.innerHTML = `
                <th style="width: 60px; text-align: center;">ID</th>
                <th style="min-width: 150px;">Nom</th>
                <th style="width: 100px; text-align: center;">Pr√©sident</th>
                <th style="min-width: 200px; text-align: center;">Tours pr√©sents</th>
                <th style="width: 120px; text-align: center;">Mot de passe</th>
                <th style="width: 100px; text-align: center;">Actions</th>
            `;
            
            tbody.innerHTML = '';
            
            JURIES.forEach(jury => {
                console.log(`üé® Jury ${jury.name}: rounds=${JSON.stringify(jury.rounds)}, isPresident=${jury.isPresident}`);
                
                const row = tbody.insertRow();
                const passwordDisplay = jury.password ? 'üîí D√©fini' : 'üîì Vide';
                const juryNumber = jury.id.replace('jury', '');
                
                // Cr√©er les checkboxes pour les tours
                const roundsCheckboxes = sortedRounds.map(round => {
                    const isChecked = jury.rounds && jury.rounds.includes(round.id);
                    console.log(`üé®   - ${round.id}: isChecked=${isChecked}`);
                    const isRepechage = round.type === 'Rep√™chage';
                    const disabled = isRepechage && !jury.isPresident ? 'disabled' : '';
                    const title = isRepechage && !jury.isPresident ? 'Seul le pr√©sident peut acc√©der aux tours de rep√™chage' : '';
                    const cbId = 'jury-round-' + jury.id + '-' + round.id;
                    return `
                        <label for="${cbId}" style="display: inline-flex; align-items: center; gap: 4px; margin: 2px 4px; padding: 4px 8px; background: var(--bg-secondary); color: var(--text-color); border-radius: 4px; cursor: ${disabled ? 'not-allowed' : 'pointer'}; opacity: ${disabled ? '0.5' : '1'}; font-size: 0.85em; white-space: nowrap;" title="${title}">
                            <input type="checkbox" id="${cbId}" name="${cbId}"
                                   ${isChecked ? 'checked' : ''} 
                                   ${disabled}
                                   onchange="toggleJuryRound('${jury.id}', '${round.id}', this.checked)"
                                   style="cursor: ${disabled ? 'not-allowed' : 'pointer'};">
                            <span>${round.name}</span>
                        </label>
                    `;
                }).join('');
                
                row.innerHTML = `
                    <td style="text-align: center; color: var(--text-secondary); font-family: monospace;">${juryNumber}</td>
                    <td><input type="text" id="jury-name-${jury.id}" name="jury-name-${jury.id}" value="${(jury.name || '').replace(/"/g, '&quot;')}" onchange="updateJuryName('${jury.id}', this.value)" style="width: 100%; padding: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px;"></td>
                    <td style="text-align: center;">
                        <input type="radio" id="jury-president-${jury.id}"
                               name="jury-president" 
                               ${jury.isPresident ? 'checked' : ''} 
                               onchange="setJuryPresident('${jury.id}')"
                               style="width: 20px; height: 20px; cursor: pointer;"
                               title="Le pr√©sident peut acc√©der aux tours de rep√™chage">
                    </td>
                    <td style="padding: 8px;">
                        <div style="display: flex; flex-wrap: wrap; gap: 4px; justify-content: center;">
                            ${roundsCheckboxes}
                        </div>
                    </td>
                    <td style="text-align: center;">${passwordDisplay}</td>
                    <td class="actions">
                        <button class="icon-btn" onclick="resetJuryPassword('${jury.id}')" title="R√©initialiser le mot de passe">üîë</button>
                        <button class="icon-btn delete" onclick="deleteJury('${jury.id}')" title="Supprimer">üóëÔ∏è</button>
                    </td>
                `;
            });
        }
        
        loadJuries();
        
        // Charger le th√®me admin depuis Firebase au chargement
        async function loadAdminTheme() {
            try {
                const adminDoc = await getDoc(doc(db, "config", "admin"));
                if (adminDoc.exists()) {
                    const adminTheme = adminDoc.data().theme || 'light';
                    localStorage.setItem('theme_admin', adminTheme);
                    // R√©appliquer le th√®me
                    initTheme();
                }
            } catch (e) {
                console.log('Impossible de charger le th√®me admin:', e);
            }
        }
        loadAdminTheme();

        // --- GESTION TOURS ---
        const loadRounds = async () => {
            console.log('üîÑ loadRounds() appel√©');
            const snap = await getDoc(doc(db, "config", "rounds"));
            console.log('üîÑ snap.exists():', snap.exists());
            if (snap.exists()) {
                console.log('üîÑ snap.data():', JSON.stringify(snap.data()));
                ROUNDS = (snap.data().rounds || []).map(r => ({
                    ...r,
                    type_epreuve: r.type_epreuve != null ? r.type_epreuve : getTypeEpreuveFromType(r.type)
                }));
                activeRoundId = snap.data().activeRoundId || null;
                console.log('üîÑ ROUNDS charg√©s:', ROUNDS.length, 'activeRoundId:', activeRoundId);
            }
            
            // Initialiser avec les tours par d√©faut si aucun n'existe
            if (ROUNDS.length === 0) {
                ROUNDS = [
                    { id: 'round1', order: 1, name: '1er tour', type: 'Notation individuelle', type_epreuve: 'notation', nextRoundCandidates: 'ALL', active: true },
                    { id: 'round2', order: 2, name: 'Repechage 1er tour', type: 'Rep√™chage', type_epreuve: 'repechage', nextRoundCandidates: 18, active: false },
                    { id: 'round3', order: 3, name: '2eme tour', type: 'Duels', type_epreuve: 'duels', nextRoundCandidates: 'ALL', active: false },
                    { id: 'round4', order: 4, name: 'Repechage 2eme tour', type: 'Rep√™chage', type_epreuve: 'repechage', nextRoundCandidates: 7, active: false },
                    { id: 'round5', order: 5, name: 'Demi-finale', type: 'Duels', type_epreuve: 'duels', nextRoundCandidates: 3, active: false },
                    { id: 'round6', order: 6, name: 'Finale', type: 'Duels', type_epreuve: 'duels', nextRoundCandidates: 1, active: false }
                ];
                activeRoundId = 'round1';
                await saveRounds();
            }
            
            renderRoundsTable();
        };

        // Map type affich√© -> type_epreuve (stockage identifiant duels, classement, etc.)
        function getTypeEpreuveFromType(type) {
            if (!type) return 'notation';
            if (type === 'Duels') return 'duels';
            if (type === 'Classement') return 'classement';
            if (type === 'Rep√™chage') return 'repechage';
            return 'notation';
        }
        
        async function saveRounds() {
            // S'assurer que chaque tour a type_epreuve (duels, classement, notation, rep√™chage)
            const roundsToSave = ROUNDS.map(r => ({
                ...r,
                type_epreuve: r.type_epreuve != null ? r.type_epreuve : getTypeEpreuveFromType(r.type)
            }));
            await setDoc(doc(db, "config", "rounds"), { 
                rounds: roundsToSave,
                activeRoundId: activeRoundId
            });
            ROUNDS = roundsToSave;
            renderRoundsTable();
        }

        // Fonction pour mettre √† jour un champ d'un tour
        window.updateRoundField = async (roundId, field, value) => {
            const round = ROUNDS.find(r => r.id === roundId);
            if (round) {
                round[field] = value;
                if (field === 'type') {
                    round.type_epreuve = getTypeEpreuveFromType(value);
                }
                console.log(`üîÑ Mise √† jour du tour ${roundId}: ${field} = ${value}`);
                await saveRounds();
            }
        };
        
        function renderRoundsTable() {
            const tbody = document.getElementById('rounds-table-body');
            const select = document.getElementById('active-round-select');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            
            // Trier par ordre
            const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
            
            sortedRounds.forEach(round => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td class="actions">
                        <button class="icon-btn delete" onclick="deleteRound('${round.id}')" title="Supprimer">üóëÔ∏è</button>
                    </td>
                    <td><input type="number" id="round-order-${round.id}" name="round-order-${round.id}" value="${round.order}" onchange="updateRoundField('${round.id}', 'order', parseInt(this.value))" style="width: 60px; padding: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px;"></td>
                    <td><input type="text" id="round-name-${round.id}" name="round-name-${round.id}" value="${(round.name || '').replace(/"/g, '&quot;')}" onchange="updateRoundField('${round.id}', 'name', this.value)" style="width: 100%; padding: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px;"></td>
                    <td>
                        <select id="round-type-${round.id}" name="round-type-${round.id}" onchange="updateRoundField('${round.id}', 'type', this.value)" style="width: 100%; min-width: 200px; padding: 6px 8px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px; font-size: 13px;">
                            <option value="Notation individuelle" ${round.type === 'Notation individuelle' || round.type === 'Classement' ? 'selected' : ''}>Notation individuelle</option>
                            <option value="Rep√™chage" ${round.type === 'Rep√™chage' ? 'selected' : ''}>Rep√™chage</option>
                            <option value="Duels" ${round.type === 'Duels' ? 'selected' : ''}>Duels</option>
                        </select>
                    </td>
                    <td><input type="text" id="round-next-${round.id}" name="round-next-${round.id}" value="${String(round.nextRoundCandidates ?? '').replace(/"/g, '&quot;')}" onchange="updateRoundField('${round.id}', 'nextRoundCandidates', this.value)" style="width: 100%; padding: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px;" placeholder="ALL ou nombre"></td>
                `;
            });
            
            // Mettre √† jour le dropdown du tour actif
            if (select) {
                select.innerHTML = '<option value="">-- S√©lectionner un tour --</option>';
                sortedRounds.forEach(round => {
                    const option = document.createElement('option');
                    option.value = round.id;
                    option.textContent = round.name;
                    option.selected = (round.id === activeRoundId);
                    select.appendChild(option);
                });
            }
            
        }
        
        window.addRound = () => {
            // Cr√©er un nouveau tour avec des valeurs par d√©faut
            const newId = `round${Date.now()}`;
            const newOrder = ROUNDS.length > 0 ? Math.max(...ROUNDS.map(r => r.order)) + 1 : 1;
            const roundNumber = ROUNDS.length + 1;
            
            ROUNDS.push({
                id: newId,
                order: newOrder,
                name: `Tour #${roundNumber}`,
                type: 'Notation individuelle',
                nextRoundCandidates: 'ALL',
                active: false
            });
            
            saveRounds();
        };
        
        window.editRound = async (roundId) => {
            const round = ROUNDS.find(r => r.id === roundId);
            if (!round) return;
            
            const name = await prompt("Nom du tour:", round.name);
            if (!name || !name.trim()) return;
            
            const typeNum = {
                'Notation individuelle': '1',
                'Rep√™chage': '2',
                'Duels': '3'
            }[round.type] || '1';
            
            const type = await prompt(`Type du tour:\n1 - Notation individuelle\n2 - Rep√™chage\n3 - Duels\n\nEntrez le num√©ro:`, typeNum);
            const types = {
                '1': 'Notation individuelle',
                '2': 'Rep√™chage',
                '3': 'Duels'
            };
            
            if (!types[type]) {
                alert("Type invalide");
                return;
            }
            
            const nextCandidates = await prompt("Nombre de candidats pour le tour suivant (ou 'ALL' pour tous):", 
                round.nextRoundCandidates === 'ALL' ? 'ALL' : round.nextRoundCandidates.toString());
            if (!nextCandidates || !nextCandidates.trim()) return;
            
            const candidates = nextCandidates.toUpperCase() === 'ALL' ? 'ALL' : parseInt(nextCandidates);
            if (candidates !== 'ALL' && isNaN(candidates)) {
                alert("Nombre invalide");
                return;
            }
            
            round.name = name.trim();
            round.type = types[type];
            round.nextRoundCandidates = candidates;
            
            saveRounds();
        };
        
        window.deleteRound = async (roundId) => {
            const round = ROUNDS.find(r => r.id === roundId);
            if (!round) return;
            
            // V√©rifier si ce tour contient des scores
            const scoresSnap = await getDocs(query(collection(db, "scores"), where("roundId", "==", roundId)));
            if (!scoresSnap.empty) {
                if (!await confirm(`Ce tour contient ${scoresSnap.size} notation(s). Supprimer le tour ET toutes ses notations ?`)) {
                    return;
                }
                
                // Supprimer tous les scores du tour
                const batch = writeBatch(db);
                scoresSnap.forEach(doc => batch.delete(doc.ref));
                await batch.commit();
            } else {
                if (!await confirm(`Supprimer le tour "${round.name}" ?`)) {
                    return;
                }
            }
            
            ROUNDS = ROUNDS.filter(r => r.id !== roundId);
            
            // Si on supprime le tour actif, activer le premier tour disponible
            if (activeRoundId === roundId && ROUNDS.length > 0) {
                activeRoundId = ROUNDS[0].id;
                ROUNDS[0].active = true;
            }
            
            saveRounds();
        };
        
        window.setActiveRound = (roundId) => {
            ROUNDS.forEach(r => r.active = (r.id === roundId));
            activeRoundId = roundId;
            saveRounds();
        };
        
        async function initializeRepechage(previousRoundId, repechageRoundId) {
            try {
                console.log(`üéØ Initialisation du rep√™chage pour le tour ${repechageRoundId}`);
                
                const repechageRound = ROUNDS.find(r => r.id === repechageRoundId);
                if (!repechageRound) {
                    console.error('Tour de rep√™chage introuvable');
                    return;
                }
                
                const topN = parseInt(repechageRound.nextRoundCandidates) || 10;
                console.log(`üìä Nombre de candidats √† qualifier: ${topN}`);
                
                // R√©cup√©rer les scores du tour pr√©c√©dent
                const scoresQuery = query(
                    collection(db, "scores"),
                    where("roundId", "==", previousRoundId)
                );
                const scoresSnap = await getDocs(scoresQuery);
                
                // Calculer les scores totaux par candidat
                const candidateScores = {};
                scoresSnap.forEach(docSnap => {
                    const data = docSnap.data();
                    if (!candidateScores[data.candidateId]) {
                        candidateScores[data.candidateId] = 0;
                    }
                    
                    // Calculer le score pond√©r√©
                    if (data.score1 && data.score1 !== '-' && data.score2 && data.score2 !== '-') {
                        if (data.score1 === 'EL' || data.score2 === 'EL') {
                            // √âlimination = 0
                            candidateScores[data.candidateId] += 0;
                        } else {
                            const weighted = (parseInt(data.score1) * 3) + parseInt(data.score2);
                            candidateScores[data.candidateId] += weighted;
                        }
                    }
                });
                
                // Trier les candidats par score d√©croissant
                const sortedCandidates = Object.entries(candidateScores)
                    .sort((a, b) => b[1] - a[1]) // Tri d√©croissant
                    .map(([candidateId, score]) => candidateId);
                
                console.log('üìä Classement des candidats:', sortedCandidates.map((id, i) => `${i+1}. ${id} (${candidateScores[id]}pts)`));
                
                // Les topN premiers re√ßoivent "1", les autres re√ßoivent "0"
                const qualifiedCandidates = new Set(sortedCandidates.slice(0, topN));
                const eliminatedCandidates = sortedCandidates.slice(topN);
                
                console.log(`‚úÖ ${qualifiedCandidates.size} candidats qualifi√©s:`, Array.from(qualifiedCandidates));
                console.log(`‚ùå ${eliminatedCandidates.length} candidats √©limin√©s:`, eliminatedCandidates);
                
                // Charger tous les jurys
                await loadJuries();
                
                // Filtrer les jurys pr√©sents sur le tour de rep√™chage
                const juriesOnRepechage = JURIES.filter(jury => {
                    return jury.rounds && jury.rounds.includes(repechageRoundId);
                });
                
                console.log(`üë• Jurys pr√©sents sur le rep√™chage:`, juriesOnRepechage.map(j => j.name));
                
                // Cr√©er les scores pour tous les candidats actifs du rep√™chage
                const candidatesInRepechage = CANDIDATES.filter(c => c.tour === repechageRoundId && c.status === 'Actif');
                
                const batch = writeBatch(db);
                let scoresCreated = 0;
                
                for (const candidate of candidatesInRepechage) {
                    const noteValue = qualifiedCandidates.has(candidate.id) ? '1' : '0';
                    
                    // Cr√©er les scores seulement pour les jurys pr√©sents sur ce tour
                    for (const jury of juriesOnRepechage) {
                        const newScoreRef = doc(collection(db, "scores"));
                        batch.set(newScoreRef, {
                            juryId: jury.id,
                            juryName: jury.name,
                            candidateId: candidate.id,
                            roundId: repechageRoundId,
                            score1: noteValue,
                            score2: noteValue, // Les deux scores sont identiques pour le rep√™chage
                            timestamp: new Date()
                        });
                        scoresCreated++;
                    }
                }
                
                await batch.commit();
                console.log(`‚úÖ ${scoresCreated} scores de rep√™chage cr√©√©s`);
                
                await customAlert(`üéØ Rep√™chage initialis√© !\n\n‚úÖ ${qualifiedCandidates.size} candidats qualifi√©s (note "1")\n‚ùå ${eliminatedCandidates.length} candidats √©limin√©s (note "0")\n\nChaque jury peut maintenant modifier ces notes si n√©cessaire.`);
                
            } catch (e) {
                console.error('‚ùå Erreur lors de l\'initialisation du rep√™chage:', e);
                await customAlert('‚ùå Erreur lors de l\'initialisation du rep√™chage:\n' + e.message);
            }
        }

        window.finishRound = async () => {
            if (!activeRoundId) {
                await customAlert("Aucun tour actif s√©lectionn√©.");
                return;
            }
            
            const activeRound = ROUNDS.find(r => r.id === activeRoundId);
            if (!activeRound) {
                await customAlert("Tour actif introuvable.");
                return;
            }
            
            // V√©rifier que tous les candidats du tour actif sont soit qualifi√©s soit √©limin√©s
            const candidatesInRound = CANDIDATES.filter(c => c.tour === activeRoundId);
            const candidatesNotReady = candidatesInRound.filter(c => c.status !== 'Qualifie' && c.status !== 'Elimine');
            
            if (candidatesNotReady.length > 0) {
                const names = candidatesNotReady.map(c => `- ${c.name} (${c.status})`).join('\n');
                await customAlert(`‚ùå Impossible de terminer le tour.\n\n${candidatesNotReady.length} candidat(s) ne sont ni Qualifi√©s ni √âlimin√©s :\n\n${names}\n\nVeuillez mettre √† jour leur statut dans l'onglet "Notes".`);
                return;
            }
            
            // Trouver le tour suivant
            const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
            const currentIndex = sortedRounds.findIndex(r => r.id === activeRoundId);
            
            if (currentIndex === -1) {
                await customAlert("Erreur : impossible de trouver le tour actif.");
                return;
            }
            
            if (currentIndex >= sortedRounds.length - 1) {
                await customAlert("C'est le dernier tour. Impossible de passer au tour suivant.");
                return;
            }
            
            const nextRound = sortedRounds[currentIndex + 1];
            
            // Demander confirmation
            const qualifiedCount = candidatesInRound.filter(c => c.status === 'Qualifie').length;
            const eliminatedCount = candidatesInRound.filter(c => c.status === 'Elimine').length;
            
            if (!await customConfirm(`Terminer le tour "${activeRound.name}" ?\n\n‚úì ${qualifiedCount} candidat(s) qualifi√©(s) passeront au tour "${nextRound.name}"\n‚úó ${eliminatedCount} candidat(s) √©limin√©(s)\n\nContinuer ?`)) {
                return;
            }
            
            // Passer les candidats qualifi√©s au tour suivant et les remettre en "Actif"
            let movedCount = 0;
            CANDIDATES.forEach(candidate => {
                if (candidate.tour === activeRoundId && candidate.status === 'Qualifie') {
                    candidate.tour = nextRound.id;
                    candidate.status = 'Actif';
                    movedCount++;
                }
            });
            
            // Sauvegarder les modifications
            await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: CANDIDATES });
            
            // Changer le tour actif
            activeRoundId = nextRound.id;
            ROUNDS.forEach(r => r.active = (r.id === activeRoundId));
            await saveRounds();
            
            // Si le tour suivant est un Rep√™chage, initialiser automatiquement
            if (nextRound.type === 'Rep√™chage') {
                console.log('üéØ Tour suivant est un Rep√™chage, initialisation...');
                await initializeRepechage(activeRound.id, nextRound.id);
            }
            
            // Notifier les jurys connect√©s du changement de tour
            await loadJuries();
            const juriesOnNextRound = JURIES.filter(j => j.rounds && j.rounds.includes(nextRound.id));
            const juryIdsOnNextRound = new Set(juriesOnNextRound.map(j => j.id));
            
            // Cr√©er un signal pour les jurys (timestamp pour forcer la d√©tection)
            await setDoc(doc(db, "config", "roundChange"), {
                newRoundId: nextRound.id,
                newRoundName: nextRound.name,
                juriesOnNewRound: Array.from(juryIdsOnNextRound),
                timestamp: new Date()
            });
            
            await customAlert(`‚úì Tour termin√© avec succ√®s !\n\n${movedCount} candidat(s) qualifi√©(s) sont pass√©s au tour "${nextRound.name}".\n\nLe tour actif est maintenant : "${nextRound.name}"\n\n‚ÑπÔ∏è Les jurys pr√©sents sur le tour suivant verront leur page se recharger automatiquement.`);
            
            // Rafra√Æchir l'affichage
            renderNotesTable();
        };
        
        // Charger tours et candidats au d√©marrage pour que tous les onglets et le classement soient coh√©rents (listener met √† jour le classement m√™me si on n'est pas sur l'onglet Notes)
        (async function initAdminData() {
            await loadRounds();
            await loadList();
            console.log('üöÄ Donn√©es admin charg√©es (ROUNDS, CANDIDATES). Initialisation des listeners...');
            setupScoresListener();
            setupCandidatesListener();
            console.log('%c[CLASSEMENT] Pour d√©boguer le bonus: filtrez la console par "CLASSEMENT". Puis: Activation classements ‚Üí activer +5 pour un candidat ‚Üí Notes ‚Üí revenir Activation. Copiez toutes les lignes [CLASSEMENT].', 'color: #0a0; font-weight: bold;');
        })();

        // --- GESTION NOTES ---
        // Variables globales pour le tri du tableau Notes et l'affichage des tours
        let notesSortColumn = 'id'; // Tri par d√©faut par ID
        let notesSortAscending = true;
        let notesDisplayRound = null; // Tour affich√© dans le tableau Notes
        let podiumDisplayRound = null; // Tour affich√© dans le podium
        let podiumFinalList = null;     // Classement final (avec bonus et points activ√©s) pour l'onglet Podium uniquement
        let podiumFinalListRound = null;
        let duelDisplayRound = null; // Tour affich√© dans l'onglet Duels
        let duelsList = []; // Liste des duels : [ { duelId, candidate1Id, candidate2Id, winnerId } ]
        let activationClassementRoundId = null; // Tour (Classement) pour l'onglet Activation classements
        let activationClassementId = null; // ID du document classement
        
        async function renderNotesTable() {
            console.log('[CLASSEMENT] renderNotesTable ENTR√âE (lecture seule, n\'√©crit pas au classement)');
            // √âviter les appels multiples en parall√®le
            if (isRenderingNotesTable) {
                console.log('[CLASSEMENT] renderNotesTable d√©j√† en cours, skip');
                return;
            }
            isRenderingNotesTable = true;
            
            try {
            const tbody = document.getElementById('notes-table-body');
            const thead = document.querySelector('#notes-table thead tr');
            tbody.innerHTML = '';
            
            // Utiliser le tour s√©lectionn√© dans le dropdown ou le tour actif par d√©faut
            const displayRound = notesDisplayRound || activeRoundId || 'round1';
            
            console.log(`üîç [renderNotesTable] ==========================================`);
            console.log(`üîç [renderNotesTable] notesDisplayRound: ${notesDisplayRound}`);
            console.log(`üîç [renderNotesTable] activeRoundId: ${activeRoundId}`);
            console.log(`üîç [renderNotesTable] displayRound (utilis√©): ${displayRound}`);
            
            // D√©terminer le type du tour affich√© et le tour pr√©c√©dent
            const currentRound = ROUNDS.find(r => r.id === displayRound);
            const isRepechage = currentRound && currentRound.type === 'Rep√™chage';
            let previousRoundId = null;
            
            if (isRepechage) {
                const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
                const currentIndex = sortedRounds.findIndex(r => r.id === displayRound);
                if (currentIndex > 0) {
                    previousRoundId = sortedRounds[currentIndex - 1].id;
                }
            }
            
            console.log(`üîç [renderNotesTable] Type de tour: ${currentRound?.type}, isRepechage: ${isRepechage}, previousRoundId: ${previousRoundId}`);
            
            // Charger TOUS les jurys depuis la collection accounts
            await loadJuries();
            
            // Filtrer les jurys pr√©sents sur le tour affich√©
            const juriesOnRound = JURIES.filter(jury => {
                return jury.rounds && jury.rounds.includes(displayRound);
            });
            const sortedJuries = [...juriesOnRound].sort((a, b) => a.name.localeCompare(b.name));
            
            console.log(`üîç [renderNotesTable] Jurys pr√©sents sur le tour ${displayRound}:`, juriesOnRound.map(j => j.name));
            
            // Charger les tours valid√©s (verrouillage d√©finitif)
            const validatedSnap = await getDoc(doc(db, "config", "validated_rounds"));
            validatedRounds = validatedSnap.exists() ? (validatedSnap.data().rounds || {}) : {};
            const isRoundValidated = !!validatedRounds[displayRound];
            
            const validatedMsg = document.getElementById('notes-validated-message');
            const validateBtn = document.getElementById('notes-validate-round-btn');
            if (validatedMsg) validatedMsg.style.display = isRoundValidated ? 'block' : 'none';
            if (validateBtn) {
                validateBtn.style.display = 'inline-block';
                validateBtn.textContent = isRoundValidated ? 'D√©verrouiller le tour' : '‚úì Valider tout le tour';
                validateBtn.onclick = isRoundValidated ? unlockRoundGlobally : validateRoundGlobally;
                validateBtn.style.background = isRoundValidated ? 'linear-gradient(135deg, #fd7e14 0%, #e8590c 100%)' : 'linear-gradient(135deg, #28a745 0%, #1e7e34 100%)';
            }
            
            // Charger les scores du tour s√©lectionn√©
            const q = query(
                collection(db, "scores"),
                where("roundId", "==", displayRound)
            );
            const querySnapshot = await getDocs(q);
            const scoresByCandidate = {};
            
            console.log(`üîç [renderNotesTable] Chargement des scores pour le tour: ${displayRound}`);
            console.log(`üîç [renderNotesTable] Nombre de scores trouv√©s: ${querySnapshot.size}`);
            
            querySnapshot.forEach(docSnap => {
                const data = docSnap.data();
                const juryId = data.juryId || data.juryName;
                console.log(`üîç [renderNotesTable] Score trouv√©: candidateId=${data.candidateId}, juryId=${juryId}, score1=${data.score1}, score2=${data.score2}`);
                if (!scoresByCandidate[data.candidateId]) {
                    scoresByCandidate[data.candidateId] = {};
                }
                scoresByCandidate[data.candidateId][juryId] = {
                    id: docSnap.id,
                    score1: data.score1,
                    score2: data.score2,
                    score_base: data.score_base != null ? data.score_base : computeScoreBase(data.score1, data.score2, displayRound)
                };
            });
            
            console.log(`üîç [renderNotesTable] scoresByCandidate:`, scoresByCandidate);
            
            // Si c'est un rep√™chage, charger aussi les scores du tour pr√©c√©dent pour affichage
            let previousRoundScores = {};
            let previousRoundJuries = [];
            if (isRepechage && previousRoundId) {
                const prevQuery = query(
                    collection(db, "scores"),
                    where("roundId", "==", previousRoundId)
                );
                const prevQuerySnapshot = await getDocs(prevQuery);
                
                // Charger les jurys qui √©taient pr√©sents sur le tour pr√©c√©dent
                const previousRoundJuriesSet = new Set();
                prevQuerySnapshot.forEach(docSnap => {
                    const data = docSnap.data();
                    const juryId = data.juryId || data.juryName;
                    previousRoundJuriesSet.add(juryId);
                    
                    if (!previousRoundScores[data.candidateId]) {
                        previousRoundScores[data.candidateId] = {};
                    }
                    previousRoundScores[data.candidateId][juryId] = {
                        score1: data.score1,
                        score2: data.score2
                    };
                });
                
                // Filtrer les jurys pour obtenir ceux du tour pr√©c√©dent
                previousRoundJuries = JURIES.filter(j => previousRoundJuriesSet.has(j.id));
                
                console.log(`üîç [renderNotesTable] Scores du tour pr√©c√©dent charg√©s:`, previousRoundScores);
                console.log(`üîç [renderNotesTable] Jurys du tour pr√©c√©dent:`, previousRoundJuries.map(j => j.name));
            }
            
            // Calculer le score total pour chaque candidat
            console.log(`üîç [renderNotesTable] Nombre de candidats √† traiter: ${CANDIDATES.length}`);
            console.log(`üîç [renderNotesTable] Nombre de jurys: ${sortedJuries.length}`);
            console.log(`üîç [renderNotesTable] IDs des jurys:`, sortedJuries.map(j => j.id));
            
            let candidatesWithScores = CANDIDATES.map(candidate => {
                let totalScore = 0;
                let hasScores = false;
                
                if (isRepechage) {
                    // Pour le rep√™chage, v√©rifier d'abord le vote du pr√©sident
                    const president = sortedJuries.find(j => j.isPresident);
                    let presidentVote = null;
                    
                    if (president) {
                        const presidentScore = scoresByCandidate[candidate.id]?.[president.id];
                        if (presidentScore && presidentScore.score1 !== '-') {
                            presidentVote = presidentScore.score1; // '0' ou '1'
                        }
                    }
                    
                    // Si le pr√©sident a vot√© "0" (√©limin√©), le score est 0
                    if (presidentVote === '0') {
                        totalScore = 0;
                        hasScores = true;
                    }
                    // Si le pr√©sident a vot√© "1" (qualifi√©) ou n'a pas encore vot√©, afficher le score du tour pr√©c√©dent
                    else {
                        previousRoundJuries.forEach(jury => {
                            const scores = previousRoundScores[candidate.id]?.[jury.id];
                            if (scores) {
                                // V√©rifier si ce jury a not√© le candidat (pas de '-')
                                if (scores.score1 !== '-' && scores.score2 !== '-') {
                                    hasScores = true;
                                    
                                    // R√®gle : si un jury met "EL", toute sa notation = 0
                                    if (scores.score1 === 'EL' || scores.score2 === 'EL') {
                                        totalScore += 0;
                                    } else {
                                        const s1 = parseFloat(scores.score1) || 0;
                                        const s2 = parseFloat(scores.score2) || 0;
                                        totalScore += (s1 * 3 + s2);
                                    }
                                }
                            }
                        });
                    }
                } else {
                    // Pour les autres tours, utiliser les jurys pr√©sents sur ce tour
                    sortedJuries.forEach(jury => {
                        const scores = scoresByCandidate[candidate.id]?.[jury.id];
                        if (scores) {
                            // V√©rifier si ce jury a not√© le candidat (pas de '-')
                            if (scores.score1 !== '-' && scores.score2 !== '-') {
                                hasScores = true;
                                
                                // R√®gle : si un jury met "EL", toute sa notation = 0
                                if (scores.score1 === 'EL' || scores.score2 === 'EL') {
                                    totalScore += 0;
                                } else {
                                    const s1 = parseFloat(scores.score1) || 0;
                                    const s2 = parseFloat(scores.score2) || 0;
                                    totalScore += (s1 * 3 + s2);
                                }
                            }
                        }
                    });
                }
                
                let totalScoreBase = 0;
                if (!isRepechage) {
                    sortedJuries.forEach(jury => {
                        const scores = scoresByCandidate[candidate.id]?.[jury.id];
                        if (scores && scores.score1 !== '-' && scores.score2 !== '-') {
                            totalScoreBase += (scores.score_base != null ? scores.score_base : computeScoreBase(scores.score1, scores.score2, displayRound));
                        }
                    });
                }
                
                return {
                    candidate,
                    totalScore: hasScores ? totalScore : null,
                    totalScoreBase: !isRepechage && totalScoreBase > 0 ? totalScoreBase : null,
                    scoresByJury: scoresByCandidate[candidate.id] || {},
                    previousRoundScoresByJury: isRepechage ? (previousRoundScores[candidate.id] || {}) : {}
                };
            });
            
            // Filtrer par tour si le checkbox est coch√©
            const filterCheckbox = document.getElementById('notes-filter-current-round');
            if (filterCheckbox && filterCheckbox.checked) {
                candidatesWithScores = candidatesWithScores.filter(item => 
                    item.candidate.tour === displayRound
                );
            }
            
            // Appliquer le tri si une colonne est s√©lectionn√©e
            if (notesSortColumn) {
                candidatesWithScores.sort((a, b) => {
                    let valA, valB;
                    
                    if (notesSortColumn === 'id') {
                        valA = parseInt(a.candidate.id) || 0;
                        valB = parseInt(b.candidate.id) || 0;
                    } else if (notesSortColumn === 'candidat') {
                        valA = a.candidate.name.toLowerCase();
                        valB = b.candidate.name.toLowerCase();
                    } else if (notesSortColumn === 'score') {
                        valA = a.totalScore !== null ? a.totalScore : -Infinity;
                        valB = b.totalScore !== null ? b.totalScore : -Infinity;
                    } else if (notesSortColumn === 'tour') {
                        const roundA = ROUNDS.find(r => r.id === a.candidate.tour);
                        const roundB = ROUNDS.find(r => r.id === b.candidate.tour);
                        valA = roundA ? roundA.name.toLowerCase() : '';
                        valB = roundB ? roundB.name.toLowerCase() : '';
                    } else if (notesSortColumn === 'statut') {
                        valA = a.candidate.status.toLowerCase();
                        valB = b.candidate.status.toLowerCase();
                    }
                    
                    if (valA < valB) return notesSortAscending ? -1 : 1;
                    if (valA > valB) return notesSortAscending ? 1 : -1;
                    return 0;
                });
            }
            
            // Construire l'en-t√™te avec colonnes triables
            const sortIcon = (col) => {
                if (notesSortColumn === col) {
                    return notesSortAscending ? ' ‚ñ≤' : ' ‚ñº';
                }
                return '';
            };
            
            // En-t√™te diff√©rent pour rep√™chage vs autres tours
            const juryHeaders = isRepechage 
                ? sortedJuries.map(j => `<th class="col-score" style="min-width: 90px;">${j.name}<br><small>(0 ou 1)</small></th>`).join('')
                : sortedJuries.map(j => `<th colspan="2" class="col-score" style="min-width: 180px;">${j.name}<br><small>(Fond | Forme)</small></th>`).join('');
            
            const scoreLabel = isRepechage ? 'Score<br><small>(tour pr√©c√©dent)</small>' : 'Score<br><small>(pond√©r√©)</small>';
            
            thead.innerHTML = `
                <th style="width: 60px; cursor: pointer;" onclick="sortNotesTable('id')">ID${sortIcon('id')}</th>
                <th class="col-candidate" style="cursor: pointer;" onclick="sortNotesTable('candidat')">Candidat${sortIcon('candidat')}</th>
                <th style="width: 100px; cursor: pointer;" onclick="sortNotesTable('score')">${scoreLabel}${sortIcon('score')}</th>
                ${isRepechage ? '' : '<th style="width: 90px; text-align: center;">Score base</th>'}
                <th style="min-width: 200px; width: 200px; cursor: pointer;" onclick="sortNotesTable('tour')">Dernier Tour${sortIcon('tour')}</th>
                <th style="width: 150px; cursor: pointer;" onclick="sortNotesTable('statut')">Statut${sortIcon('statut')}</th>
                ${juryHeaders}
            `;
            
            // Construire les lignes
            candidatesWithScores.forEach(item => {
                const candidate = item.candidate;
                const row = tbody.insertRow();
                
                // ID
                const idCell = row.insertCell();
                idCell.textContent = candidate.id;
                idCell.style.textAlign = 'center';
                
                // Nom du candidat
                const nameCell = row.insertCell();
                nameCell.className = 'candidate-name col-candidate';
                nameCell.textContent = candidate.name;
                
                // Score total (pond√©r√©)
                const scoreCell = row.insertCell();
                if (isRepechage && item.totalScore === null) {
                    scoreCell.textContent = '0';
                } else {
                    scoreCell.textContent = item.totalScore !== null ? item.totalScore.toFixed(0) : '-';
                }
                scoreCell.style.textAlign = 'center';
                scoreCell.style.fontWeight = 'bold';
                
                // Score base (Fond+Forme) ‚Äî uniquement pour tours non rep√™chage
                if (!isRepechage) {
                    const scoreBaseCell = row.insertCell();
                    scoreBaseCell.textContent = item.totalScoreBase != null ? item.totalScoreBase : '-';
                    scoreBaseCell.style.textAlign = 'center';
                }
                
                // Tour
                const tourCell = row.insertCell();
                tourCell.innerHTML = createTourDropdown(candidate);
                
                // Statut
                const statusCell = row.insertCell();
                statusCell.innerHTML = createStatusDropdown(candidate);
                
                // Notes par jury
                sortedJuries.forEach(jury => {
                    const scores = item.scoresByJury[jury.id];
                    
                    if (isRepechage) {
                        // Pour rep√™chage : une seule colonne par jury (0 ou 1)
                        const cell = row.insertCell();
                        cell.className = 'col-score';
                        cell.style.minWidth = '90px';
                        cell.style.width = '90px';
                        cell.style.textAlign = 'center';
                        
                        // Lecture seule si tour valid√© (verrouillage d√©finitif) ou statut Qualifie/Elimine
                        const readonly = isRoundValidated || (candidate.status === 'Elimine' || candidate.status === 'Qualifie');
                        
                        if (scores) {
                            cell.innerHTML = createRepechageScoreDropdown(scores.id, scores.score1, candidate.id, jury.id, readonly);
                        } else {
                            cell.innerHTML = createRepechageScoreDropdown(null, '-', candidate.id, jury.id, readonly);
                        }
                    } else {
                        // Pour autres tours : deux colonnes (Fond | Forme)
                        const cell1 = row.insertCell();
                        const cell2 = row.insertCell();
                        cell1.className = 'col-score';
                        cell2.className = 'col-score';
                        cell1.style.minWidth = '90px';
                        cell1.style.width = '90px';
                        cell2.style.minWidth = '90px';
                        cell2.style.width = '90px';
                        
                        // Lecture seule si tour valid√© (verrouillage d√©finitif) ou statut Qualifie/Elimine
                        const readonly = isRoundValidated || (candidate.status === 'Elimine' || candidate.status === 'Qualifie');
                        
                        if (scores) {
                            cell1.innerHTML = createScoreDropdown(scores.id, 'score1', scores.score1, candidate.id, jury.id, readonly);
                            cell2.innerHTML = createScoreDropdown(scores.id, 'score2', scores.score2, candidate.id, jury.id, readonly);
                        } else {
                            cell1.innerHTML = createScoreDropdown(null, 'score1', '-', candidate.id, jury.id, readonly);
                            cell2.innerHTML = createScoreDropdown(null, 'score2', '-', candidate.id, jury.id, readonly);
                        }
                    }
                });
            });

            } finally {
                isRenderingNotesTable = false;
            }
        }

        /** Met √† jour le classement pour un tour donn√© √† partir des scores (fond/forme), en pr√©servant les points d'activation et duelBonusEnabled. Appel√© √† chaque changement de notes (listener ou admin), quel que soit l'onglet affich√©. Charge toujours candidats et tours depuis Firestore pour ne pas d√©pendre de l'onglet ouvert. */
        async function updateClassementFromScoresForRound(roundId) {
            if (!roundId) return;
            console.log('[CLASSEMENT] updateClassementFromScoresForRound ENTR√âE roundId=', roundId);
            try {
                const scoresQuery = query(collection(db, "scores"), where("roundId", "==", roundId));
                const scoresSnap = await getDocs(scoresQuery);
                const totalBaseByCandidate = {};
                scoresSnap.forEach(d => {
                    const data = d.data();
                    const cid = data.candidateId;
                    const base = data.score_base != null ? data.score_base : computeScoreBase(data.score1, data.score2, roundId);
                    totalBaseByCandidate[cid] = (totalBaseByCandidate[cid] || 0) + base;
                });
                // Charger les candidats depuis Firestore (ne pas d√©pendre de CANDIDATES en m√©moire, qui peut √™tre vide si on n'a pas ouvert l'onglet Candidats)
                const candidatsSnap = await getDoc(doc(db, "candidats", "liste_actuelle"));
                const allCandidates = candidatsSnap.exists() ? (candidatsSnap.data().candidates || []) : [];
                const roundCandidates = allCandidates.filter(c => (c.tour || '') === roundId);
                const withScore = roundCandidates.map(c => ({
                    candidateId: c.id,
                    name: c.name || c.id,
                    score_base: totalBaseByCandidate[c.id] || 0
                }));
                withScore.sort((a, b) => b.score_base - a.score_base);
                if (withScore.length === 0) {
                    console.log('[CLASSEMENT] updateClassementFromScoresForRound: withScore vide, return');
                    return;
                }
                // R√©solution du classementId identique √† loadActivationClassementsData pour toujours √©crire dans le m√™me doc que l'onglet Activation (et donc lire les bons points d'activation)
                let classementId = null;
                const roundsSnap = await getDoc(doc(db, "config", "rounds"));
                const roundsList = roundsSnap.exists() ? (roundsSnap.data().rounds || []) : [];
                const round = roundsList.find(r => r.id === roundId);
                if (round && round.classementId && String(round.classementId).trim()) {
                    classementId = String(round.classementId).trim();
                }
                if (!classementId) {
                    const configActivationsSnap = await getDoc(doc(db, "config", "activations"));
                    classementId = (configActivationsSnap.exists() && configActivationsSnap.data().classementIdActif)
                        ? configActivationsSnap.data().classementIdActif.trim() : ('classement_' + roundId);
                }
                console.log('[CLASSEMENT] updateClassementFromScoresForRound: classementId=', classementId);
                const classementRef = doc(db, "classements", classementId);
                const classementSnap = await getDoc(classementRef);
                const currentData = classementSnap.exists() ? classementSnap.data() : {};
                if (classementSnap.exists() && currentData.code != null && currentData.code !== roundId) {
                    console.log('[CLASSEMENT] updateClassementFromScoresForRound: doc classement code !== roundId, return');
                    return;
                }
                // Toujours relire les activations juste avant d'√©crire (m√™me doc que l'onglet Activation) pour ne jamais √©craser les points
                const activationsSnap = await getDoc(doc(db, "classement_activations", classementId));
                const activated = activationsSnap.exists() ? (activationsSnap.data().activated || []) : [];
                console.log('[CLASSEMENT] updateClassementFromScoresForRound: activations lues =', activated.length, activated.map(a => `${a.candidateId}+${a.points}`).join(', '));
                const pointsByCandidate = {};
                activated.forEach(a => {
                    if (a.candidateId && (a.points != null || a.points === 0)) {
                        pointsByCandidate[a.candidateId] = (pointsByCandidate[a.candidateId] || 0) + (typeof a.points === 'number' ? a.points : parseFloat(a.points) || 0);
                    }
                });
                console.log('[CLASSEMENT] updateClassementFromScoresForRound: pointsByCandidate =', JSON.stringify(pointsByCandidate));
                const entries = withScore.map((x, i) => {
                    const base = x.score_base != null ? (typeof x.score_base === 'number' ? x.score_base : parseFloat(x.score_base) || 0) : 0;
                    const points = pointsByCandidate[x.candidateId] != null ? pointsByCandidate[x.candidateId] : 0;
                    const total = Math.round((base + points) * 100) / 100;
                    return {
                        rank: i + 1,
                        candidateId: x.candidateId,
                        name: x.name,
                        score_base: x.score_base,
                        score_appliqu√©: total,
                        score_affich√©: total
                    };
                });
                entries.sort((a, b) => (b.score_appliqu√© ?? 0) - (a.score_appliqu√© ?? 0));
                entries.forEach((e, i) => { e.rank = i + 1; });
                // Sauvegarde : ne JAMAIS √©craser le classement si le doc actuel a des points d'activation et qu'on √©crirait des scores plus bas (sinon on perdrait les points ; ne pas appeler recalculate ici car il relirait les m√™mes activations et pourrait aussi √©craser en cas de cache/doc diff√©rent)
                const currentEntries = currentData.entries || [];
                const entriesWithBonus = currentEntries.filter(e => {
                    const base = e.score_base != null ? (typeof e.score_base === 'number' ? e.score_base : parseFloat(e.score_base) || 0) : 0;
                    const applied = e.score_appliqu√© != null ? (typeof e.score_appliqu√© === 'number' ? e.score_appliqu√© : parseFloat(e.score_appliqu√©) || 0) : 0;
                    return applied > base;
                });
                console.log('[CLASSEMENT] updateClassementFromScoresForRound: currentEntries=', currentEntries.length, 'dont avec bonus (appliqu√©>base)=', entriesWithBonus.length, entriesWithBonus.map(e => `${e.candidateId}:${e.score_base}‚Üí${e.score_appliqu√©}`).join(', '));
                const newByCid = Object.fromEntries(entries.map(e => [e.candidateId, e]));
                const wouldLosePoints = currentEntries.some(e => {
                    const base = e.score_base != null ? (typeof e.score_base === 'number' ? e.score_base : parseFloat(e.score_base) || 0) : 0;
                    const applied = e.score_appliqu√© != null ? (typeof e.score_appliqu√© === 'number' ? e.score_appliqu√© : parseFloat(e.score_appliqu√©) || 0) : 0;
                    const newEntry = newByCid[e.candidateId];
                    const newApplied = newEntry ? (newEntry.score_appliqu√© != null ? newEntry.score_appliqu√© : 0) : 0;
                    return applied > base && newApplied < applied;
                });
                const losingCandidates = currentEntries.filter(e => {
                    const base = e.score_base != null ? (typeof e.score_base === 'number' ? e.score_base : parseFloat(e.score_base) || 0) : 0;
                    const applied = e.score_appliqu√© != null ? (typeof e.score_appliqu√© === 'number' ? e.score_appliqu√© : parseFloat(e.score_appliqu√©) || 0) : 0;
                    const newEntry = newByCid[e.candidateId];
                    const newApplied = newEntry ? (newEntry.score_appliqu√© != null ? newEntry.score_appliqu√© : 0) : 0;
                    return applied > base && newApplied < applied;
                });
                if (wouldLosePoints) {
                    console.log('[CLASSEMENT] updateClassementFromScoresForRound: SKIP √âCRITURE (wouldLosePoints) candidats qui perdraient des points:', losingCandidates.map(e => e.candidateId).join(', '));
                    return;
                }
                const duelBonusEnabled = Array.isArray(currentData.duelBonusEnabled) ? currentData.duelBonusEnabled : [];
                console.log('[CLASSEMENT] updateClassementFromScoresForRound: √âCRITURE classement', classementId, 'entries=', entries.length);
                await setDoc(classementRef, {
                    ...currentData,
                    code: roundId,
                    entries,
                    duelBonusEnabled,
                    readOnly: true,
                    lastUpdateSource: 'admin_sync_from_scores_listener',
                    updatedAt: new Date()
                }, { merge: true });
            } catch (e) {
                console.warn('[CLASSEMENT] updateClassementFromScoresForRound ERREUR:', e);
            }
        }

        /** Recalcule enti√®rement le classement du tour s√©lectionn√© √† partir des notes et candidats actuels (exclut les candidats supprim√©s). √Ä utiliser apr√®s suppression d‚Äôun candidat si le classement ne s‚Äôest pas mis √† jour. */
        window.refreshClassementFully = async function() {
            const roundId = activationClassementRoundId || document.getElementById('activation-classement-round')?.value;
            if (!roundId) {
                await customAlert('S√©lectionnez un tour dans la liste.');
                return;
            }
            try {
                const roundsSnap = await getDoc(doc(db, "config", "rounds"));
                const roundsList = roundsSnap.exists() ? (roundsSnap.data().rounds || []) : [];
                const round = roundsList.find(r => r.id === roundId);
                let classementId = (round && round.classementId) ? String(round.classementId).trim() : null;
                if (!classementId) {
                    const activationsSnap = await getDoc(doc(db, "config", "activations"));
                    classementId = (activationsSnap.exists() && activationsSnap.data().classementIdActif) ? activationsSnap.data().classementIdActif.trim() : ('classement_' + roundId);
                }
                const scoresQuery = query(collection(db, "scores"), where("roundId", "==", roundId));
                const scoresSnap = await getDocs(scoresQuery);
                const totalBaseByCandidate = {};
                scoresSnap.forEach(d => {
                    const data = d.data();
                    const cid = data.candidateId;
                    const base = data.score_base != null ? data.score_base : computeScoreBase(data.score1, data.score2, roundId);
                    totalBaseByCandidate[cid] = (totalBaseByCandidate[cid] || 0) + base;
                });
                const candidatsSnap = await getDoc(doc(db, "candidats", "liste_actuelle"));
                const allCandidates = candidatsSnap.exists() ? (candidatsSnap.data().candidates || []) : [];
                let roundCandidates = allCandidates.filter(c => (c.tour || '') === roundId);
                if (roundCandidates.length === 0) roundCandidates = allCandidates;
                const withScore = roundCandidates.map(c => ({
                    candidateId: c.id,
                    name: c.name || c.id,
                    score_base: totalBaseByCandidate[c.id] || 0
                }));
                withScore.sort((a, b) => b.score_base - a.score_base);
                const activationsSnap = await getDoc(doc(db, "classement_activations", classementId));
                const activated = activationsSnap.exists() ? (activationsSnap.data().activated || []) : [];
                const pointsByCandidate = {};
                activated.forEach(a => {
                    if (a.candidateId && (a.points != null || a.points === 0)) {
                        pointsByCandidate[a.candidateId] = (pointsByCandidate[a.candidateId] || 0) + (typeof a.points === 'number' ? a.points : parseFloat(a.points) || 0);
                    }
                });
                const entries = withScore.map((x, i) => {
                    const base = x.score_base != null ? (typeof x.score_base === 'number' ? x.score_base : parseFloat(x.score_base) || 0) : 0;
                    const points = pointsByCandidate[x.candidateId] != null ? pointsByCandidate[x.candidateId] : 0;
                    const total = Math.round((base + points) * 100) / 100;
                    return { rank: i + 1, candidateId: x.candidateId, name: x.name, score_base: x.score_base, score_appliqu√©: total, score_affich√©: total };
                });
                entries.sort((a, b) => (b.score_appliqu√© ?? 0) - (a.score_appliqu√© ?? 0));
                entries.forEach((e, i) => { e.rank = i + 1; });
                const classementSnap = await getDoc(doc(db, "classements", classementId));
                const currentData = classementSnap.exists() ? classementSnap.data() : {};
                const duelBonusEnabled = Array.isArray(currentData.duelBonusEnabled) ? currentData.duelBonusEnabled : [];
                await setDoc(doc(db, "classements", classementId), {
                    ...currentData,
                    code: roundId,
                    entries,
                    duelBonusEnabled,
                    lastUpdateSource: 'admin_refresh_classement_fully',
                    updatedAt: new Date()
                }, { merge: true });
                await customAlert('‚úì Classement actualis√©.\n\n' + entries.length + ' candidat(s) dans le classement (candidats supprim√©s exclus).');
                if (typeof loadActivationClassementsData === 'function') await loadActivationClassementsData();
            } catch (e) {
                console.error(e);
                await customAlert('Erreur lors de l\'actualisation : ' + (e.message || e));
            }
        };

        window.sortNotesTable = (column) => {
            if (notesSortColumn === column) {
                notesSortAscending = !notesSortAscending;
            } else {
                notesSortColumn = column;
                notesSortAscending = true;
            }
            renderNotesTable();
        };
        
        // Fonction pour remplir le dropdown des tours dans l'onglet Notes
        function populateNotesRoundDropdown() {
            const select = document.getElementById('notes-round-select');
            if (!select) return;
            
            const roundToSelect = notesDisplayRound || activeRoundId || (ROUNDS.length > 0 ? [...ROUNDS].sort((a, b) => (a.order || 0) - (b.order || 0))[0].id : null);
            select.innerHTML = '';
            const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
            
            sortedRounds.forEach(round => {
                const option = document.createElement('option');
                option.value = round.id;
                option.textContent = round.name;
                select.appendChild(option);
            });
            
            if (roundToSelect && sortedRounds.some(r => r.id === roundToSelect)) {
                select.value = roundToSelect;
            } else if (sortedRounds.length > 0) {
                select.value = sortedRounds[0].id;
            }
            
            // Attacher l'event listener sur la checkbox de filtrage (si pas d√©j√† fait)
            const filterCheckbox = document.getElementById('notes-filter-current-round');
            if (filterCheckbox && !filterCheckbox.hasAttribute('data-listener-attached')) {
                filterCheckbox.addEventListener('change', () => {
                    console.log('üîÑ Checkbox chang√©e, rechargement du tableau...');
                    renderNotesTable();
                });
                filterCheckbox.setAttribute('data-listener-attached', 'true');
            }
        }
        
        // Fonction pour remplir le dropdown des tours dans l'onglet Podium
        function populatePodiumRoundDropdown() {
            const select = document.getElementById('podium-round-select');
            if (!select) return;
            
            select.innerHTML = '';
            const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
            
            sortedRounds.forEach(round => {
                const option = document.createElement('option');
                option.value = round.id;
                option.textContent = round.name;
                option.selected = (round.id === (podiumDisplayRound || activeRoundId));
                select.appendChild(option);
            });
        }
        
        // Fonction pour changer le tour affich√© dans Notes
        window.changeNotesRound = (roundId) => {
            notesDisplayRound = roundId;
            renderNotesTable();
        };
        
        // Fonction pour changer le tour affich√© dans Podium
        window.changePodiumRound = (roundId) => {
            podiumDisplayRound = roundId;
            loadResults();
        };
        
        // --- ONGLET DUELS ---
        function isDuelsRound(round) {
            return (round && (round.type === 'Duels' || round.type_epreuve === 'duels'));
        }
        
        function populateDuelsRoundDropdown() {
            const select = document.getElementById('duels-round-select');
            if (!select) return;
            const current = duelDisplayRound || activeRoundId;
            select.innerHTML = '<option value="">-- S√©lectionner un tour --</option>';
            const sortedRounds = [...ROUNDS].sort((a, b) => (a.order || 0) - (b.order || 0));
            sortedRounds.forEach(round => {
                if (!isDuelsRound(round)) return;
                const option = document.createElement('option');
                option.value = round.id;
                option.textContent = round.name;
                option.selected = (round.id === current);
                select.appendChild(option);
            });
        }
        
        window.changeDuelsRound = (roundId) => {
            duelDisplayRound = roundId || null;
            loadDuelsData();
        };
        
        async function loadDuelsData() {
            const roundId = duelDisplayRound || activeRoundId;
            const emptyMsg = document.getElementById('duels-empty-msg');
            const listEl = document.getElementById('duels-list');
            const addBtn = document.getElementById('duels-add-btn');
            if (!roundId || !isDuelsRound(ROUNDS.find(r => r.id === roundId))) {
                duelsList = [];
                if (emptyMsg) emptyMsg.textContent = 'S√©lectionnez un tour de type Duels.';
                if (emptyMsg) emptyMsg.style.display = 'block';
                if (listEl) listEl.style.display = 'none';
                if (addBtn) addBtn.disabled = true;
                return;
            }
            if (duelsListener) { duelsListener(); duelsListener = null; }
            const snap = await getDoc(doc(db, "duel_results", roundId));
            duelsList = (snap.exists() && snap.data().duels) ? [...snap.data().duels] : [];
            if (addBtn) addBtn.disabled = false;
            if (duelsList.length === 0) {
                if (emptyMsg) emptyMsg.textContent = 'Aucun duel. Cliquez sur "Ajouter un duel" pour en cr√©er un.';
                if (emptyMsg) emptyMsg.style.display = 'block';
                if (listEl) listEl.style.display = 'none';
            } else {
                if (emptyMsg) emptyMsg.style.display = 'none';
                if (listEl) listEl.style.display = 'block';
                renderDuelsList();
            }
            duelsListener = onSnapshot(doc(db, "duel_results", roundId), (snap) => {
                if (snap.exists() && snap.data().duels) {
                    duelsList = [...snap.data().duels];
                    const emptyMsg2 = document.getElementById('duels-empty-msg');
                    const listEl2 = document.getElementById('duels-list');
                    if (duelsList.length === 0) {
                        if (emptyMsg2) { emptyMsg2.textContent = 'Aucun duel. Cliquez sur "Ajouter un duel" pour en cr√©er un.'; emptyMsg2.style.display = 'block'; }
                        if (listEl2) listEl2.style.display = 'none';
                    } else {
                        if (emptyMsg2) emptyMsg2.style.display = 'none';
                        if (listEl2) { listEl2.style.display = 'block'; renderDuelsList(); }
                    }
                }
            });
        }

        window.addDuel = function() {
            const roundId = duelDisplayRound || activeRoundId;
            if (!roundId) {
                customAlert('S√©lectionnez un tour de type Duels.');
                return;
            }
            duelsList.push({
                duelId: 'duel_' + Date.now(),
                candidate1Id: '',
                candidate2Id: '',
                winnerId: null
            });
            document.getElementById('duels-empty-msg').style.display = 'none';
            document.getElementById('duels-list').style.display = 'block';
            renderDuelsList();
            saveDuelsSilently();
        };

        window.removeDuel = function(duelIndex) {
            if (duelIndex < 0 || duelIndex >= duelsList.length) return;
            duelsList.splice(duelIndex, 1);
            if (duelsList.length === 0) {
                document.getElementById('duels-empty-msg').textContent = 'Aucun duel. Cliquez sur "Ajouter un duel" pour en cr√©er un.';
                document.getElementById('duels-empty-msg').style.display = 'block';
                document.getElementById('duels-list').style.display = 'none';
            } else {
                renderDuelsList();
            }
            saveDuelsSilently();
        };
        
        /** Synchronise duelBonusEnabled des classements li√©s √† ce tour : ne garde que les candidats qui sont encore gagnants d'un duel (on retire les ex-gagnants ; on n'ajoute pas les nouveaux par d√©faut).
         * @param {string} roundId - id du tour duels
         * @param {string[]} [currentWinnerIds] - si fourni, utilise cette liste ; sinon d√©duit de duelsList en m√©moire
         */
        async function syncDuelBonusEnabledWithDuelWinners(roundId, currentWinnerIds) {
            if (!roundId) return;
            try {
                const winnerIds = currentWinnerIds != null
                    ? currentWinnerIds
                    : (duelsList || []).filter(d => d.winnerId).map(d => d.winnerId);
                const classementsSnap = await getDocs(collection(db, "classements"));
                for (const docSnap of classementsSnap.docs) {
                    const data = docSnap.data();
                    if (data.code !== roundId) continue;
                    const list = Array.isArray(data.duelBonusEnabled) ? data.duelBonusEnabled : [];
                    const kept = list.filter(id => winnerIds.includes(id));
                    if (kept.length !== list.length) {
                        await setDoc(doc(db, "classements", docSnap.id), { duelBonusEnabled: kept, lastUpdateSource: 'admin_duel_sync', updatedAt: new Date() }, { merge: true });
                    }
                }
            } catch (e) {
                console.error(e);
            }
        }

        /** Sauvegarde les duels en base sans message (√† chaque modification). */
        async function saveDuelsSilently() {
            const roundId = duelDisplayRound || activeRoundId;
            if (!roundId) return;
            const sameCandidate = duelsList.filter(d => d.candidate1Id && d.candidate2Id && d.candidate1Id === d.candidate2Id);
            if (sameCandidate.length > 0) return;
            try {
                await setDoc(doc(db, "duel_results", roundId), {
                    roundId,
                    duels: duelsList,
                    updatedAt: new Date()
                });
                await syncDuelBonusEnabledWithDuelWinners(roundId);
            } catch (e) {
                console.error(e);
            }
        }

        window.updateDuelCandidates = function(duelIndex, which, value) {
            if (duelIndex < 0 || duelIndex >= duelsList.length) return;
            const d = duelsList[duelIndex];
            if (which === 1) {
                d.candidate1Id = value || '';
                if (d.candidate2Id === d.candidate1Id) d.candidate2Id = '';
                d.winnerId = null;
            }
            if (which === 2) {
                d.candidate2Id = value || '';
                if (d.candidate1Id === d.candidate2Id) d.candidate1Id = '';
                d.winnerId = null;
            }
            renderDuelsList();
            saveDuelsSilently();
        };

        window.setDuelWinner = async function(duelIndex, winnerId) {
            if (duelIndex < 0 || duelIndex >= duelsList.length) return;
            const d = duelsList[duelIndex];
            if (winnerId !== d.candidate1Id && winnerId !== d.candidate2Id) return;
            d.winnerId = winnerId;
            renderDuelsList();
            await saveDuelsSilently();
        };

        function renderDuelsList() {
            const listEl = document.getElementById('duels-list');
            if (!listEl) return;
            const roundId = duelDisplayRound || activeRoundId;
            const candidatesInRound = (roundId ? CANDIDATES.filter(c => c.tour === roundId) : []).sort((a, b) => String(a.id).localeCompare(String(b.id)));
            listEl.innerHTML = '';
            duelsList.forEach((duel, i) => {
                const c1 = CANDIDATES.find(c => c.id === duel.candidate1Id);
                const c2 = CANDIDATES.find(c => c.id === duel.candidate2Id);
                const card = document.createElement('div');
                card.style.cssText = 'display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 12px; padding: 14px; margin-bottom: 10px; border: 2px solid var(--border-color); border-radius: 8px; background: var(--input-bg);';
                const sel1 = document.createElement('select');
                sel1.style.cssText = 'padding: 6px 10px; border: 2px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-color); min-width: 140px;';
                sel1.innerHTML = '<option value="">-- Candidat 1 --</option>' + candidatesInRound.map(c => `<option value="${c.id}" ${duel.candidate1Id === c.id ? 'selected' : ''}>${(c.name || c.id).replace(/</g, '&lt;')}</option>`).join('');
                sel1.onchange = () => updateDuelCandidates(i, 1, sel1.value);
                const sel2 = document.createElement('select');
                sel2.style.cssText = 'padding: 6px 10px; border: 2px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-color); min-width: 140px;';
                const others = candidatesInRound.filter(c => c.id !== duel.candidate1Id);
                sel2.innerHTML = '<option value="">-- Candidat 2 --</option>' + others.map(c => `<option value="${c.id}" ${duel.candidate2Id === c.id ? 'selected' : ''}>${(c.name || c.id).replace(/</g, '&lt;')}</option>`).join('');
                sel2.onchange = () => updateDuelCandidates(i, 2, sel2.value);
                const left = document.createElement('span');
                left.style.display = 'flex';
                left.style.alignItems = 'center';
                left.style.gap = '10px';
                left.innerHTML = `<span style="font-weight: 600; color: var(--text-color); min-width: 50px;">Duel ${i + 1}</span>`;
                left.appendChild(sel1);
                left.appendChild(document.createTextNode(' vs '));
                left.appendChild(sel2);
                card.appendChild(left);
                const center = document.createElement('span');
                center.style.display = 'flex';
                center.style.gap = '10px';
                center.style.alignItems = 'center';
                if (duel.candidate1Id && duel.candidate2Id) {
                    center.innerHTML = '<label style="color: var(--text-color);">Gagnant :</label>';
                    const name1 = (c1 ? c1.name : duel.candidate1Id).replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    const name2 = (c2 ? c2.name : duel.candidate2Id).replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    const is1Winner = duel.winnerId === duel.candidate1Id;
                    const is2Winner = duel.winnerId === duel.candidate2Id;
                    const btn1 = document.createElement('button');
                    btn1.type = 'button';
                    btn1.textContent = c1 ? c1.name : duel.candidate1Id;
                    btn1.style.cssText = `padding: 8px 16px; border-radius: 6px; border: 2px solid var(--border-color); background: ${is1Winner ? 'var(--success-color)' : (duel.winnerId ? 'var(--danger-color)' : 'var(--input-bg)')}; color: ${is1Winner || (duel.winnerId && !is1Winner) ? 'white' : 'var(--text-color)'}; cursor: pointer; font-weight: 600;`;
                    btn1.onclick = () => setDuelWinner(i, duel.candidate1Id);
                    const btn2 = document.createElement('button');
                    btn2.type = 'button';
                    btn2.textContent = c2 ? c2.name : duel.candidate2Id;
                    btn2.style.cssText = `padding: 8px 16px; border-radius: 6px; border: 2px solid var(--border-color); background: ${is2Winner ? 'var(--success-color)' : (duel.winnerId ? 'var(--danger-color)' : 'var(--input-bg)')}; color: ${is2Winner || (duel.winnerId && !is2Winner) ? 'white' : 'var(--text-color)'}; cursor: pointer; font-weight: 600;`;
                    btn2.onclick = () => setDuelWinner(i, duel.candidate2Id);
                    center.appendChild(btn1);
                    center.appendChild(btn2);
                } else {
                    center.textContent = 'Choisissez les deux candidats';
                    center.style.color = 'var(--text-secondary)';
                }
                card.appendChild(center);
                const delBtn = document.createElement('button');
                delBtn.type = 'button';
                delBtn.textContent = 'Supprimer';
                delBtn.style.cssText = 'padding: 8px 14px; border-radius: 6px; border: 2px solid var(--danger-color); background: transparent; color: var(--danger-color); cursor: pointer; font-weight: 600;';
                delBtn.onclick = () => removeDuel(i);
                card.appendChild(delBtn);
                listEl.appendChild(card);
            });
        }
        
        /** Valider / enregistrer les duels (avec ou sans gagnant : permet de sauvegarder la liste des duels puis de renseigner les gagnants plus tard, ou de corriger un gagnant depuis l'admin). */
        window.validateDuels = async function() {
            const roundId = duelDisplayRound || activeRoundId;
            if (!roundId) {
                await customAlert('S√©lectionnez un tour.');
                return;
            }
            const incomplete = duelsList.filter(d => !d.candidate1Id || !d.candidate2Id);
            if (incomplete.length > 0) {
                await customAlert('Choisissez les deux candidats pour chaque duel. Il manque ' + incomplete.length + ' duel(s) incomplet(s).');
                return;
            }
            const sameCandidate = duelsList.filter(d => d.candidate1Id === d.candidate2Id);
            if (sameCandidate.length > 0) {
                await customAlert('Les deux candidats d\'un duel doivent √™tre diff√©rents.');
                return;
            }
            try {
                await setDoc(doc(db, "duel_results", roundId), {
                    roundId,
                    duels: duelsList,
                    updatedAt: new Date()
                });
                const withWinner = duelsList.filter(d => d.winnerId).length;
                const total = duelsList.length;
                if (withWinner === total) {
                    await customAlert('Duels valid√©s. Tous les gagnants sont enregistr√©s.');
                } else if (withWinner === 0) {
                    await customAlert('Duels valid√©s. Aucun gagnant renseign√© pour l\'instant ; vous pourrez les indiquer plus tard ou corriger depuis l\'admin.');
                } else {
                    await customAlert('Duels valid√©s. ' + withWinner + ' gagnant(s) sur ' + total + ' enregistr√©(s).');
                }
            } catch (e) {
                console.error(e);
                await customAlert('Erreur lors de la validation : ' + e.message);
            }
        };

        // --- ACTIVATION CLASSEMENTS ---
        // Le jury enregistre les positions sous les cl√©s "1" √† "5" (jury_rankings.positions).
        // Points associ√©s : 1er = 10, 2e = 8, 3e = 6, 4e = 4, 5e = 2.
        const POSITION_LABELS_JURY = ['1', '2', '3', '4', '5'];
        const POSITION_TO_POINTS = { '1': 10, '2': 8, '3': 6, '4': 4, '5': 2 };

        function isClassementRound(round) {
            return round && (round.type === 'Classement' || round.type_epreuve === 'classement');
        }

        function populateActivationClassementRoundDropdown() {
            const sel = document.getElementById('activation-classement-round');
            if (!sel) return;
            sel.innerHTML = '';
            const sorted = [...ROUNDS].sort((a, b) => (a.order || 0) - (b.order || 0));
            sorted.forEach(r => {
                const opt = document.createElement('option');
                opt.value = r.id;
                opt.textContent = r.name;
                sel.appendChild(opt);
            });
            const saved = localStorage.getItem('activation_classement_round');
            const firstRoundId = sorted.length > 0 ? sorted[0].id : '';
            const toSelect = (saved && sorted.some(r => r.id === saved)) ? saved : firstRoundId;
            if (toSelect) {
                sel.value = toSelect;
                activationClassementRoundId = toSelect;
            } else {
                activationClassementRoundId = firstRoundId || null;
            }
        }

        window.changeActivationClassementRound = function(roundId) {
            activationClassementRoundId = roundId || null;
            activationClassementId = null;
            if (roundId) localStorage.setItem('activation_classement_round', roundId);
            loadActivationClassementsData();
        };

        window.loadActivationClassementsData = async function() {
            console.log('[CLASSEMENT] loadActivationClassementsData ENTR√âE');
            activationClassementUnsubscribes.forEach(fn => { if (typeof fn === 'function') fn(); });
            activationClassementUnsubscribes = [];

            const loadingEl = document.getElementById('activation-classements-loading');
            const emptyEl = document.getElementById('activation-classements-empty');
            const containerEl = document.getElementById('activation-classements-container');
            if (loadingEl) loadingEl.style.display = 'block';
            if (emptyEl) emptyEl.style.display = 'none';
            if (containerEl) containerEl.style.display = 'none';

            const roundId = activationClassementRoundId || document.getElementById('activation-classement-round')?.value;
            if (!roundId) {
                console.log('[CLASSEMENT] loadActivationClassementsData: pas de roundId, return');
                if (loadingEl) loadingEl.style.display = 'none';
                if (emptyEl) { emptyEl.style.display = 'block'; emptyEl.textContent = ROUNDS.length === 0 ? 'Aucun tour configur√©.' : 'Chargement‚Ä¶'; }
                return;
            }
            const round = ROUNDS.find(r => r.id === roundId);
            let classementId = (round && round.classementId) ? round.classementId.trim() : null;
            if (!classementId) {
                const activationsSnap = await getDoc(doc(db, "config", "activations"));
                classementId = (activationsSnap.exists() && activationsSnap.data().classementIdActif) ? activationsSnap.data().classementIdActif.trim() : 'classement';
            }
            console.log('[CLASSEMENT] loadActivationClassementsData: roundId=', roundId, 'classementId=', classementId);

            try {
                await loadJuries();
                const juriesOnRound = JURIES.filter(j => j.rounds && j.rounds.includes(roundId));
                let classementSnap = await getDoc(doc(db, "classements", classementId));
                let entries = classementSnap.exists() ? (classementSnap.data().entries || []) : [];
                const entriesWithBonus = entries.filter(e => {
                    const base = e.score_base != null ? (typeof e.score_base === 'number' ? e.score_base : parseFloat(e.score_base) || 0) : 0;
                    const applied = e.score_appliqu√© != null ? (typeof e.score_appliqu√© === 'number' ? e.score_appliqu√© : parseFloat(e.score_appliqu√©) || 0) : 0;
                    return applied > base;
                });
                console.log('[CLASSEMENT] loadActivationClassementsData: entries lues=', entries.length, 'dont avec bonus (appliqu√©>base)=', entriesWithBonus.length, entriesWithBonus.map(e => `${e.candidateId}:${e.score_base}‚Üí${e.score_appliqu√©}`).join(', '));
                if (entries.length === 0 && roundId) {
                    try {
                        const scoresQuery = query(collection(db, "scores"), where("roundId", "==", roundId));
                        const scoresSnap = await getDocs(scoresQuery);
                        const totalBaseByCandidate = {};
                        scoresSnap.forEach(d => {
                            const sd = d.data();
                            const cid = sd.candidateId;
                            totalBaseByCandidate[cid] = (totalBaseByCandidate[cid] || 0) + (sd.score_base != null ? sd.score_base : 0);
                        });
                        const candidatesSnap = await getDoc(doc(db, "candidats", "liste_actuelle"));
                        const allCandidates = candidatesSnap.exists() ? (candidatesSnap.data().candidates || []) : [];
                        let roundCandidates = allCandidates.filter(c => (c.tour || '') === roundId);
                        if (roundCandidates.length === 0) roundCandidates = allCandidates;
                        const withScore = roundCandidates.map(c => ({ candidateId: c.id, name: c.name, score_base: totalBaseByCandidate[c.id] || 0 }));
                        withScore.sort((a, b) => b.score_base - a.score_base);
                        const activationsRepopSnap = await getDoc(doc(db, "classement_activations", classementId));
                        const pointsByCandidate = {};
                        (activationsRepopSnap.exists() ? (activationsRepopSnap.data().activated || []) : []).forEach(a => {
                            if (a.candidateId && (a.points != null || a.points === 0)) {
                                pointsByCandidate[a.candidateId] = (pointsByCandidate[a.candidateId] || 0) + (typeof a.points === 'number' ? a.points : parseFloat(a.points) || 0);
                            }
                        });
                        entries = withScore.map((x, i) => {
                            const base = x.score_base != null ? (typeof x.score_base === 'number' ? x.score_base : parseFloat(x.score_base) || 0) : 0;
                            const points = pointsByCandidate[x.candidateId] != null ? pointsByCandidate[x.candidateId] : 0;
                            const total = Math.round((base + points) * 100) / 100;
                            return { rank: i + 1, candidateId: x.candidateId, name: x.name, score_base: x.score_base, score_appliqu√©: total, score_affich√©: total };
                        });
                        entries.sort((a, b) => (b.score_appliqu√© ?? 0) - (a.score_appliqu√© ?? 0));
                        entries.forEach((e, i) => { e.rank = i + 1; });
                        if (entries.length > 0) {
                            const data = classementSnap.exists() ? classementSnap.data() : {};
                            const repopDuelBonusEnabled = Array.isArray(data.duelBonusEnabled) ? data.duelBonusEnabled : [];
                            await setDoc(doc(db, "classements", classementId), { ...data, code: roundId, entries, duelBonusEnabled: repopDuelBonusEnabled, lastUpdateSource: 'admin_activation_tab_repopulate', updatedAt: new Date() }, { merge: true });
                            classementSnap = await getDoc(doc(db, "classements", classementId));
                            entries = classementSnap.exists() ? (classementSnap.data().entries || []) : [];
                        }
                    } catch (repopErr) {
                        console.warn('Repopulation classement vide:', repopErr);
                    }
                }
                const activationsSnap = await getDoc(doc(db, "classement_activations", classementId));
                const activatedList = activationsSnap.exists() ? (activationsSnap.data().activated || []) : [];
                console.log('[CLASSEMENT] loadActivationClassementsData: activations lues=', activatedList.length, activatedList.map(a => `${a.candidateId}+${a.points}`).join(', '));
                const entriesWithBonusNow = entries.filter(e => {
                    const base = e.score_base != null ? (typeof e.score_base === 'number' ? e.score_base : parseFloat(e.score_base) || 0) : 0;
                    const applied = e.score_appliqu√© != null ? (typeof e.score_appliqu√© === 'number' ? e.score_appliqu√© : parseFloat(e.score_appliqu√©) || 0) : 0;
                    return applied > base;
                });
                if (activatedList.length > 0 && entriesWithBonusNow.length === 0 && entries.length > 0) {
                    console.warn('[CLASSEMENT] ‚ö†Ô∏è INCOH√âRENCE: il y a', activatedList.length, 'activation(s) mais aucune entry n\'a score_appliqu√© > score_base. Le document classement a √©t√© √©cras√© sans les points.');
                }
                const activatedSet = new Set();
                if (activationsSnap.exists() && activationsSnap.data().activated) {
                    activationsSnap.data().activated.forEach(a => {
                        activatedSet.add(a.juryId + '_' + a.candidateId);
                    });
                }
                const juryRankingsByJury = {};
                for (const j of juriesOnRound) {
                    const docId = j.id + '_' + roundId;
                    const snap = await getDoc(doc(db, "jury_rankings", docId));
                    juryRankingsByJury[j.id] = snap.exists() ? (snap.data().positions || {}) : {};
                }

                function pointsForCandidateAtPosition(positions, candidateId) {
                    for (const posLabel of POSITION_LABELS_JURY) {
                        if (positions[posLabel] === candidateId) return POSITION_TO_POINTS[posLabel] || 0;
                    }
                    return 0;
                }

                const grid = [];
                entries.forEach(entry => {
                    const row = { candidateId: entry.candidateId, name: entry.name || entry.candidateId };
                    row.cells = {};
                    juriesOnRound.forEach(j => {
                        const pos = juryRankingsByJury[j.id] || {};
                        const points = pointsForCandidateAtPosition(pos, entry.candidateId);
                        row.cells[j.id] = {
                            points,
                            juryId: j.id,
                            juryName: j.name,
                            activated: activatedSet.has(j.id + '_' + entry.candidateId)
                        };
                    });
                    grid.push(row);
                });

                const duelWinnerIds = await getDuelWinnerIds(roundId);
                const classementData = classementSnap.exists() ? classementSnap.data() : {};
                const duelBonusEnabled = Array.isArray(classementData.duelBonusEnabled) ? classementData.duelBonusEnabled : [];

                if (loadingEl) loadingEl.style.display = 'none';
                if (emptyEl) emptyEl.style.display = 'none';
                if (containerEl) containerEl.style.display = 'block';
                renderActivationClassementsGrid(grid, juriesOnRound, classementId, roundId, activationsSnap.exists() ? activationsSnap.data().activated : [], duelWinnerIds, duelBonusEnabled);

                let firstJury = true, firstClassement = true, firstActivations = true, firstDuels = true;
                const qJuryRankings = query(collection(db, "jury_rankings"), where("roundId", "==", roundId));
                activationClassementUnsubscribes.push(onSnapshot(qJuryRankings, () => {
                    if (firstJury) { firstJury = false; return; }
                    loadActivationClassementsData();
                }));
                activationClassementUnsubscribes.push(onSnapshot(doc(db, "classements", classementId), () => {
                    if (firstClassement) { firstClassement = false; return; }
                    loadActivationClassementsData();
                }));
                activationClassementUnsubscribes.push(onSnapshot(doc(db, "classement_activations", classementId), () => {
                    if (firstActivations) { firstActivations = false; return; }
                    loadActivationClassementsData();
                }));
                activationClassementUnsubscribes.push(onSnapshot(doc(db, "duel_results", roundId), () => {
                    if (firstDuels) { firstDuels = false; return; }
                    loadActivationClassementsData();
                }));
            } catch (e) {
                console.error(e);
                if (loadingEl) loadingEl.style.display = 'none';
                if (emptyEl) { emptyEl.style.display = 'block'; emptyEl.textContent = 'Erreur : ' + (e.message || e); }
            }
        };

        function renderActivationClassementsGrid(grid, juriesOnRound, classementId, roundId, activatedList, duelWinnerIds, duelBonusEnabled) {
            duelWinnerIds = duelWinnerIds || [];
            duelBonusEnabled = duelBonusEnabled || [];
            const thead = document.getElementById('activation-classements-thead');
            const tbody = document.getElementById('activation-classements-tbody');
            if (!thead || !tbody) return;
            thead.innerHTML = '';
            tbody.innerHTML = '';
            const thCand = document.createElement('th');
            thCand.textContent = 'Candidat';
            thCand.style.padding = '10px';
            thCand.style.textAlign = 'left';
            thead.appendChild(thCand);
            juriesOnRound.forEach(j => {
                const th = document.createElement('th');
                th.textContent = j.name || j.id;
                th.style.padding = '10px';
                th.style.textAlign = 'center';
                th.style.minWidth = '100px';
                thead.appendChild(th);
            });

            grid.forEach(row => {
                const tr = tbody.insertRow();
                const tdCand = tr.insertCell();
                tdCand.style.padding = '10px';
                const nameText = document.createTextNode((row.name || row.candidateId) + ' (' + row.candidateId + ') ');
                tdCand.appendChild(nameText);
                const isDuelWinner = duelWinnerIds.includes(row.candidateId);
                const bonusEnabled = duelBonusEnabled.includes(row.candidateId);
                if (isDuelWinner) {
                    const duelBtn = document.createElement('button');
                    duelBtn.type = 'button';
                    duelBtn.title = bonusEnabled ? 'D√©sactiver les +10% gagnant duel dans le classement' : 'Activer les +10% gagnant duel dans le classement';
                    duelBtn.textContent = 'üèÜ';
                    duelBtn.style.cssText = 'margin-left: 4px; padding: 2px 6px; font-size: 1.1em; border-radius: 6px; border: 2px solid var(--border-color); cursor: pointer; background: ' + (bonusEnabled ? 'linear-gradient(135deg, #ffc107 0%, #e0a800 100%)' : 'var(--light-bg, #e9ecef)') + '; color: ' + (bonusEnabled ? '#1a1a1a' : 'var(--text-secondary)') + ';';
                    duelBtn.onclick = () => toggleDuelBonus(classementId, row.candidateId);
                    tdCand.appendChild(duelBtn);
                }
                juriesOnRound.forEach(j => {
                    const cell = row.cells[j.id];
                    const td = tr.insertCell();
                    td.style.padding = '8px';
                    td.style.textAlign = 'center';
                    if (!cell || cell.points === 0) {
                        td.textContent = '‚Äî';
                        td.style.background = 'var(--light-bg, #f5f5f5)';
                        td.style.color = 'var(--text-secondary)';
                    } else {
                        td.innerHTML = '';
                        const btn = document.createElement('button');
                        btn.type = 'button';
                        btn.className = 'action-button';
                        btn.style.padding = '6px 12px';
                        btn.style.fontSize = '0.9em';
                        if (cell.activated) {
                            btn.textContent = '‚úì ' + cell.points + ' (d√©sactiver)';
                            btn.style.background = 'linear-gradient(135deg, #28a745 0%, #1e7e34 100%)';
                            btn.style.color = 'white';
                            btn.style.cursor = 'pointer';
                            btn.onclick = () => deactivateClassementJury(classementId, roundId, j.id, row.candidateId, cell.points);
                        } else {
                            btn.textContent = '+ ' + cell.points;
                            btn.style.background = 'linear-gradient(135deg, #28a745 0%, #1e7e34 100%)';
                            btn.style.color = 'white';
                            btn.onclick = () => activateClassementJury(classementId, roundId, j.id, row.candidateId, cell.points);
                        }
                        td.appendChild(btn);
                    }
                });
            });
        }

        /** Retourne la liste des IDs candidats gagnants d'un duel pour le tour donn√©. */
        async function getDuelWinnerIds(roundId) {
            if (!roundId) return [];
            const snap = await getDoc(doc(db, "duel_results", roundId));
            if (!snap.exists() || !snap.data().duels) return [];
            return (snap.data().duels).filter(d => d.winnerId).map(d => d.winnerId);
        }

        /** Recalcule score_appliqu√© et score_affich√© de chaque entr√©e = score_base + somme des points de classement activ√©s (jamais de +10% stock√©). */
        async function recalculateClassementScoresFromBase(classementId) {
            console.log('[CLASSEMENT] recalculateClassementScoresFromBase ENTR√âE classementId=', classementId);
            const snap = await getDoc(doc(db, "classements", classementId));
            if (!snap.exists()) {
                console.log('[CLASSEMENT] recalculateClassementScoresFromBase: doc classement inexistant, return');
                return;
            }
            const data = snap.data();
            const entries = [...(data.entries || [])];
            const activationsSnap = await getDoc(doc(db, "classement_activations", classementId));
            const activated = activationsSnap.exists() ? (activationsSnap.data().activated || []) : [];
            console.log('[CLASSEMENT] recalculateClassementScoresFromBase: activations=', activated.length, activated.map(a => `${a.candidateId}+${a.points}`).join(', '));
            const pointsByCandidate = {};
            activated.forEach(a => {
                if (a.candidateId && (a.points != null || a.points === 0)) {
                    pointsByCandidate[a.candidateId] = (pointsByCandidate[a.candidateId] || 0) + (typeof a.points === 'number' ? a.points : parseFloat(a.points) || 0);
                }
            });
            entries.forEach(e => {
                const base = e.score_base != null ? (typeof e.score_base === 'number' ? e.score_base : parseFloat(e.score_base) || 0) : 0;
                const points = pointsByCandidate[e.candidateId] != null ? pointsByCandidate[e.candidateId] : 0;
                const total = Math.round((base + points) * 100) / 100;
                e.score_appliqu√© = total;
                e.score_affich√© = total;
            });
            entries.sort((a, b) => (b.score_appliqu√© ?? 0) - (a.score_appliqu√© ?? 0));
            entries.forEach((e, i) => { e.rank = i + 1; });
            console.log('[CLASSEMENT] recalculateClassementScoresFromBase: √âCRITURE entries=', entries.length, 'source=admin_recalculate_scores');
            await setDoc(doc(db, "classements", classementId), { entries, lastUpdateSource: 'admin_recalculate_scores', updatedAt: new Date() }, { merge: true });
        }

        /** Active ou d√©sactive les +10% gagnant duel pour un candidat dans le classement (stock√© dans le doc classement : duelBonusEnabled). Recalcule toutes les notes √† partir de la base pour √©viter d'avoir stock√© du +10%. */
        window.toggleDuelBonus = async function(classementId, candidateId) {
            try {
                const snap = await getDoc(doc(db, "classements", classementId));
                if (!snap.exists()) {
                    await customAlert('Classement introuvable.');
                    return;
                }
                const data = snap.data();
                const list = Array.isArray(data.duelBonusEnabled) ? [...data.duelBonusEnabled] : [];
                const idx = list.indexOf(candidateId);
                if (idx >= 0) list.splice(idx, 1);
                else list.push(candidateId);
                await setDoc(doc(db, "classements", classementId), { ...data, duelBonusEnabled: list, lastUpdateSource: 'admin_duel_bonus_toggle', updatedAt: new Date() }, { merge: true });
                await recalculateClassementScoresFromBase(classementId);
                await loadActivationClassementsData();
            } catch (e) {
                console.error(e);
                await customAlert('Erreur : ' + (e.message || e));
            }
        };

        window.activateClassementJury = async function(classementId, roundId, juryId, candidateId, points) {
            try {
                console.log('[CLASSEMENT] activateClassementJury:', classementId, candidateId, '+', points);
                const activationsCheckSnap = await getDoc(doc(db, "classement_activations", classementId));
                const alreadyActivated = activationsCheckSnap.exists() && (activationsCheckSnap.data().activated || []).some(a => a.juryId === juryId && a.candidateId === candidateId);
                if (alreadyActivated) {
                    await customAlert('Cette activation a d√©j√† √©t√© effectu√©e. Pas de double activation possible.');
                    await loadActivationClassementsData();
                    return;
                }
                const snap = await getDoc(doc(db, "classements", classementId));
                if (!snap.exists()) {
                    await customAlert('Classement introuvable.');
                    return;
                }
                const entry = (snap.data().entries || []).find(e => e.candidateId === candidateId);
                if (!entry) {
                    await customAlert('Candidat non trouv√© dans le classement.');
                    return;
                }
                const activationsSnap = await getDoc(doc(db, "classement_activations", classementId));
                const activated = activationsSnap.exists() ? [...(activationsSnap.data().activated || [])] : [];
                activated.push({ juryId, candidateId, points, activatedAt: new Date() });
                await setDoc(doc(db, "classement_activations", classementId), { activated, updatedAt: new Date() });
                console.log('[CLASSEMENT] activateClassementJury: activations √©crites, appel recalculateClassementScoresFromBase');
                await recalculateClassementScoresFromBase(classementId);
                const afterSnap = await getDoc(doc(db, "classements", classementId));
                const newScore = (afterSnap.data().entries || []).find(e => e.candidateId === candidateId)?.score_affich√©;
                await addDoc(collection(db, "activation_logs"), {
                    type: 'classement_jury',
                    candidat_id: candidateId,
                    source: juryId,
                    timestamp: new Date(),
                    payload: { classementId, points, newScore }
                });
                await loadActivationClassementsData();
            } catch (e) {
                console.error(e);
                await customAlert('Erreur lors de l\'activation : ' + (e.message || e));
            }
        };

        window.deactivateClassementJury = async function(classementId, roundId, juryId, candidateId, points) {
            try {
                const activationsSnap = await getDoc(doc(db, "classement_activations", classementId));
                if (!activationsSnap.exists()) {
                    await customAlert('Aucune activation trouv√©e.');
                    await loadActivationClassementsData();
                    return;
                }
                const activatedList = activationsSnap.data().activated || [];
                const activated = activatedList.filter(a => !(a.juryId === juryId && a.candidateId === candidateId));
                if (activated.length === activatedList.length) {
                    await customAlert('Cette activation n\'est pas enregistr√©e.');
                    await loadActivationClassementsData();
                    return;
                }
                const snap = await getDoc(doc(db, "classements", classementId));
                if (!snap.exists()) {
                    await customAlert('Classement introuvable.');
                    return;
                }
                await setDoc(doc(db, "classement_activations", classementId), { activated, updatedAt: new Date() });
                await recalculateClassementScoresFromBase(classementId);
                await addDoc(collection(db, "activation_logs"), {
                    type: 'classement_jury_desactivated',
                    candidat_id: candidateId,
                    source: juryId,
                    timestamp: new Date(),
                    payload: { classementId, points }
                });
                await loadActivationClassementsData();
            } catch (e) {
                console.error(e);
                await customAlert('Erreur lors de la d√©sactivation : ' + (e.message || e));
            }
        };

        function createTourDropdown(candidate) {
            const selId = 'notes-tour-' + candidate.id;
            let html = `<select id="${selId}" name="${selId}" onchange="updateCandidateTour('${candidate.id}', this.value)" style="width: 100%; min-width: 180px; padding: 6px 8px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px; font-size: 13px;">`;
            ROUNDS.forEach(round => {
                const selected = round.id === candidate.tour ? 'selected' : '';
                html += `<option value="${round.id}" ${selected}>${round.name}</option>`;
            });
            html += '</select>';
            return html;
        }
        
        function createStatusDropdown(candidate) {
            const statuses = ['Actif', 'Reset', 'Elimine', 'Qualifie'];
            const selId = 'notes-status-' + candidate.id;
            let html = `<select id="${selId}" name="${selId}" onchange="updateCandidateStatus('${candidate.id}', this.value)" style="width: 100%; min-width: 130px; padding: 6px 8px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px; font-size: 13px;">`;
            statuses.forEach(status => {
                const selected = status === candidate.status ? 'selected' : '';
                html += `<option value="${status}" ${selected}>${status}</option>`;
            });
            html += '</select>';
            return html;
        }
        
        window.updateCandidateTour = async (candidateId, newTour) => {
            const candidate = CANDIDATES.find(c => c.id === candidateId);
            if (candidate) {
                candidate.tour = newTour;
                await saveCandidates();
                renderNotesTable();
            }
        };
        
        window.updateCandidateStatus = async (candidateId, newStatus) => {
            // Sauvegarder la position de scroll
            const tableContainer = document.querySelector('#tab-notes .table-container');
            const scrollTop = tableContainer ? tableContainer.scrollTop : 0;
            const scrollLeft = tableContainer ? tableContainer.scrollLeft : 0;
            
            const candidate = CANDIDATES.find(c => c.id === candidateId);
            if (!candidate) return;
            
            const oldStatus = candidate.status;
            candidate.status = newStatus;
            
            // Si on passe √† "Reset", r√©initialiser les notes et revenir √† "Actif"
            if (newStatus === 'Reset') {
                await resetCandidateScores(candidateId);
                candidate.status = 'Actif';
            }
            
            await saveCandidates();
            await renderNotesTable();
            await loadResults();
            
            // Restaurer la position de scroll apr√®s que le DOM soit mis √† jour
            // Utiliser setTimeout pour s'assurer que le navigateur a rendu les changements
            setTimeout(() => {
                const container = document.querySelector('#tab-notes .table-container');
                if (container) {
                    container.scrollTop = scrollTop;
                    container.scrollLeft = scrollLeft;
                }
            }, 0);
        };
        
        // Fonction pour v√©rifier si un candidat a toutes ses notes d√©finies 
        // et qualifier/√©liminer en fonction du classement et de la limite nextRoundCandidates
        async function checkAndQualifyCandidate(candidateId) {
            const candidate = CANDIDATES.find(c => c.id === candidateId);
            if (!candidate || candidate.status !== 'Actif') return;
            
            // R√©cup√©rer le tour actif pour conna√Ætre la limite de candidats
            const activeRound = ROUNDS.find(r => r.id === activeRoundId);
            if (!activeRound) return;
            
            // Charger les jurys pr√©sents sur ce tour
            await loadJuries();
            const juriesOnRound = JURIES.filter(j => j.rounds && j.rounds.includes(activeRoundId));
            if (juriesOnRound.length === 0) {
                console.log(`‚ö†Ô∏è Aucun jury pr√©sent sur le tour ${activeRoundId}`);
                return;
            }
            
            // R√©cup√©rer tous les candidats du tour actif qui sont "Actif"
            const candidatesInRound = CANDIDATES.filter(c => c.tour === activeRoundId && c.status === 'Actif');
            if (candidatesInRound.length === 0) {
                console.log(`‚ö†Ô∏è Aucun candidat actif sur le tour ${activeRoundId}`);
                return;
            }
            
            console.log(`üîç checkAndQualifyCandidate: ${candidatesInRound.length} candidats actifs, ${juriesOnRound.length} jurys pr√©sents`);
            
            // Charger tous les scores du tour actif
            const scoresQuery = query(
                collection(db, "scores"),
                where("roundId", "==", activeRoundId || 'round1')
            );
            const scoresSnap = await getDocs(scoresQuery);
            
            console.log(`üîç Scores trouv√©s pour ce tour: ${scoresSnap.size}`);
            
            // Organiser les scores par candidat et jury
            const scoresByCandidate = {};
            scoresSnap.forEach(docSnap => {
                const data = docSnap.data();
                if (!scoresByCandidate[data.candidateId]) {
                    scoresByCandidate[data.candidateId] = {};
                }
                const juryId = data.juryId || data.juryName;
                scoresByCandidate[data.candidateId][juryId] = {
                    score1: data.score1,
                    score2: data.score2
                };
            });
            
            // V√©rifier si TOUS les candidats ont toutes leurs notes compl√®tes
            let allCandidatesComplete = true;
            const candidateScores = [];
            
            for (const c of candidatesInRound) {
                const candidateScoreData = scoresByCandidate[c.id] || {};
                let isComplete = true;
                let totalScore = 0;
                
                for (const jury of juriesOnRound) {
                    const scores = candidateScoreData[jury.id];
                    if (!scores || 
                        !scores.score1 || scores.score1 === '-' ||
                        !scores.score2 || scores.score2 === '-') {
                        isComplete = false;
                        allCandidatesComplete = false;
                        console.log(`  ‚ùå ${c.name}: notes manquantes pour jury ${jury.name} (${jury.id})`);
                        break;
                    }
                    
                    // Calculer le score (EL = 0)
                    if (scores.score1 === 'EL' || scores.score2 === 'EL') {
                        totalScore += 0;
                    } else {
                        const s1 = parseFloat(scores.score1) || 0;
                        const s2 = parseFloat(scores.score2) || 0;
                        totalScore += (s1 * 3 + s2);
                    }
                }
                
                if (isComplete) {
                    candidateScores.push({
                        id: c.id,
                        name: c.name,
                        totalScore: totalScore
                    });
                    console.log(`  ‚úì ${c.name}: complet (${totalScore} pts)`);
                }
            }
            
            // Si tous les candidats ne sont pas encore complets, on attend
            if (!allCandidatesComplete) {
                console.log(`‚è≥ En attente : ${candidatesInRound.length - candidateScores.length}/${candidatesInRound.length} candidat(s) n'ont pas encore toutes leurs notes`);
                return;
            }
            
            console.log(`‚úÖ Tous les candidats ont leurs notes compl√®tes. Calcul du classement...`);
            
            // Trier par score d√©croissant
            candidateScores.sort((a, b) => b.totalScore - a.totalScore);
            
            // D√©terminer le nombre de candidats √† qualifier
            let qualifyCount;
            if (activeRound.nextRoundCandidates === 'ALL') {
                qualifyCount = candidateScores.length; // Tous qualifi√©s
            } else {
                qualifyCount = parseInt(activeRound.nextRoundCandidates) || candidateScores.length;
            }
            
            console.log(`üìä ${candidateScores.length} candidats, ${qualifyCount} seront qualifi√©s (nextRoundCandidates=${activeRound.nextRoundCandidates})`);
            
            // Qualifier les N premiers, √©liminer les autres
            let qualifiedCount = 0;
            let eliminatedCount = 0;
            
            candidateScores.forEach((scoreData, index) => {
                const c = CANDIDATES.find(cand => cand.id === scoreData.id);
                if (c) {
                    if (index < qualifyCount) {
                        c.status = 'Qualifie';
                        qualifiedCount++;
                        console.log(`  ‚úì ${c.name}: ${scoreData.totalScore} pts ‚Üí Qualifi√© (rang ${index + 1})`);
                    } else {
                        c.status = 'Elimine';
                        eliminatedCount++;
                        console.log(`  ‚úó ${c.name}: ${scoreData.totalScore} pts ‚Üí √âlimin√© (rang ${index + 1})`);
                    }
                }
            });
            
            await saveCandidates();
            console.log(`‚úÖ Qualification termin√©e: ${qualifiedCount} qualifi√©(s), ${eliminatedCount} √©limin√©(s)`);
        }

        function createScoreDropdown(scoreId, field, currentValue, candidateId, juryId, readonly = false) {
            const displayRound = notesDisplayRound || activeRoundId || 'round1';
            const round = ROUNDS.find(r => r.id === displayRound);
            const isDuels = round && (round.type === 'Duels' || round.type_epreuve === 'duels');
            const options = isDuels
                ? ['-'].concat(Array.from({ length: 21 }, (_, i) => String(i)))
                : ['-', '5', '10', '15', '20', 'EL'];
            const selectId = `score-${candidateId}-${juryId}-${field}`;
            const disabledAttr = readonly ? 'disabled' : '';
            const currentStr = currentValue === undefined || currentValue === null ? '-' : String(currentValue);

            let html = `<select id="${selectId}" onchange="handleScoreChange('${scoreId}', '${field}', this.value, '${candidateId}', '${juryId}')" ${disabledAttr} style="text-align: center;">`;
            options.forEach(opt => {
                const selected = opt === currentStr ? 'selected' : '';
                html += `<option value="${opt}" ${selected}>${opt}</option>`;
            });
            html += '</select>';
            return html;
        }
        
        function createRepechageScoreDropdown(scoreId, currentValue, candidateId, juryId, readonly = false) {
            const options = ['-', '0', '1'];
            const selectId = `score-${candidateId}-${juryId}-repechage`;
            const disabledAttr = readonly ? 'disabled' : '';
            
            let html = `<select id="${selectId}" onchange="handleRepechageScoreChange('${scoreId}', this.value, '${candidateId}', '${juryId}')" ${disabledAttr} style="text-align: center;">`;
            options.forEach(opt => {
                const selected = opt === String(currentValue) ? 'selected' : '';
                html += `<option value="${opt}" ${selected}>${opt}</option>`;
            });
            html += '</select>';
            return html;
        }
        
        window.handleRepechageScoreChange = async function(scoreId, value, candidateId, juryId) {
            const displayRound = notesDisplayRound || activeRoundId || 'round1';
            const validatedSnap = await getDoc(doc(db, "config", "validated_rounds"));
            const vr = validatedSnap.exists() ? (validatedSnap.data().rounds || {}) : {};
            if (vr[displayRound]) {
                await customAlert('Ce tour est valid√©. Les notes ne sont plus modifiables.');
                return;
            }
            const tableContainer = document.querySelector('#tab-notes .table-container');
            const scrollTop = tableContainer ? tableContainer.scrollTop : 0;
            const scrollLeft = tableContainer ? tableContainer.scrollLeft : 0;
            if (value === '-') {
                // Supprimer le score s'il existe
                if (scoreId && scoreId !== 'null') {
                    await deleteDoc(doc(db, "scores", scoreId));
                }
            } else {
                // Pour le rep√™chage, score1 et score2 sont identiques
                const jury = JURIES.find(j => j.id === juryId);
                const juryName = jury ? jury.name : juryId;
                
                if (scoreId && scoreId !== 'null') {
                    // Mettre √† jour le score existant
                    await setDoc(doc(db, "scores", scoreId), {
                        score1: value,
                        score2: value,
                        timestamp: new Date()
                    }, { merge: true });
                } else {
                    // Cr√©er un nouveau score
                    await addDoc(collection(db, "scores"), {
                        candidateId: candidateId,
                        juryId: juryId,
                        juryName: juryName,
                        roundId: notesDisplayRound || activeRoundId,
                        score1: value,
                        score2: value,
                        timestamp: new Date()
                    });
                }
            }
            
            // Restaurer la position de scroll apr√®s le rechargement
            setTimeout(() => {
                if (tableContainer) {
                    tableContainer.scrollTop = scrollTop;
                    tableContainer.scrollLeft = scrollLeft;
                }
            }, 50);
        };

        window.handleScoreChange = async function(scoreId, field, value, candidateId, juryId) {
            const displayRound = notesDisplayRound || activeRoundId || 'round1';
            console.log('[CLASSEMENT] handleScoreChange: note modifi√©e, displayRound=', displayRound, '‚Üí updateClassementFromScoresForRound sera appel√©');
            const validatedSnap = await getDoc(doc(db, "config", "validated_rounds"));
            const vr = validatedSnap.exists() ? (validatedSnap.data().rounds || {}) : {};
            if (vr[displayRound]) {
                await customAlert('Ce tour est valid√©. Les notes Fond/Forme ne sont plus modifiables.');
                return;
            }
            isManualChange = true;
            const tableContainer = document.querySelector('#tab-notes .table-container');
            const scrollTop = tableContainer ? tableContainer.scrollTop : 0;
            const scrollLeft = tableContainer ? tableContainer.scrollLeft : 0;
            try {
                if (value === '-') {
                    // Supprimer le score s'il existe
                    if (scoreId && scoreId !== 'null') {
                        await deleteDoc(doc(db, "scores", scoreId));
                    }
                } else {
                    // Cr√©er ou mettre √† jour le score (avec le tour affich√© dans l'onglet Notes pour √©viter roundId incorrect)
                    if (scoreId && scoreId !== 'null') {
                        await updateScore(scoreId, field, value);
                    } else {
                        await createScore(candidateId, juryId, field, value, displayRound);
                    }
                }
                
                await updateClassementFromScoresForRound(displayRound);
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Rafra√Æchir les deux onglets
                await renderNotesTable();
                await loadResults();
                
                // Restaurer la position de scroll apr√®s que le DOM soit mis √† jour
                setTimeout(() => {
                    const container = document.querySelector('#tab-notes .table-container');
                    if (container) {
                        container.scrollTop = scrollTop;
                        container.scrollLeft = scrollLeft;
                    }
                }, 0);
            } finally {
                // D√©sactiver le flag apr√®s un d√©lai suffisant pour que tous les listeners l'ignorent
                // (inclut le temps de propagation Firebase + debounce des listeners)
                setTimeout(() => {
                    isManualChange = false;
                }, 800);
            }
        };

        async function createScore(candidateId, juryNameOrId, field, value, roundIdForScore) {
            const roundId = roundIdForScore || notesDisplayRound || activeRoundId || 'round1';
            // juryNameOrId est maintenant le juryId dans le nouveau syst√®me ou le nom dans l'ancien
            // On essaie d'abord par juryId, sinon par juryName (compatibilit√©)
            let q = query(collection(db, "scores"), 
                where("candidateId", "==", candidateId),
                where("juryId", "==", juryNameOrId),
                where("roundId", "==", roundId));
            let snap = await getDocs(q);
            
            // Si pas trouv√© par juryId, essayer par juryName (ancien syst√®me)
            if (snap.empty) {
                q = query(collection(db, "scores"), 
                    where("candidateId", "==", candidateId),
                    where("juryName", "==", juryNameOrId),
                    where("roundId", "==", roundId));
                snap = await getDocs(q);
            }
            
            if (snap.empty) {
                // Cr√©er nouveau score - d√©terminer si on a un juryId ou juryName
                let juryId, juryName;
                if (juryNameOrId.startsWith('jury')) {
                    // C'est un ID num√©rique
                    juryId = juryNameOrId;
                    const juryDoc = await getDoc(doc(db, "accounts", juryId));
                    juryName = juryDoc.exists() ? (juryDoc.data().name || juryId) : juryId;
                } else {
                    // C'est un ancien nom - chercher l'ID
                    const accountsSnap = await getDocs(collection(db, "accounts"));
                    accountsSnap.forEach(d => {
                        if ((d.data().name || d.id) === juryNameOrId) {
                            juryId = d.id;
                            juryName = juryNameOrId;
                        }
                    });
                    // Si pas trouv√©, utiliser le nom comme ID (compatibilit√©)
                    if (!juryId) {
                        juryId = juryNameOrId;
                        juryName = juryNameOrId;
                    }
                }
                
                const score1 = field === 'score1' ? value : '-';
                const score2 = field === 'score2' ? value : '-';
                const data = {
                    candidateId: candidateId,
                    juryId: juryId,
                    juryName: juryName,
                    roundId: roundId,
                    score1,
                    score2,
                    score_base: computeScoreBase(score1, score2, roundId),
                    timestamp: new Date()
                };
                
                await addDoc(collection(db, "scores"), data);
            } else {
                // Si des doublons existent, les nettoyer
                if (snap.docs.length > 1) {
                    console.warn(`‚ö†Ô∏è ${snap.docs.length} doublons trouv√©s pour ${candidateId}/${juryName}, nettoyage...`);
                    // Garder le plus r√©cent, supprimer les autres
                    const sorted = snap.docs.sort((a, b) => {
                        const timeA = a.data().timestamp?.toDate?.() || new Date(0);
                        const timeB = b.data().timestamp?.toDate?.() || new Date(0);
                        return timeB - timeA;
                    });
                    
                    // Supprimer tous sauf le premier (le plus r√©cent)
                    for (let i = 1; i < sorted.length; i++) {
                        await deleteDoc(doc(db, "scores", sorted[i].id));
                    }
                }
                
                // Mettre √† jour le score existant (ou le seul restant apr√®s nettoyage)
                const scoreDoc = snap.docs[0];
                await updateScore(scoreDoc.id, field, value);
            }
        }

        window.updateScore = async (scoreId, field, value) => {
            try {
                const scoreRef = doc(db, "scores", scoreId);
                const scoreSnap = await getDoc(scoreRef);
                
                if (!scoreSnap.exists()) return;
                
                const data = scoreSnap.data();
                data[field] = value;
                
                delete data.totalWeightedScore;
                data.score_base = computeScoreBase(data.score1, data.score2, data.roundId);
                
                await setDoc(scoreRef, data);
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la mise √† jour: ' + e.message);
            }
        };

        async function resetCandidateScores(candidateId) {
            // Supprimer toutes les notes de ce candidat pour le tour actif
            const scoresQuery = query(
                collection(db, "scores"), 
                where("candidateId", "==", candidateId),
                where("roundId", "==", activeRoundId || 'round1')
            );
            const scoresSnap = await getDocs(scoresQuery);
            
            for (const scoreDoc of scoresSnap.docs) {
                await deleteDoc(doc(db, "scores", scoreDoc.id));
            }
            
            // D√©verrouiller automatiquement ce candidat apr√®s r√©initialisation (compatibilit√©)
            if (candidateLocks[candidateId]) {
                delete candidateLocks[candidateId];
                await setDoc(doc(db, "config", "locks"), { locks: candidateLocks });
            }
        }

        /** Validation globale : v√©rifie que tous les candidats du tour ont Fond+Forme pour tous les jurys, puis verrouillage d√©finitif. */
        window.validateRoundGlobally = async function() {
            const displayRound = notesDisplayRound || activeRoundId || 'round1';
            if (validatedRounds[displayRound]) {
                await customAlert('Ce tour est d√©j√† valid√© (verrouillage d√©finitif).');
                return;
            }
            await loadJuries();
            const juriesOnRound = JURIES.filter(j => j.rounds && j.rounds.includes(displayRound));
            const candidatesInRound = CANDIDATES.filter(c => c.tour === displayRound);
            if (candidatesInRound.length === 0 || juriesOnRound.length === 0) {
                await customAlert('Aucun candidat ou jury sur ce tour.');
                return;
            }
            const scoresQuery = query(collection(db, "scores"), where("roundId", "==", displayRound));
            const scoresSnap = await getDocs(scoresQuery);
            const byCandidate = {};
            scoresSnap.forEach(d => {
                const data = d.data();
                const cid = data.candidateId;
                const jid = data.juryId || data.juryName;
                if (!byCandidate[cid]) byCandidate[cid] = {};
                byCandidate[cid][jid] = { score1: data.score1, score2: data.score2 };
            });
            let missing = [];
            for (const c of candidatesInRound) {
                for (const j of juriesOnRound) {
                    const s = byCandidate[c.id] && byCandidate[c.id][j.id];
                    if (!s || s.score1 === '-' || s.score1 === undefined || s.score2 === '-' || s.score2 === undefined) {
                        missing.push(`${c.name} (${j.name})`);
                    }
                }
            }
            if (missing.length > 0) {
                await customAlert('Impossible de valider : notes manquantes pour\n\n' + missing.slice(0, 10).join('\n') + (missing.length > 10 ? '\n‚Ä¶ et ' + (missing.length - 10) + ' autre(s)' : ''));
                return;
            }
            if (!await customConfirm('Valider tout le tour ? Les notes ne pourront plus √™tre modifi√©es (verrouillage d√©finitif).')) return;
            validatedRounds[displayRound] = true;
            await setDoc(doc(db, "config", "validated_rounds"), { rounds: validatedRounds });
            for (const c of candidatesInRound) {
                candidateLocks[c.id] = candidateLocks[c.id] || {};
                juriesOnRound.forEach(j => { candidateLocks[c.id][j.id] = true; });
            }
            await setDoc(doc(db, "config", "locks"), { locks: candidateLocks });
            await addDoc(collection(db, "activation_logs"), {
                type: 'tour_validated',
                candidat_id: '',
                source: 'admin',
                timestamp: new Date(),
                payload: { roundId: displayRound }
            });
            await customAlert('‚úì Tour valid√©. Verrouillage d√©finitif appliqu√©.');
            await renderNotesTable();
        };

        /** D√©verrouiller le tour : retire la validation et les verrous pour ce tour. */
        window.unlockRoundGlobally = async function() {
            const displayRound = notesDisplayRound || activeRoundId || 'round1';
            if (!validatedRounds[displayRound]) {
                await customAlert('Ce tour n\'est pas valid√©.');
                return;
            }
            if (!await customConfirm('D√©verrouiller ce tour ? Les notes pourront √† nouveau √™tre modifi√©es.')) return;
            delete validatedRounds[displayRound];
            await setDoc(doc(db, "config", "validated_rounds"), { rounds: validatedRounds });
            await loadJuries();
            const juriesOnRound = JURIES.filter(j => j.rounds && j.rounds.includes(displayRound));
            const candidatesInRound = CANDIDATES.filter(c => c.tour === displayRound);
            for (const c of candidatesInRound) {
                if (candidateLocks[c.id]) {
                    juriesOnRound.forEach(j => { delete candidateLocks[c.id][j.id]; });
                    if (Object.keys(candidateLocks[c.id]).length === 0) delete candidateLocks[c.id];
                }
            }
            await setDoc(doc(db, "config", "locks"), { locks: candidateLocks });
            await addDoc(collection(db, "activation_logs"), {
                type: 'tour_unlocked',
                candidat_id: '',
                source: 'admin',
                timestamp: new Date(),
                payload: { roundId: displayRound }
            });
            await customAlert('‚úì Tour d√©verrouill√©. Les notes peuvent √† nouveau √™tre modifi√©es.');
            await renderNotesTable();
        };

        // --- CALCUL DES SCORES ---
        window.loadResults = async () => {
            // Utiliser le tour s√©lectionn√© dans le dropdown du podium ou le tour actif par d√©faut
            const displayRound = podiumDisplayRound || activeRoundId || 'round1';
            
            // D√©terminer le type du tour affich√© et le tour pr√©c√©dent
            const currentRound = ROUNDS.find(r => r.id === displayRound);
            const isRepechage = currentRound && currentRound.type === 'Rep√™chage';
            let previousRoundId = null;
            
            if (isRepechage) {
                const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
                const currentIndex = sortedRounds.findIndex(r => r.id === displayRound);
                if (currentIndex > 0) {
                    previousRoundId = sortedRounds[currentIndex - 1].id;
                }
            }
            
            console.log(`üìä [loadResults] Type de tour: ${currentRound?.type}, isRepechage: ${isRepechage}, previousRoundId: ${previousRoundId}`);
            
            // Charger les scores du tour s√©lectionn√©
            const q = query(
                collection(db, "scores"),
                where("roundId", "==", displayRound)
            );
            const querySnapshot = await getDocs(q);
            
            // Charger aussi les jurys pour identifier le pr√©sident si c'est un rep√™chage
            await loadJuries();
            const president = JURIES.find(j => j.isPresident);
            
            // Pour rep√™chage : charger les scores du tour pr√©c√©dent
            let previousRoundScores = {};
            let previousRoundJuries = [];
            if (isRepechage && previousRoundId) {
                const prevQuery = query(
                    collection(db, "scores"),
                    where("roundId", "==", previousRoundId)
                );
                const prevQuerySnapshot = await getDocs(prevQuery);
                
                const previousRoundJuriesSet = new Set();
                prevQuerySnapshot.forEach(docSnap => {
                    const data = docSnap.data();
                    const juryId = data.juryId || data.juryName;
                    previousRoundJuriesSet.add(juryId);
                    
                    if (!previousRoundScores[data.candidateId]) {
                        previousRoundScores[data.candidateId] = {};
                    }
                    previousRoundScores[data.candidateId][juryId] = {
                        score1: data.score1,
                        score2: data.score2,
                        juryName: data.juryName
                    };
                });
                
                previousRoundJuries = JURIES.filter(j => previousRoundJuriesSet.has(j.id));
                console.log(`üìä [loadResults] Jurys du tour pr√©c√©dent:`, previousRoundJuries.map(j => j.name));
            }
            
            aggregatedData = {};
            const juries = new Set();

            CANDIDATES.forEach(c => {
                aggregatedData[c.id] = { name: c.name, total: 0, juryScores: {}, hasScores: false };
            });

            // Utiliser un Set pour d√©tecter et √©viter les doublons
            const processedKeys = new Set();

            querySnapshot.forEach(doc => {
                const data = doc.data();
                const key = `${data.candidateId}_${data.juryName}`;
                
                // Ignorer les doublons (garder seulement le premier rencontr√©)
                if (processedKeys.has(key)) {
                    console.warn(`‚ö†Ô∏è Doublon ignor√©: ${key}`);
                    return;
                }
                processedKeys.add(key);
                
                if (aggregatedData[data.candidateId]) {
                    juries.add(data.juryName);
                    aggregatedData[data.candidateId].juryScores[data.juryName] = data;
                }
            });
            
            // Calculer les scores pour chaque candidat
            CANDIDATES.forEach(c => {
                let totalScore = 0;
                let hasScores = false;
                
                if (isRepechage && president) {
                    // Pour le rep√™chage, v√©rifier d'abord le vote du pr√©sident
                    const presidentScore = aggregatedData[c.id].juryScores[president.name];
                    let presidentVote = null;
                    
                    if (presidentScore && presidentScore.score1 !== '-') {
                        presidentVote = presidentScore.score1; // '0' ou '1'
                    }
                    
                    // Si le pr√©sident a vot√© "0" (√©limin√©), le score est 0
                    if (presidentVote === '0') {
                        totalScore = 0;
                        hasScores = true;
                    }
                    // Si le pr√©sident a vot√© "1" (qualifi√©) ou n'a pas encore vot√©, utiliser le score du tour pr√©c√©dent
                    else {
                        previousRoundJuries.forEach(jury => {
                            const scores = previousRoundScores[c.id]?.[jury.id];
                            if (scores) {
                                if (scores.score1 !== '-' && scores.score2 !== '-') {
                                    hasScores = true;
                                    
                                    // R√®gle : si un jury met "EL", toute sa notation = 0
                                    if (scores.score1 === 'EL' || scores.score2 === 'EL') {
                                        totalScore += 0;
                                    } else {
                                        const s1 = parseFloat(scores.score1) || 0;
                                        const s2 = parseFloat(scores.score2) || 0;
                                        totalScore += (s1 * 3 + s2);
                                    }
                                    
                                    // Ajouter les scores du tour pr√©c√©dent aux juryScores pour l'export
                                    if (!aggregatedData[c.id].juryScores[scores.juryName]) {
                                        aggregatedData[c.id].juryScores[scores.juryName] = scores;
                                    }
                                }
                            }
                        });
                    }
                } else {
                    // Pour les autres tours, utiliser les scores du tour courant
                    Object.values(aggregatedData[c.id].juryScores).forEach(data => {
                        if (data.score1 && data.score1 !== '-' && data.score2 && data.score2 !== '-') {
                            hasScores = true;
                            
                            // R√®gle : si un jury met "EL", toute sa notation = 0
                            if (data.score1 === 'EL' || data.score2 === 'EL') {
                                totalScore += 0;
                            } else {
                                const s1 = parseFloat(data.score1) || 0;
                                const s2 = parseFloat(data.score2) || 0;
                                totalScore += (s1 * 3 + s2);
                            }
                        }
                    });
                }
                
                aggregatedData[c.id].total = totalScore;
                aggregatedData[c.id].hasScores = hasScores;
            });

            // Pour l'onglet Podium uniquement : classement final pour la r√©gie = score_base + TOUS les points (Mon classement des jurys) + bonus +10% pour TOUS les gagnants de duel. Sans d√©pendre de l'activation classements.
            podiumFinalList = null;
            podiumFinalListRound = null;
            try {
                await loadJuries();
                const juriesOnRound = JURIES.filter(j => j.rounds && j.rounds.includes(displayRound));
                const POSITION_LABELS = ['1', '2', '3', '4', '5'];
                const POSITION_TO_POINTS = { '1': 10, '2': 8, '3': 6, '4': 4, '5': 2 };
                const pointsByCandidate = {};
                for (const j of juriesOnRound) {
                    const docId = j.id + '_' + displayRound;
                    const snap = await getDoc(doc(db, "jury_rankings", docId));
                    const positions = snap.exists() ? (snap.data().positions || {}) : {};
                    POSITION_LABELS.forEach(posLabel => {
                        const candidateId = positions[posLabel];
                        if (candidateId) {
                            const pts = POSITION_TO_POINTS[posLabel] || 0;
                            pointsByCandidate[candidateId] = (pointsByCandidate[candidateId] || 0) + pts;
                        }
                    });
                }
                const duelWinnerIds = await getDuelWinnerIds(displayRound) || [];
                const list = [];
                CANDIDATES.forEach(c => {
                    const data = aggregatedData[c.id];
                    if (!data || !data.hasScores) return;
                    let total = (typeof data.total === 'number' ? data.total : parseFloat(data.total) || 0) + (pointsByCandidate[c.id] || 0);
                    if (duelWinnerIds.includes(c.id)) total = Math.round(total * 1.1 * 100) / 100;
                    list.push({ name: c.name || c.id, candidateId: c.id, total: Math.round(total * 100) / 100 });
                });
                list.sort((a, b) => b.total - a.total);
                podiumFinalList = list;
                podiumFinalListRound = displayRound;
            } catch (e) {
                console.warn('[PODIUM] Chargement classement final:', e);
            }

            // L'onglet R√©sultats n'existe plus, on ne garde que le podium
            // renderMatrix(Array.from(juries).sort());
            renderPodium();
        };

        let currentSortColumn = -1;
        let currentSortDirection = 'desc'; // Start with descending for Total column
        let cachedSortedJuries = [];

        function renderMatrix(sortedJuries) {
            cachedSortedJuries = sortedJuries; // Cache for sorting
            
            const thead = document.querySelector("#scores-matrix thead tr");
            const tbody = document.querySelector("#scores-matrix tbody");
            
            // Build header with click handlers
            thead.innerHTML = "<th data-col='0' title='Cliquer pour trier'>Candidat</th>" + 
                sortedJuries.map((j, idx) => `<th data-col='${idx + 1}' title='Cliquer pour trier'>${j}</th>`).join('') + 
                "<th data-col='total' title='Cliquer pour trier'>Total</th>";
            
            // Add click handlers to headers
            thead.querySelectorAll('th').forEach((th, colIndex) => {
                th.addEventListener('click', () => sortTable(colIndex));
            });
            
            // Store data for sorting
            const candidateRows = CANDIDATES.map(c => {
                const data = aggregatedData[c.id];
                return { candidate: c, data: data };
            });
            
            // Sort if needed
            if (currentSortColumn >= 0) {
                candidateRows.sort((a, b) => {
                    let valA, valB;
                    
                    if (currentSortColumn === 0) {
                        // Sort by candidate name
                        valA = a.candidate.name.toLowerCase();
                        valB = b.candidate.name.toLowerCase();
                        return currentSortDirection === 'asc' ? 
                            valA.localeCompare(valB) : valB.localeCompare(valA);
                    } else if (currentSortColumn === sortedJuries.length + 1) {
                        // Sort by total
                        valA = a.data.total || 0;
                        valB = b.data.total || 0;
                        return currentSortDirection === 'asc' ? valA - valB : valB - valA;
                    } else {
                        // Sort by jury score
                        const juryName = sortedJuries[currentSortColumn - 1];
                        const scoreA = a.data.juryScores[juryName];
                        const scoreB = b.data.juryScores[juryName];
                        
                        // Calculate weighted scores
                        valA = 0;
                        valB = 0;
                        
                        if (scoreA && scoreA.score1 !== '-' && scoreA.score2 !== '-' && 
                            scoreA.score1 !== 'EL' && scoreA.score2 !== 'EL') {
                            valA = (parseInt(scoreA.score1) * 3) + parseInt(scoreA.score2);
                        }
                        if (scoreB && scoreB.score1 !== '-' && scoreB.score2 !== '-' && 
                            scoreB.score1 !== 'EL' && scoreB.score2 !== 'EL') {
                            valB = (parseInt(scoreB.score1) * 3) + parseInt(scoreB.score2);
                        }
                        
                        return currentSortDirection === 'asc' ? valA - valB : valB - valA;
                    }
                });
                
                // Update sort indicator
                thead.querySelectorAll('th').forEach(th => {
                    th.classList.remove('sorted-asc', 'sorted-desc');
                });
                thead.querySelectorAll('th')[currentSortColumn].classList.add(
                    currentSortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc'
                );
            }
            
            // Render rows
            tbody.innerHTML = "";
            candidateRows.forEach(({ candidate: c, data }) => {
                const row = tbody.insertRow();
                row.insertCell().innerHTML = `<b>${c.name}</b>`;
                
                sortedJuries.forEach(j => {
                    const scoreObj = data.juryScores[j];
                    const cell = row.insertCell();
                    if (scoreObj) {
                        if (scoreObj.score1 === "EL") {
                            cell.className = "eliminado";
                            cell.textContent = "√âLIMIN√â";
                        } else {
                            // Recalculer le weighted score pour l'affichage
                            let displayWeightedScore = 0;
                            if (scoreObj.score1 && scoreObj.score1 !== '-' && 
                                scoreObj.score2 && scoreObj.score2 !== '-' &&
                                scoreObj.score1 !== 'EL' && scoreObj.score2 !== 'EL') {
                                displayWeightedScore = (parseInt(scoreObj.score1) * 3) + parseInt(scoreObj.score2);
                            }
                            cell.innerHTML = `<span class="detail-note">${scoreObj.score1} | ${scoreObj.score2}</span><span class="weighted-total">${displayWeightedScore}</span>`;
                        }
                    } else { cell.textContent = "-"; }
                });
                const totalCell = row.insertCell();
                totalCell.className = "total-score";
                totalCell.textContent = data.total;
            });
        }

        function sortTable(colIndex) {
            if (currentSortColumn === colIndex) {
                // Toggle direction
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                // New column - default to descending for numbers, ascending for names
                currentSortColumn = colIndex;
                currentSortDirection = colIndex === 0 ? 'asc' : 'desc';
            }
            renderMatrix(cachedSortedJuries);
        }

        window.renderPodium = function() {
            const body = document.getElementById('podium-body');
            if (!body) return;
            
            body.innerHTML = "";
            
            const displayRound = podiumDisplayRound || activeRoundId || 'round1';
            // Utiliser le classement final (avec points d'activation et bonus duel +10%) pour la r√©gie, si disponible
            let list = [];
            if (podiumFinalList && podiumFinalList.length > 0 && podiumFinalListRound === displayRound) {
                list = podiumFinalList.filter(e => {
                    const c = CANDIDATES.find(x => x.id === e.candidateId);
                    return !c || c.status !== 'Elimine';
                });
            }
            if (list.length === 0 && aggregatedData && Object.keys(aggregatedData).length > 0) {
                // Fallback : classement √† partir des scores bruts (sans bonus)
                list = Object.values(aggregatedData).filter(c => {
                    const candidate = CANDIDATES.find(cand => cand.name === c.name);
                    return c.hasScores && candidate && candidate.status !== 'Elimine';
                }).sort((a, b) => b.total - a.total);
            }
            if (list.length === 0) {
                const row = body.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 3;
                cell.textContent = !aggregatedData || Object.keys(aggregatedData).length === 0
                    ? "Aucune donn√©e. Les r√©sultats se calculent automatiquement en ouvrant cet onglet."
                    : "Aucun r√©sultat disponible.";
                cell.style.textAlign = "center";
                cell.style.padding = "20px";
                cell.style.color = "var(--text-secondary)";
                return;
            }
            
            // Limiter le nombre de r√©sultats affich√©s
            const limitInput = document.getElementById('result-limit');
            const limit = limitInput ? parseInt(limitInput.value || 3) : 3;
            list = list.slice(0, limit);
            
            list.forEach((c, i) => {
                const row = body.insertRow();
                if (i === 0) row.className = "rank-1";
                else if (i === 1) row.className = "rank-2";
                else if (i === 2) row.className = "rank-3";

                row.insertCell().textContent = i + 1;
                row.insertCell().textContent = c.name;
                row.insertCell().textContent = c.total;
            });
        };

        // Migrer les scores vers le nouveau syst√®me avec juryId
        window.migrateScoresToJuryIds = async () => {
            if (!await confirm('Migrer tous les scores vers le nouveau syst√®me avec IDs num√©riques ?\n\nCela ajoutera un champ juryId √† tous les scores qui n\'en ont pas encore.')) {
                return;
            }
            
            try {
                // Charger tous les comptes jury
                const accountsSnap = await getDocs(collection(db, "accounts"));
                const juryNameToId = new Map();
                accountsSnap.forEach(doc => {
                    const juryName = doc.data().name || doc.id;
                    juryNameToId.set(juryName, doc.id);
                });
                
                // Charger tous les scores
                const scoresSnap = await getDocs(collection(db, "scores"));
                let migrated = 0;
                let skipped = 0;
                let notFound = 0;
                
                const batch = writeBatch(db);
                let batchCount = 0;
                
                for (const scoreDoc of scoresSnap.docs) {
                    const data = scoreDoc.data();
                    
                    // Si le score a d√©j√† un juryId, le sauter
                    if (data.juryId) {
                        skipped++;
                        continue;
                    }
                    
                    // Chercher le juryId correspondant au juryName
                    const juryId = juryNameToId.get(data.juryName);
                    
                    if (juryId) {
                        // Ajouter le juryId au score
                        batch.update(scoreDoc.ref, { juryId: juryId });
                        migrated++;
                        batchCount++;
                        
                        // Firestore batch limit is 500
                        if (batchCount >= 500) {
                            await batch.commit();
                            batchCount = 0;
                        }
                    } else {
                        notFound++;
                        console.warn(`‚ö†Ô∏è Jury non trouv√© pour le score: ${data.juryName}`);
                    }
                }
                
                // Commit remaining operations
                if (batchCount > 0) {
                    await batch.commit();
                }
                
                alert(`‚úì Migration termin√©e !\n\n${migrated} score(s) migr√©(s)\n${skipped} score(s) d√©j√† √† jour\n${notFound} jury(s) non trouv√©(s)`);
                
                // Rafra√Æchir l'affichage
                await loadResults();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la migration: ' + e.message);
            }
        };
        
        // Nettoyer et v√©rifier la conformit√© de la base de donn√©es
        window.cleanDatabase = async () => {
            if (!await confirm('‚ö†Ô∏è NETTOYAGE DE LA BASE DE DONN√âES ‚ö†Ô∏è\n\nCette op√©ration va :\n- Supprimer les doublons de scores\n- Supprimer les scores orphelins (candidats/jurys supprim√©s)\n- Nettoyer les valeurs calcul√©es obsol√®tes\n\nüíæ Recommandation : Sauvegardez votre base avant de continuer !\n\nContinuer le nettoyage ?')) {
                return;
            }
            
            try {
                let report = {
                    duplicatesRemoved: 0,
                    orphanScores: 0,
                    obsoleteFields: 0
                };
                
                // 1. Charger les candidats et jurys valides
                const candidatsSnap = await getDoc(doc(db, "candidats", "liste_actuelle"));
                const validCandidates = new Set(candidatsSnap.exists() ? (candidatsSnap.data().candidates || []).map(c => c.id) : []);
                
                const accountsSnap = await getDocs(collection(db, "accounts"));
                const validJuries = new Set();
                accountsSnap.forEach(d => {
                    validJuries.add(d.id); // juryId
                    validJuries.add(d.data().name || d.id); // juryName pour compatibilit√©
                });
                
                // 2. Analyser tous les scores
                const querySnapshot = await getDocs(collection(db, "scores"));
                const scoresByKey = {};
                const toDelete = [];
                
                querySnapshot.forEach(scoreDoc => {
                    const data = scoreDoc.data();
                    const key = `${data.candidateId}_${data.juryId || data.juryName}_${data.roundId || 'round1'}`;
                    
                    // V√©rifier si le score est orphelin
                    const isOrphan = !validCandidates.has(data.candidateId) || 
                                     (!validJuries.has(data.juryId) && !validJuries.has(data.juryName));
                    
                    if (isOrphan) {
                        toDelete.push({ id: scoreDoc.id, reason: 'orphan' });
                        report.orphanScores++;
                    } else {
                        // Grouper pour d√©tecter les doublons
                        if (!scoresByKey[key]) {
                            scoresByKey[key] = [];
                        }
                        scoresByKey[key].push({ 
                            id: scoreDoc.id, 
                            data: data, 
                            timestamp: data.timestamp 
                        });
                    }
                    
                    // V√©rifier les champs obsol√®tes
                    if ('totalWeightedScore' in data) {
                        toDelete.push({ id: scoreDoc.id, reason: 'obsoleteField', data: data });
                        report.obsoleteFields++;
                    }
                });
                
                // 3. Trouver les doublons
                for (const key in scoresByKey) {
                    const scores = scoresByKey[key];
                    if (scores.length > 1) {
                        // Trier par timestamp (le plus r√©cent en premier)
                        scores.sort((a, b) => {
                            const timeA = a.timestamp?.toDate?.() || new Date(0);
                            const timeB = b.timestamp?.toDate?.() || new Date(0);
                            return timeB - timeA;
                        });
                        
                        // Marquer les anciens pour suppression
                        for (let i = 1; i < scores.length; i++) {
                            toDelete.push({ id: scores[i].id, reason: 'duplicate' });
                            report.duplicatesRemoved++;
                        }
                    }
                }
                
                // 4. Supprimer les scores invalides/obsol√®tes
                for (const item of toDelete) {
                    if (item.reason === 'obsoleteField') {
                        // Juste enlever le champ obsol√®te
                        const { totalWeightedScore, ...cleanData } = item.data;
                        await setDoc(doc(db, "scores", item.id), cleanData);
                    } else {
                        // Supprimer compl√®tement (doublon ou orphelin)
                        await deleteDoc(doc(db, "scores", item.id));
                    }
                }
                
                await alert(`‚úì Nettoyage termin√© !\n\nüìä Rapport :\n- ${report.duplicatesRemoved} doublon(s) supprim√©(s)\n- ${report.orphanScores} score(s) orphelin(s) supprim√©(s)\n- ${report.obsoleteFields} champ(s) obsol√®te(s) nettoy√©(s)\n\nTotal : ${report.duplicatesRemoved + report.orphanScores} score(s) supprim√©(s)`);
                
                // Rafra√Æchir l'affichage
                renderNotesTable();
                await loadResults();
            } catch (e) {
                console.error('Erreur:', e);
                await alert('Erreur lors du nettoyage: ' + e.message);
            }
        };
        
        // Supprimer les doublons de scores
        window.removeDuplicateScores = async () => {
            if (!await confirm('Rechercher et supprimer les doublons de scores ?\n\nPour chaque combinaison candidat+jury, seule la note la plus r√©cente sera conserv√©e.')) {
                return;
            }
            
            try {
                const querySnapshot = await getDocs(collection(db, "scores"));
                
                // Grouper par candidat+jury
                const scoresByKey = {};
                querySnapshot.forEach(doc => {
                    const data = doc.data();
                    const key = `${data.candidateId}_${data.juryName}`;
                    
                    if (!scoresByKey[key]) {
                        scoresByKey[key] = [];
                    }
                    scoresByKey[key].push({ id: doc.id, data: data, timestamp: data.timestamp });
                });
                
                // Trouver et supprimer les doublons
                let duplicatesFound = 0;
                let duplicatesRemoved = 0;
                
                for (const key in scoresByKey) {
                    const scores = scoresByKey[key];
                    if (scores.length > 1) {
                        duplicatesFound += scores.length - 1;
                        console.log(`Doublon trouv√© pour ${key}: ${scores.length} entr√©es`);
                        
                        // Trier par timestamp (le plus r√©cent en premier)
                        scores.sort((a, b) => {
                            const timeA = a.timestamp?.toDate?.() || new Date(0);
                            const timeB = b.timestamp?.toDate?.() || new Date(0);
                            return timeB - timeA;
                        });
                        
                        // Garder le premier (le plus r√©cent), supprimer les autres
                        for (let i = 1; i < scores.length; i++) {
                            console.log(`Suppression de l'ancien score: ${scores[i].id}`, scores[i].data);
                            await deleteDoc(doc(db, "scores", scores[i].id));
                            duplicatesRemoved++;
                        }
                    }
                }
                
                alert(`‚úì Nettoyage des doublons termin√© !\n${duplicatesFound} doublon(s) trouv√©(s)\n${duplicatesRemoved} doublon(s) supprim√©(s)`);
                
                // Rafra√Æchir l'affichage
                renderNotesTable();
                await loadResults();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors du nettoyage des doublons: ' + e.message);
            }
        };

        // Nettoyer les valeurs calcul√©es obsol√®tes de la base de donn√©es
        // T√©l√©charger toute la base de donn√©es en JSON
        window.downloadDatabase = async () => {
            try {
                const backup = {
                    exportDate: new Date().toISOString(),
                    version: "2.0",
                    data: {}
                };
                
                // Exporter les candidats
                const candidatsSnap = await getDoc(doc(db, "candidats", "liste_actuelle"));
                if (candidatsSnap.exists()) {
                    backup.data.candidats = candidatsSnap.data();
                }
                
                // Exporter tous les comptes jury (collection accounts)
                const accountsSnap = await getDocs(collection(db, "accounts"));
                backup.data.accounts = [];
                accountsSnap.forEach(d => {
                    backup.data.accounts.push({ 
                        id: d.id, 
                        ...d.data(),
                        // Convertir les timestamps en ISO strings pour le JSON
                        createdAt: d.data().createdAt?.toDate?.()?.toISOString() || null
                    });
                });
                
                // Exporter tous les scores
                const scoresSnap = await getDocs(collection(db, "scores"));
                backup.data.scores = [];
                scoresSnap.forEach(d => {
                    const scoreData = d.data();
                    backup.data.scores.push({ 
                        id: d.id, 
                        ...scoreData,
                        // Convertir les timestamps en ISO strings
                        timestamp: scoreData.timestamp?.toDate?.()?.toISOString() || null
                    });
                });
                
                // Exporter la configuration compl√®te
                backup.data.config = {};
                
                // Config: locks
                const locksSnap = await getDoc(doc(db, "config", "locks"));
                if (locksSnap.exists()) {
                    backup.data.config.locks = locksSnap.data();
                }
                
                // Config: session
                const sessionSnap = await getDoc(doc(db, "config", "session"));
                if (sessionSnap.exists()) {
                    backup.data.config.session = sessionSnap.data();
                }
                
                // Config: admin (mot de passe et th√®me)
                const adminSnap = await getDoc(doc(db, "config", "admin"));
                if (adminSnap.exists()) {
                    backup.data.config.admin = adminSnap.data();
                }
                
                // Config: rounds (tours)
                const roundsSnap = await getDoc(doc(db, "config", "rounds"));
                if (roundsSnap.exists()) {
                    backup.data.config.rounds = roundsSnap.data();
                }
                
                // Cr√©er le fichier JSON
                const json = JSON.stringify(backup, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // T√©l√©charger
                const a = document.createElement('a');
                a.href = url;
                a.download = `concours-eloquence-backup-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert(`‚úì Sauvegarde cr√©√©e avec succ√®s !\n\n${backup.data.scores.length} score(s)\n${backup.data.candidats?.candidates?.length || 0} candidat(s)\n${backup.data.accounts.length} jury(s)`);
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la sauvegarde: ' + e.message);
            }
        };
        
        // Restaurer la base de donn√©es depuis un fichier JSON
        window.uploadDatabase = async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!await confirm(`‚ö†Ô∏è ATTENTION ‚ö†Ô∏è\n\nRestaurer la base de donn√©es va REMPLACER toutes les donn√©es actuelles !\n\nVoulez-vous continuer ?`)) {
                event.target.value = ''; // Reset file input
                return;
            }
            
            try {
                const text = await file.text();
                const backup = JSON.parse(text);
                
                if (!backup.data || !backup.version) {
                    throw new Error('Format de fichier invalide');
                }
                
                let restored = 0;
                
                // Restaurer les candidats
                if (backup.data.candidats) {
                    await setDoc(doc(db, "candidats", "liste_actuelle"), backup.data.candidats);
                    CANDIDATES = backup.data.candidats.candidates || [];
                    restored++;
                }
                
                // Restaurer les comptes jury (supprimer les anciens d'abord)
                if (backup.data.accounts) {
                    const oldAccounts = await getDocs(collection(db, "accounts"));
                    for (const d of oldAccounts.docs) {
                        await deleteDoc(doc(db, "accounts", d.id));
                    }
                    
                    for (const account of backup.data.accounts) {
                        const { id, ...accountData } = account;
                        // Convertir les ISO strings en Timestamps
                        if (accountData.createdAt && typeof accountData.createdAt === 'string') {
                            accountData.createdAt = new Date(accountData.createdAt);
                        }
                        await setDoc(doc(db, "accounts", id), accountData);
                        restored++;
                    }
                }
                
                // Restaurer les scores (supprimer les anciens d'abord)
                const oldScores = await getDocs(collection(db, "scores"));
                for (const d of oldScores.docs) {
                    await deleteDoc(doc(db, "scores", d.id));
                }
                
                if (backup.data.scores) {
                    for (const score of backup.data.scores) {
                        const { id, ...scoreData } = score;
                        // Convertir les ISO strings en Timestamps
                        if (scoreData.timestamp && typeof scoreData.timestamp === 'string') {
                            scoreData.timestamp = new Date(scoreData.timestamp);
                        }
                        await addDoc(collection(db, "scores"), scoreData);
                        restored++;
                    }
                }
                
                // Restaurer la configuration (version 2.0 avec structure unifi√©e)
                if (backup.data.config) {
                    if (backup.data.config.locks) {
                        await setDoc(doc(db, "config", "locks"), backup.data.config.locks);
                        candidateLocks = backup.data.config.locks.locks || {};
                        restored++;
                    }
                    
                    if (backup.data.config.session) {
                        await setDoc(doc(db, "config", "session"), backup.data.config.session);
                        restored++;
                    }
                    
                    if (backup.data.config.admin) {
                        await setDoc(doc(db, "config", "admin"), backup.data.config.admin);
                        restored++;
                    }
                    
                    if (backup.data.config.rounds) {
                        await setDoc(doc(db, "config", "rounds"), backup.data.config.rounds);
                        restored++;
                    }
                }
                // Support de l'ancien format (version 1.0)
                else {
                    if (backup.data.locks) {
                        await setDoc(doc(db, "config", "locks"), backup.data.locks);
                        candidateLocks = backup.data.locks.locks || {};
                        restored++;
                    }
                    
                    if (backup.data.session) {
                        await setDoc(doc(db, "config", "session"), backup.data.session);
                        restored++;
                    }
                    
                    if (backup.data.adminPassword) {
                        await setDoc(doc(db, "config", "admin"), { password: backup.data.adminPassword });
                        restored++;
                    }
                }
                
                alert(`‚úì Restauration r√©ussie !\n\n${restored} √©l√©ment(s) restaur√©(s)\nVersion: ${backup.version}\nDate de sauvegarde: ${new Date(backup.exportDate).toLocaleString()}`);
                
                // Recharger la page pour rafra√Æchir toutes les donn√©es
                location.reload();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la restauration: ' + e.message);
                event.target.value = ''; // Reset file input
            }
        };

        window.recalculateAllScores = async () => {
            if (!await confirm('Nettoyer les valeurs calcul√©es obsol√®tes en base de donn√©es ?\n\nLes scores pond√©r√©s seront d√©sormais toujours calcul√©s √† la vol√©e.')) {
                return;
            }
            
            try {
                const querySnapshot = await getDocs(collection(db, "scores"));
                let cleaned = 0;
                
                for (const scoreDoc of querySnapshot.docs) {
                    const data = scoreDoc.data();
                    
                    // Supprimer totalWeightedScore s'il existe
                    if ('totalWeightedScore' in data) {
                        delete data.totalWeightedScore;
                        await setDoc(doc(db, "scores", scoreDoc.id), data);
                        cleaned++;
                    }
                }
                
                alert(`‚úì Nettoyage termin√© !\n${cleaned} enregistrement(s) nettoy√©(s).\n\nLes totaux sont maintenant calcul√©s correctement.`);
                
                // Rafra√Æchir l'affichage
                renderNotesTable();
                await loadResults();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors du nettoyage: ' + e.message);
            }
        };

        window.confirmDeleteAllJuries = async () => {
            if (!await customConfirm(`‚ö†Ô∏è ATTENTION ‚ö†Ô∏è\n\nSupprimer TOUS les comptes jurys ET toutes leurs notations ?\n\nLa liste des candidats sera conserv√©e.\n\nCette action est IRR√âVERSIBLE !`)) {
                return;
            }
            
            // Double confirmation
            if (!await customConfirm(`√ätes-vous VRAIMENT s√ªr ?\n\nTous les comptes jurys et toutes leurs notes seront supprim√©s d√©finitivement.`)) {
                return;
            }
            
            try {
                // Supprimer toutes les notations
                const scoresSnapshot = await getDocs(collection(db, "scores"));
                const batch1 = writeBatch(db);
                scoresSnapshot.docs.forEach(d => batch1.delete(d.ref));
                await batch1.commit();
                const deletedScores = scoresSnapshot.docs.length;
                
                // Supprimer tous les comptes jurys
                const accountsSnapshot = await getDocs(collection(db, "accounts"));
                const batch2 = writeBatch(db);
                accountsSnapshot.docs.forEach(d => batch2.delete(d.ref));
                await batch2.commit();
                const deletedJuries = accountsSnapshot.docs.length;
                
                // Supprimer tous les verrous
                candidateLocks = {};
                await setDoc(doc(db, "config", "locks"), { locks: {} });
                
                await customAlert(`‚úì Suppression termin√©e avec succ√®s\n\n- ${deletedJuries} jury(s) supprim√©(s)\n- ${deletedScores} notation(s) supprim√©e(s)`);
                location.reload();
            } catch (e) {
                console.error('Erreur:', e);
                await customAlert('‚ùå Erreur lors de la suppression:\n' + e.message);
            }
        };

        window.insertTestData = async () => {
            // Listes par d√©faut
            const defaultCandidateNames = [
                "Tim√©o Charvolin", "Paul R√©gent", "Lo√Øc Delais", "Sophie Moreau", "Lucas Bernard",
                "Emma Dubois", "Nathan Thomas", "L√©a Petit", "Hugo Robert", "Chlo√© Richard",
                "Arthur Durand", "Manon Lefebvre", "Louis Martin", "Camille Laurent", "Gabriel Simon",
                "Sarah Michel", "Alexandre Lef√®vre", "Julie Garcia", "Maxime Roux", "Marine Vincent",
                "Th√©o Fournier", "Clara Bertrand", "Antoine Girard", "Pauline Morel", "Nicolas Andr√©",
                "Laura Mercier", "Julien Blanchard", "Alice Fontaine", "Romain Rousseau", "Ana√Øs Lambert",
                "Pierre Chevalier", "Am√©lie Bonnet", "L√©na Garnier", "Benjamin Faure"
            ];
            
            const defaultJuryNames = ["Martin", "Lasso", "Murat", "Blier", "Collisse", "Pierre"];
            
            // Cr√©er la modal personnalis√©e
            const modalHtml = `
                <div style="display: flex; flex-direction: column; gap: 20px; max-height: 70vh; overflow-y: auto;">
                    <div style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; border: 2px solid var(--border-color);">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <input type="checkbox" id="test-add-candidates" checked style="width: 20px; height: 20px; cursor: pointer;">
                            <label for="test-add-candidates" style="font-weight: 600; font-size: 1.1em; color: var(--text-color); cursor: pointer;">üìã Ajouter des candidats de test</label>
                        </div>
                        <p style="color: var(--text-secondary); font-size: 0.9em; margin-bottom: 10px;">Un nom par ligne. Ces candidats seront ajout√©s aux candidats existants.</p>
                        <textarea id="test-candidates-list" style="width: 100%; min-height: 150px; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-color); font-family: monospace; font-size: 0.9em; resize: vertical;">${defaultCandidateNames.join('\n')}</textarea>
                        <div style="display: flex; align-items: center; gap: 8px; margin-top: 10px;">
                            <input type="checkbox" id="test-random-ids" style="width: 18px; height: 18px; cursor: pointer;">
                            <label for="test-random-ids" style="color: var(--text-color); cursor: pointer; font-size: 0.95em;">G√©n√©rer des IDs al√©atoires (sinon 001, 002, 003...)</label>
                        </div>
                    </div>
                    
                    <div style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; border: 2px solid var(--border-color);">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <input type="checkbox" id="test-add-juries" checked style="width: 20px; height: 20px; cursor: pointer;">
                            <label for="test-add-juries" style="font-weight: 600; font-size: 1.1em; color: var(--text-color); cursor: pointer;">üë• Ajouter des jurys de test</label>
                        </div>
                        <p style="color: var(--text-secondary); font-size: 0.9em; margin-bottom: 10px;">Un nom par ligne. Ces jurys seront ajout√©s aux jurys existants avec le mot de passe par d√©faut.</p>
                        <textarea id="test-juries-list" style="width: 100%; min-height: 100px; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-color); font-family: monospace; font-size: 0.9em; resize: vertical;">${defaultJuryNames.join('\n')}</textarea>
                    </div>
                    
                    <div style="background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%); padding: 12px; border-radius: 6px; border: 1px solid #ffc107;">
                        <p style="color: #856404; font-size: 0.9em; margin: 0;">
                            <strong>‚ö†Ô∏è Note :</strong> Les doublons seront automatiquement ignor√©s.
                        </p>
                    </div>
                </div>
            `;
            
            // Variable pour stocker les valeurs avant que la modal ne se ferme
            let modalData = null;
            
            // Cr√©er une Promise personnalis√©e pour g√©rer la modal
            const confirmed = await new Promise((resolve) => {
                // Afficher la modal avec customConfirm
                customConfirm(modalHtml, {
                    title: 'üß™ Ins√©rer des donn√©es de test',
                    confirmText: '‚úì Ajouter',
                    cancelText: '‚úó Annuler',
                    width: '600px'
                }).then((result) => {
                    resolve(result);
                });
                
                // Intercepter le clic sur le bouton confirm pour r√©cup√©rer les valeurs
                setTimeout(() => {
                    const confirmBtn = document.getElementById('modal-confirm');
                    if (confirmBtn) {
                        confirmBtn.addEventListener('click', () => {
                            // R√©cup√©rer les valeurs juste avant la fermeture
                            const addCandidatesEl = document.getElementById('test-add-candidates');
                            const addJuriesEl = document.getElementById('test-add-juries');
                            const candidatesListEl = document.getElementById('test-candidates-list');
                            const juriesListEl = document.getElementById('test-juries-list');
                            const randomIdsEl = document.getElementById('test-random-ids');
                            
                            modalData = {
                                addCandidates: addCandidatesEl?.checked || false,
                                addJuries: addJuriesEl?.checked || false,
                                candidatesList: candidatesListEl?.value || '',
                                juriesList: juriesListEl?.value || '',
                                randomIds: randomIdsEl?.checked || false
                            };
                        }, { once: true, capture: true });
                    }
                }, 100);
            });
            
            if (!confirmed || !modalData) return;
            
            try {
                // Utiliser les donn√©es sauvegard√©es
                const { addCandidates, addJuries, candidatesList, juriesList, randomIds } = modalData;
                
                if (!addCandidates && !addJuries) {
                    await customAlert('‚ö†Ô∏è Aucune donn√©e s√©lectionn√©e pour l\'ajout.');
                    return;
                }
                
                let candidatesAdded = 0;
                let juriesAdded = 0;
                
                // Ajouter les candidats si la checkbox est coch√©e
                if (addCandidates && candidatesList.trim()) {
                    const testCandidateNames = candidatesList.split('\n')
                        .map(name => name.trim())
                        .filter(name => name.length > 0);
                    
                    const candidatesDoc = await getDoc(doc(db, "candidats", "liste_actuelle"));
                    let existingCandidates = candidatesDoc.exists() ? candidatesDoc.data().candidates || [] : [];
                    const usedIds = new Set(existingCandidates.map(c => c.id));
                    const existingNames = new Set(existingCandidates.map(c => c.name.toLowerCase()));
                    
                    // Trouver le prochain ID s√©quentiel si n√©cessaire
                    let nextSequentialId = 1;
                    if (!randomIds) {
                        existingCandidates.forEach(c => {
                            const numId = parseInt(c.id);
                            if (!isNaN(numId) && numId >= nextSequentialId) {
                                nextSequentialId = numId + 1;
                            }
                        });
                    }
                    
                    for (const name of testCandidateNames) {
                        // Ignorer les doublons
                        if (existingNames.has(name.toLowerCase())) {
                            continue;
                        }
                        
                        // G√©n√©rer un ID unique
                        let newId;
                        if (randomIds) {
                            // IDs al√©atoires
                            do {
                                newId = String(Math.floor(Math.random() * 999) + 1).padStart(3, '0');
                            } while (usedIds.has(newId));
                        } else {
                            // IDs s√©quentiels
                            do {
                                newId = String(nextSequentialId).padStart(3, '0');
                                nextSequentialId++;
                            } while (usedIds.has(newId));
                        }
                        usedIds.add(newId);
                        
                        existingCandidates.push({
                            id: newId,
                            name: name,
                            tour: activeRoundId || 'round1',
                            status: 'Actif'
                        });
                        existingNames.add(name.toLowerCase());
                        candidatesAdded++;
                    }
                    
                    // Sauvegarder les candidats
                    await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: existingCandidates });
                }
                
                // Ajouter les jurys si la checkbox est coch√©e
                if (addJuries && juriesList.trim()) {
                    const testJuryNames = juriesList.split('\n')
                        .map(name => name.trim())
                        .filter(name => name.length > 0);
                    
                    // Charger les jurys existants sans mettre √† jour le textarea
                    const accountsSnap = await getDocs(collection(db, "accounts"));
                    JURIES = [];
                    accountsSnap.forEach(docSnap => {
                        const data = docSnap.data();
                        JURIES.push({
                            id: docSnap.id,
                            name: data.name || docSnap.id,
                            password: data.password || '',
                            theme: data.theme || 'light',
                            createdAt: data.createdAt,
                            rounds: data.rounds || [],
                            isPresident: data.isPresident || false
                        });
                    });
                    JURIES.sort((a, b) => {
                        const numA = parseInt(a.id.replace('jury', ''));
                        const numB = parseInt(b.id.replace('jury', ''));
                        return numA - numB;
                    });
                    
                    const existingJuryNames = new Set(JURIES.map(j => j.name.toLowerCase()));
                    
                    for (const juryName of testJuryNames) {
                        // Ignorer les doublons
                        if (existingJuryNames.has(juryName.toLowerCase())) {
                            continue;
                        }
                        
                        // Trouver le prochain ID disponible
                        let maxId = 0;
                        JURIES.forEach(j => {
                            const num = parseInt(j.id.replace('jury', ''));
                            if (num > maxId) maxId = num;
                        });
                        const newJuryId = `jury${maxId + 1}`;
                        
                        // D√©terminer si c'est le premier jury (pr√©sident)
                        const isFirstJury = JURIES.length === 0;
                        
                        // D√©terminer les tours par d√©faut
                        // Le jury est pr√©sent sur le tour actif et tous les suivants
                        // Sauf pour le rep√™chage, seul le pr√©sident acc√®de √† ce tour
                        const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
                        const activeRoundIndex = sortedRounds.findIndex(r => r.id === activeRoundId);
                        const defaultRounds = sortedRounds
                            .filter((r, index) => {
                                // Inclure le tour actif et tous les suivants
                                if (index < activeRoundIndex) return false;
                                
                                // Si c'est un rep√™chage, l'inclure seulement si c'est le pr√©sident
                                if (r.type === 'Rep√™chage') {
                                    return isFirstJury;
                                }
                                
                                return true;
                            })
                            .map(r => r.id);
                        
                        await setDoc(doc(db, "accounts", newJuryId), {
                            name: juryName,
                            password: DEFAULT_JURY_PASSWORD || '',
                            theme: 'light',
                            createdAt: new Date(),
                            isPresident: isFirstJury,
                            rounds: defaultRounds
                        });
                        
                        JURIES.push({
                            id: newJuryId,
                            name: juryName,
                            isPresident: isFirstJury,
                            rounds: defaultRounds
                        });
                        existingJuryNames.add(juryName.toLowerCase());
                        
                        juriesAdded++;
                    }
                }
                
                // Message de confirmation
                let message = '‚úì Donn√©es ajout√©es avec succ√®s !\n\n';
                if (candidatesAdded > 0) {
                    message += `üìã ${candidatesAdded} candidat(s) ajout√©(s)\n`;
                }
                if (juriesAdded > 0) {
                    message += `üë• ${juriesAdded} jury(s) ajout√©(s)\n`;
                }
                if (candidatesAdded === 0 && juriesAdded === 0) {
                    message = '‚ö†Ô∏è Aucune donn√©e ajout√©e (tous les noms existent d√©j√†).';
                }
                
                await customAlert(message);
                
                // Rafra√Æchir uniquement les tables (sans mettre √† jour les textareas)
                if (candidatesAdded > 0) {
                    // Recharger les candidats en m√©moire
                    const snap = await getDoc(doc(db, "candidats", "liste_actuelle"));
                    if (snap.exists()) {
                        CANDIDATES = snap.data().candidates || [];
                        CANDIDATES = CANDIDATES.map(c => ({
                            ...c,
                            tour: c.tour || activeRoundId || 'round1',
                            status: c.status || 'Actif'
                        }));
                    }
                    // Rafra√Æchir seulement la table
                    renderCandidateTable();
                }
                
                if (juriesAdded > 0) {
                    // Recharger les jurys en m√©moire
                    const accountsSnap = await getDocs(collection(db, "accounts"));
                    JURIES = [];
                    accountsSnap.forEach(docSnap => {
                        const data = docSnap.data();
                        JURIES.push({
                            id: docSnap.id,
                            name: data.name || docSnap.id,
                            password: data.password || '',
                            theme: data.theme || 'light',
                            createdAt: data.createdAt,
                            rounds: data.rounds || [],
                            isPresident: data.isPresident || false
                        });
                    });
                    JURIES.sort((a, b) => {
                        const numA = parseInt(a.id.replace('jury', ''));
                        const numB = parseInt(b.id.replace('jury', ''));
                        return numA - numB;
                    });
                    // Rafra√Æchir seulement la table
                    renderJuryTable();
                }
            } catch (e) {
                console.error('Erreur:', e);
                await customAlert('‚ùå Erreur lors de l\'insertion des donn√©es de test:\n' + e.message);
            }
        };

        window.autoFillActiveRound = async () => {
            try {
                // V√©rifier qu'il y a un tour actif
                if (!activeRoundId) {
                    await customAlert("Aucun tour actif d√©fini. Veuillez s√©lectionner un tour actif dans l'onglet 'Tours'.");
                    return;
                }
                
                // Trouver le nom du tour actif
                const activeRound = ROUNDS.find(r => r.id === activeRoundId);
                const roundName = activeRound ? activeRound.name : activeRoundId;
                
                if (!await customConfirm(`Auto-remplir les notes des candidats actifs du tour "${roundName}" avec des notes de test ?\n\nüìä Notes : 5, 10, 15 ou 20\n‚ö†Ô∏è ~15% des candidats seront √©limin√©s (note "EL")`)) {
                    return;
                }
                
                console.log(`üîÑ Auto-remplissage pour le tour: ${roundName} (${activeRoundId})`);
                
                // D√©sactiver temporairement le listener pour √©viter les rafra√Æchissements multiples
                console.log('‚è∏Ô∏è D√©sactivation temporaire du listener...');
                const wasListenerActive = !!scoresListener;
                if (scoresListener) {
                    scoresListener(); // Unsubscribe
                    scoresListener = null;
                }
                
                // Charger les candidats
                const candidatesDoc = await getDoc(doc(db, "candidats", "liste_actuelle"));
                if (!candidatesDoc.exists()) {
                    await customAlert("Aucun candidat trouv√©");
                    if (wasListenerActive) {
                        isFirstSnapshot = true;
                        setupScoresListener();
                    }
                    return;
                }
                const allCandidates = candidatesDoc.data().candidates || [];
                console.log(`üìã Total candidats: ${allCandidates.length}`);
                
                // Filtrer les candidats actifs du tour en cours
                const candidatesInRound = allCandidates.filter(c => c.tour === activeRoundId);
                const activeCandidatesInRound = candidatesInRound.filter(c => 
                    c.status === 'Actif' || c.status === 'Reset'
                );
                console.log(`üéØ Candidats dans le tour "${roundName}": ${candidatesInRound.length} (dont ${activeCandidatesInRound.length} actifs)`);
                console.log(`üìä D√©tail statuts:`, candidatesInRound.map(c => `${c.name}(${c.status})`).join(', '));
                
                if (activeCandidatesInRound.length === 0) {
                    await customAlert(`Aucun candidat actif trouv√© pour le tour "${roundName}".\n\nV√©rifiez que:\n- Des candidats existent\n- Ils sont assign√©s au tour "${roundName}"\n- Leur statut est "Actif" ou "Reset"`);
                    if (wasListenerActive) {
                        isFirstSnapshot = true;
                        setupScoresListener();
                    }
                    return;
                }
                
                // Charger les jurys
                await loadJuries();
                
                // Filtrer les jurys pr√©sents sur le tour actif
                const juriesOnActiveRound = JURIES.filter(jury => {
                    return jury.rounds && jury.rounds.includes(activeRoundId);
                });
                console.log(`üë• Jurys charg√©s: ${JURIES.length}, pr√©sents sur le tour actif: ${juriesOnActiveRound.length}`);
                console.log(`üë• D√©tail des jurys pr√©sents:`, juriesOnActiveRound.map(j => `${j.name} (id=${j.id})`).join(', '));
                
                if (juriesOnActiveRound.length === 0) {
                    await customAlert(`Aucun jury n'est configur√© pour √™tre pr√©sent sur le tour "${roundName}".\n\nVeuillez d'abord configurer les tours de pr√©sence des jurys dans l'onglet 'Jury'.`);
                    if (wasListenerActive) {
                        isFirstSnapshot = true;
                        setupScoresListener();
                    }
                    return;
                }
                
                // Charger tous les scores existants pour ce tour en UNE SEULE requ√™te
                const existingScoresQuery = query(
                    collection(db, "scores"),
                    where("roundId", "==", activeRoundId)
                );
                const existingScoresSnap = await getDocs(existingScoresQuery);
                const existingScoresSet = new Set();
                existingScoresSnap.forEach(docSnap => {
                    const data = docSnap.data();
                    existingScoresSet.add(`${data.candidateId}_${data.juryId}`);
                });
                console.log(`üìä Scores existants dans ce tour: ${existingScoresSet.size}`);
                
                // Pr√©parer les scores √† cr√©er en batch
                const batch = writeBatch(db);
                let scoresCreated = 0;
                let scoresSkipped = 0;
                const qualifiedCandidates = [];
                let eliminatedCount = 0;
                
                // Fonction pour g√©n√©rer une note al√©atoire (5, 10, 15 ou 20)
                const randomScore = () => {
                    const scores = [5, 10, 15, 20];
                    return scores[Math.floor(Math.random() * scores.length)];
                };
                
                // S√©lectionner environ 15% des candidats pour recevoir des notes "EL"
                const eliminationRate = 0.15;
                const eliminatedCandidateIds = new Set();
                const candidateCount = activeCandidatesInRound.length;
                const eliminationCount = Math.floor(candidateCount * eliminationRate);
                
                // M√©langer et s√©lectionner al√©atoirement les candidats qui recevront des "EL"
                const shuffledCandidates = [...activeCandidatesInRound].sort(() => Math.random() - 0.5);
                for (let i = 0; i < eliminationCount && i < shuffledCandidates.length; i++) {
                    eliminatedCandidateIds.add(shuffledCandidates[i].id);
                }
                
                console.log(`üé≤ ${eliminationCount} candidat(s) (${Math.round(eliminationRate * 100)}%) recevront des notes "EL":`, Array.from(eliminatedCandidateIds));
                
                for (const candidate of activeCandidatesInRound) {
                    let candidateHasAllScores = true;
                    
                    for (const jury of juriesOnActiveRound) {
                        const key = `${candidate.id}_${jury.id}`;
                        
                        // V√©rifier si le score existe d√©j√†
                        if (existingScoresSet.has(key)) {
                            scoresSkipped++;
                            console.log(`‚è≠Ô∏è Score existant ignor√©: candidateId=${candidate.id}, juryId=${jury.id}`);
                        } else {
                            // Cr√©er une r√©f√©rence de document avec un nouvel ID auto-g√©n√©r√©
                            const newScoreRef = doc(collection(db, "scores"));
                            
                            // D√©terminer si ce candidat fait partie des candidats s√©lectionn√©s pour √©limination
                            let score1, score2;
                            if (eliminatedCandidateIds.has(candidate.id)) {
                                // Ce candidat re√ßoit des notes "EL" de ce jury
                                // 70% du temps : EL pour score1 (Fond) uniquement
                                // 30% du temps : EL pour les deux scores
                                if (Math.random() < 0.7) {
                                    score1 = 'EL';
                                    score2 = randomScore();
                                } else {
                                    score1 = 'EL';
                                    score2 = 'EL';
                                }
                            } else {
                                // Candidat normal : notes al√©atoires
                                score1 = randomScore();
                                score2 = randomScore();
                            }
                            
                            const scoreData = {
                                juryId: jury.id,
                                juryName: jury.name,
                                candidateId: candidate.id,
                                roundId: activeRoundId,
                                score1: score1,
                                score2: score2,
                                timestamp: new Date()
                            };
                            batch.set(newScoreRef, scoreData);
                            scoresCreated++;
                            console.log(`‚ûï Ajout au batch: ${jury.name} ‚Üí ${candidate.name} (${score1}, ${score2})`);
                            candidateHasAllScores = false; // Au moins un nouveau score cr√©√©
                        }
                    }


                    
                }
                
                // Ex√©cuter le batch en UNE SEULE op√©ration
                console.log(`üíæ Tentative de cr√©ation de ${scoresCreated} scores en batch...`);
                if (scoresCreated > 0) {
                    try {
                        await batch.commit();
                        console.log(`‚úÖ Batch ex√©cut√© avec succ√®s ! ${scoresCreated} scores cr√©√©s.`);
                    } catch (batchError) {
                        console.error('‚ùå Erreur lors du commit du batch:', batchError);
                        throw new Error(`Erreur batch: ${batchError.message}`);
                    }
                } else {
                    console.log('‚ÑπÔ∏è Aucun score √† cr√©er (tous existent d√©j√†)');
                }
                
                // Recharger tous les scores apr√®s le commit pour calculer les scores totaux
                console.log('üìä Calcul des scores totaux pour le classement...');
                const allScoresQuery = query(
                    collection(db, "scores"),
                    where("roundId", "==", activeRoundId)
                );
                const allScoresSnap = await getDocs(allScoresQuery);
                
                // Organiser les scores par candidat et jury
                const scoresByCandidate = {};
                allScoresSnap.forEach(docSnap => {
                    const data = docSnap.data();
                    if (!scoresByCandidate[data.candidateId]) {
                        scoresByCandidate[data.candidateId] = {};
                    }
                    const juryId = data.juryId || data.juryName;
                    scoresByCandidate[data.candidateId][juryId] = {
                        score1: data.score1,
                        score2: data.score2
                    };
                });
                
                // Calculer le score total de chaque candidat
                const candidateScores = [];
                for (const candidate of activeCandidatesInRound) {
                    const candidateScoreData = scoresByCandidate[candidate.id] || {};
                    let totalScore = 0;
                    let hasAllScores = true;
                    
                    for (const jury of juriesOnActiveRound) {
                        const scores = candidateScoreData[jury.id];
                        if (!scores || 
                            !scores.score1 || scores.score1 === '-' ||
                            !scores.score2 || scores.score2 === '-') {
                            hasAllScores = false;
                            break;
                        }
                        
                        // Calculer le score (EL = 0)
                        if (scores.score1 === 'EL' || scores.score2 === 'EL') {
                            totalScore += 0;
                        } else {
                            const s1 = parseFloat(scores.score1) || 0;
                            const s2 = parseFloat(scores.score2) || 0;
                            totalScore += (s1 * 3 + s2);
                        }
                    }
                    
                    if (hasAllScores) {
                        candidateScores.push({
                            id: candidate.id,
                            name: candidate.name,
                            totalScore: totalScore
                        });
                    }
                }
                
                // Trier par score d√©croissant
                candidateScores.sort((a, b) => b.totalScore - a.totalScore);
                
                // D√©terminer le nombre de candidats √† qualifier selon nextRoundCandidates
                let qualifyCount;
                if (activeRound.nextRoundCandidates === 'ALL') {
                    qualifyCount = candidateScores.length;
                } else {
                    qualifyCount = parseInt(activeRound.nextRoundCandidates) || candidateScores.length;
                }
                
                console.log(`üìä Classement: ${candidateScores.length} candidats, ${qualifyCount} √† qualifier`);
                
                // Qualifier les N premiers, √©liminer les autres
                let qualifiedCount = 0;
                let eliminatedByRankCount = 0;
                
                candidateScores.forEach((scoreData, index) => {
                    const candidateIndex = allCandidates.findIndex(c => c.id === scoreData.id);
                    if (candidateIndex >= 0) {
                        if (index < qualifyCount) {
                            allCandidates[candidateIndex].status = 'Qualifie';
                            qualifiedCandidates.push(scoreData.id);
                            qualifiedCount++;
                            console.log(`  ‚úì ${scoreData.name}: ${scoreData.totalScore} pts ‚Üí Qualifi√© (rang ${index + 1})`);
                        } else {
                            allCandidates[candidateIndex].status = 'Elimine';
                            eliminatedByRankCount++;
                            console.log(`  ‚úó ${scoreData.name}: ${scoreData.totalScore} pts ‚Üí √âlimin√© (rang ${index + 1})`);
                        }
                    }
                });
                
                // Sauvegarder les candidats mis √† jour
                await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: allCandidates });
                console.log(`üíæ ${qualifiedCount} qualifi√©(s), ${eliminatedByRankCount} √©limin√©(s) par classement`);
                
                // Mettre √† jour le compteur d'√©limin√©s
                eliminatedCount = eliminatedByRankCount;
                
                const qualifyLimit = activeRound.nextRoundCandidates === 'ALL' ? 'Tous' : activeRound.nextRoundCandidates;
                let message = `‚úì Auto-remplissage termin√© !\n\n`;
                message += `üìä ${scoresCreated} note(s) de test cr√©√©e(s)\n`;
                message += `üèÜ Limite tour suivant: ${qualifyLimit} candidat(s)\n`;
                message += `‚úÖ ${qualifiedCandidates.length} candidat(s) qualifi√©(s) (top ${qualifiedCandidates.length})\n`;
                message += `‚ùå ${eliminatedCount} candidat(s) √©limin√©(s) par classement`;
                if (scoresSkipped > 0) {
                    message += `\n‚ö†Ô∏è ${scoresSkipped} note(s) d√©j√† existante(s) (conserv√©e(s))`;
                }
                
                // Afficher un r√©sum√© d√©taill√© dans la console
                console.log(`
üìä R√©sum√© de l'auto-remplissage:
   - Candidats actifs trouv√©s: ${activeCandidatesInRound.length}
   - Jurys pr√©sents sur ce tour: ${juriesOnActiveRound.length}
   - Scores cr√©√©s: ${scoresCreated}
   - Scores ignor√©s (existants): ${scoresSkipped}
   - Limite pour le tour suivant: ${qualifyLimit}
   - Candidats qualifi√©s: ${qualifiedCandidates.length}
   - Candidats √©limin√©s par classement: ${eliminatedCount}
   - R√®gle: si un jury met "EL", sa contribution = 0 (les autres jurys comptent normalement)
   - Op√©ration en batch: OUI ‚úÖ
                `);
                
                // Attendre un petit d√©lai pour s'assurer que Firestore a propag√© les changements
                console.log('‚è≥ Attente de la propagation Firestore...');
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Forcer le rechargement complet des candidats depuis Firestore
                console.log('üì• Rechargement des candidats depuis Firestore...');
                const refreshedDoc = await getDoc(doc(db, "candidats", "liste_actuelle"));
                if (refreshedDoc.exists()) {
                    CANDIDATES = refreshedDoc.data().candidates || [];
                    console.log(`‚úÖ ${CANDIDATES.length} candidats recharg√©s`);
                }
                
                // S'assurer que le dropdown des notes affiche le tour actif
                notesDisplayRound = activeRoundId;
                populateNotesRoundDropdown();
                
                // Rafra√Æchir l'affichage UNE SEULE FOIS AVANT de r√©activer le listener
                await loadList();
                console.log('üîÑ Rafra√Æchissement du tableau des notes...');
                await renderNotesTable();
                
                await customAlert(message);
                
                // R√©activer le listener APR√àS avoir rafra√Æchi l'affichage
                if (wasListenerActive) {
                    console.log('‚ñ∂Ô∏è R√©activation du listener...');
                    isFirstSnapshot = true; // R√©initialiser le flag pour ignorer le premier snapshot
                    setupScoresListener();
                }
            } catch (e) {
                console.error('‚ùå Erreur:', e);
                // R√©activer le listener en cas d'erreur
                if (!scoresListener) {
                    isFirstSnapshot = true;
                    setupScoresListener();
                }
                await customAlert('‚ùå Erreur lors de l\'auto-remplissage:\n' + e.message);
            }
        };

        /** Remplit tous les scores (tous tours, jurys, candidats) et g√©n√®re les classements globaux (pas par jury) comme en temps normal ‚Äî pour tests. */
        window.fillAllScoresAndBonusesRandomly = async function() {
            try {
                if (!await customConfirm('Remplir TOUS les scores avec des valeurs al√©atoires et g√©n√©rer les classements (comme les classements globaux, pas par jury) ?\n\n‚ö†Ô∏è Tous les tours, tous les jurys, tous les candidats seront concern√©s.\nR√©serv√© aux tests.\n\nContinuer ?')) return;

                await loadList();
                await loadJuries();
                const roundsSnap = await getDoc(doc(db, "config", "rounds"));
                const rounds = roundsSnap.exists() ? (roundsSnap.data().rounds || []) : [];
                if (CANDIDATES.length === 0 || JURIES.length === 0) {
                    await customAlert('Chargement candidats ou jurys : aucun candidat ou jury trouv√©.');
                    return;
                }

                const randomScore = () => [5, 10, 15, 20][Math.floor(Math.random() * 4)];
                const existingScoresSnap = await getDocs(collection(db, "scores"));
                const scoreDocByKey = {};
                existingScoresSnap.forEach(d => {
                    const data = d.data();
                    scoreDocByKey[`${data.candidateId}_${data.juryId}_${data.roundId}`] = d.id;
                });

                let written = 0;
                const BATCH_SIZE = 500;
                let batch = writeBatch(db);
                let batchCount = 0;

                for (const round of rounds) {
                    const roundId = round.id;
                    const isRepechage = (round.type || '').toLowerCase().includes('rep√™chage') || (round.type || '').toLowerCase().includes('repechage');
                    const juriesOnRound = JURIES.filter(j => j.rounds && j.rounds.includes(roundId));
                    const candidatesOnRound = CANDIDATES.filter(c => c.tour === roundId);
                    for (const candidate of candidatesOnRound) {
                        for (const jury of juriesOnRound) {
                            const key = `${candidate.id}_${jury.id}_${roundId}`;
                            let score1, score2;
                            if (isRepechage) {
                                score1 = Math.random() < 0.5 ? '0' : '1';
                                score2 = score1;
                            } else {
                                score1 = String(randomScore());
                                score2 = String(randomScore());
                            }
                            const score_base = computeScoreBase(score1, score2, roundId);
                            const data = {
                                juryId: jury.id,
                                juryName: jury.name || jury.id,
                                candidateId: candidate.id,
                                roundId,
                                score1,
                                score2,
                                score_base,
                                timestamp: new Date()
                            };
                            const docId = scoreDocByKey[key];
                            if (docId) {
                                batch.update(doc(db, "scores", docId), data);
                            } else {
                                batch.set(doc(collection(db, "scores")), data);
                            }
                            batchCount++;
                            written++;
                            if (batchCount >= BATCH_SIZE) {
                                await batch.commit();
                                batch = writeBatch(db);
                                batchCount = 0;
                            }
                        }
                    }
                }
                if (batchCount > 0) await batch.commit();

                for (const round of rounds) {
                    const roundId = round.id;
                    const isNotationOrDuels = (round.type === 'Notation individuelle' || round.type === 'Duels' || (round.type_epreuve && (round.type_epreuve === 'notation' || round.type_epreuve === 'duels')));
                    if (isNotationOrDuels) {
                        try {
                            await syncClassementFromScores(roundId);
                        } catch (e) {
                            console.warn('syncClassementFromScores', roundId, e);
                        }
                    }
                }

                const POSITION_LABELS_FILL = ['1', '2', '3', '4', '5'];
                let juryRankingsWritten = 0;
                for (const round of rounds) {
                    const roundId = round.id;
                    const juriesOnRound = JURIES.filter(j => j.rounds && j.rounds.includes(roundId));
                    const candidatesOnRound = CANDIDATES.filter(c => c.tour === roundId);
                    if (candidatesOnRound.length === 0) continue;
                    for (const jury of juriesOnRound) {
                        const shuffled = [...candidatesOnRound].sort(() => Math.random() - 0.5);
                        const positions = {};
                        POSITION_LABELS_FILL.forEach((posLabel, i) => {
                            if (shuffled[i]) positions[posLabel] = shuffled[i].id;
                        });
                        await setDoc(doc(db, "jury_rankings", jury.id + '_' + roundId), {
                            juryId: jury.id,
                            roundId,
                            positions,
                            updatedAt: new Date()
                        });
                        juryRankingsWritten++;
                    }
                }

                await loadList();
                await renderNotesTable();
                await customAlert('‚úì Termin√©.\n\n' + written + ' score(s) mis √† jour / cr√©√©(s).\nClassements globaux g√©n√©r√©s.\n' + juryRankingsWritten + ' ¬´ Mon classement ¬ª (jury_rankings) g√©n√©r√©(s) pour l\'activation classements.');
            } catch (e) {
                console.error(e);
                await customAlert('‚ùå Erreur : ' + (e.message || e));
            }
        };

        window.confirmResetScores = async () => {
            if(!await customConfirm("Supprimer TOUTES les notes (les candidats et jurys seront conserv√©s) ?")) return;
            
            try {
                const snap = await getDocs(collection(db, "scores"));
                const batch = writeBatch(db);
                snap.docs.forEach(d => batch.delete(d.ref));
                await batch.commit();
                
                // R√©initialiser les verrous
                await setDoc(doc(db, "config", "locks"), { locks: {} });
                candidateLocks = {};
                
                await customAlert('‚úì Toutes les notes ont √©t√© supprim√©es');
                location.reload();
            } catch (e) {
                console.error('Erreur:', e);
                await customAlert('‚ùå Erreur lors de la r√©initialisation:\n' + e.message);
            }
        };
        
        window.confirmResetRoundsToDefault = async () => {
            if (!await customConfirm(`Remettre les tours √† la configuration par d√©faut ?\n\n‚ö†Ô∏è Ceci va r√©initialiser la structure des tours (6 tours standards).\n\n‚úÖ Les notes et candidats seront conserv√©s.\n\nContinuer ?`)) {
                return;
            }
            
            try {
                // Cr√©er la configuration par d√©faut des tours
                const defaultRounds = [
                    { id: 'round1', order: 1, name: '1er tour', type: 'Notation individuelle', type_epreuve: 'notation', nextRoundCandidates: 'ALL', active: true },
                    { id: 'round2', order: 2, name: 'Repechage 1er tour', type: 'Rep√™chage', type_epreuve: 'repechage', nextRoundCandidates: 18, active: false },
                    { id: 'round3', order: 3, name: '2eme tour', type: 'Duels', type_epreuve: 'duels', nextRoundCandidates: 'ALL', active: false },
                    { id: 'round4', order: 4, name: 'Repechage 2eme tour', type: 'Rep√™chage', type_epreuve: 'repechage', nextRoundCandidates: 7, active: false },
                    { id: 'round5', order: 5, name: 'Demi-finale', type: 'Duels', type_epreuve: 'duels', nextRoundCandidates: 3, active: false },
                    { id: 'round6', order: 6, name: 'Finale', type: 'Duels', type_epreuve: 'duels', nextRoundCandidates: 1, active: false }
                ];
                
                // Sauvegarder la configuration par d√©faut
                await setDoc(doc(db, "config", "rounds"), { 
                    rounds: defaultRounds,
                    activeRoundId: 'round1'
                });
                
                // Mettre √† jour les variables locales
                ROUNDS = defaultRounds;
                activeRoundId = 'round1';
                
                console.log('‚úÖ Tours r√©initialis√©s aux valeurs par d√©faut');
                
                await customAlert('‚úì Tours r√©initialis√©s avec succ√®s !\n\n6 tours cr√©√©s :\n- 1er tour (Notation individuelle)\n- Rep√™chage 1er tour\n- 2√®me tour (Duels)\n- Rep√™chage 2√®me tour\n- Demi-finale\n- Finale');
                
                // Recharger la page pour actualiser tout
                location.reload();
            } catch (e) {
                console.error('‚ùå Erreur:', e);
                await customAlert('‚ùå Erreur lors de la r√©initialisation des tours:\n' + e.message);
            }
        };

        window.confirmResetActiveRound = async () => {
            try {
                // V√©rifier qu'il y a un tour actif
                if (!activeRoundId) {
                    await customAlert("Aucun tour actif d√©fini. Veuillez s√©lectionner un tour actif dans l'onglet 'Tours'.");
                    return;
                }
                
                // Trouver le nom du tour actif
                const activeRound = ROUNDS.find(r => r.id === activeRoundId);
                const roundName = activeRound ? activeRound.name : activeRoundId;
                
                if (!await customConfirm(`R√©initialiser le tour "${roundName}" ?\n\n‚ö†Ô∏è Ceci va :\n- Supprimer toutes les notes des candidats de ce tour\n- Remettre leur statut √† "Actif"\n\nCette action est IRR√âVERSIBLE !`)) {
                    return;
                }
                
                console.log(`üîÑ R√©initialisation du tour: ${roundName} (${activeRoundId})`);
                
                // Charger les candidats
                const candidatesDoc = await getDoc(doc(db, "candidats", "liste_actuelle"));
                if (!candidatesDoc.exists()) {
                    await customAlert("Aucun candidat trouv√©");
                    return;
                }
                
                const allCandidates = candidatesDoc.data().candidates || [];
                
                // Filtrer les candidats du tour en cours
                const candidatesInRound = allCandidates.filter(c => c.tour === activeRoundId);
                console.log(`üìã Candidats du tour "${roundName}": ${candidatesInRound.length}`);
                
                if (candidatesInRound.length === 0) {
                    await customAlert(`Aucun candidat trouv√© pour le tour "${roundName}".`);
                    return;
                }
                
                // R√©cup√©rer tous les scores de ce tour
                const scoresQuery = query(
                    collection(db, "scores"),
                    where("roundId", "==", activeRoundId)
                );
                const scoresSnap = await getDocs(scoresQuery);
                console.log(`üìä Scores √† supprimer: ${scoresSnap.size}`);
                
                // Supprimer les scores en batch
                const batch = writeBatch(db);
                scoresSnap.docs.forEach(docSnap => {
                    batch.delete(docSnap.ref);
                });
                
                // Mettre √† jour les statuts des candidats √† "Actif"
                let candidatesReset = 0;
                for (const candidate of candidatesInRound) {
                    const candidateIndex = allCandidates.findIndex(c => c.id === candidate.id);
                    if (candidateIndex >= 0) {
                        allCandidates[candidateIndex].status = 'Actif';
                        candidatesReset++;
                    }
                }
                
                // Ex√©cuter le batch
                await batch.commit();
                console.log(`‚úÖ ${scoresSnap.size} score(s) supprim√©(s)`);
                
                // Sauvegarder les candidats mis √† jour
                await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: allCandidates });
                console.log(`‚úÖ ${candidatesReset} candidat(s) remis √† "Actif"`);
                
                // Supprimer les verrous pour ce tour
                if (candidateLocks) {
                    for (const candidateId of candidatesInRound.map(c => c.id)) {
                        delete candidateLocks[candidateId];
                    }
                    await setDoc(doc(db, "config", "locks"), { locks: candidateLocks });
                }
                
                // Retirer la validation globale du tour (verrouillage d√©finitif annul√©)
                if (validatedRounds[activeRoundId]) {
                    delete validatedRounds[activeRoundId];
                    await setDoc(doc(db, "config", "validated_rounds"), { rounds: validatedRounds });
                }
                
                await customAlert(`‚úì Tour "${roundName}" r√©initialis√© !\n\nüìä ${scoresSnap.size} note(s) supprim√©e(s)\n‚úÖ ${candidatesReset} candidat(s) remis √† "Actif"`);
                
                // Rafra√Æchir l'affichage
                CANDIDATES = allCandidates;
                await loadList();
                await renderNotesTable();
            } catch (e) {
                console.error('‚ùå Erreur:', e);
                await customAlert('‚ùå Erreur lors de la r√©initialisation du tour:\n' + e.message);
            }
        };

        window.qualifyCandidatesOfRound = async () => {
            try {
                // V√©rifier qu'il y a un tour actif
                if (!activeRoundId) {
                    await customAlert("Aucun tour actif d√©fini. Veuillez s√©lectionner un tour actif dans l'onglet 'Tours'.");
                    return;
                }
                
                // Trouver le tour actif
                const activeRound = ROUNDS.find(r => r.id === activeRoundId);
                if (!activeRound) {
                    await customAlert("Tour actif non trouv√© dans la configuration.");
                    return;
                }
                
                const roundName = activeRound.name;
                
                // Charger les jurys pr√©sents sur ce tour
                await loadJuries();
                const juriesOnRound = JURIES.filter(j => j.rounds && j.rounds.includes(activeRoundId));
                if (juriesOnRound.length === 0) {
                    await customAlert("Aucun jury pr√©sent sur ce tour.");
                    return;
                }
                
                // Filtrer les candidats actifs du tour
                const candidatesInRound = CANDIDATES.filter(c => c.tour === activeRoundId && c.status === 'Actif');
                if (candidatesInRound.length === 0) {
                    await customAlert(`Aucun candidat actif sur le tour "${roundName}".`);
                    return;
                }
                
                // Charger tous les scores du tour actif
                const scoresQuery = query(
                    collection(db, "scores"),
                    where("roundId", "==", activeRoundId)
                );
                const scoresSnap = await getDocs(scoresQuery);
                
                // Organiser les scores par candidat et jury
                const scoresByCandidate = {};
                scoresSnap.forEach(docSnap => {
                    const data = docSnap.data();
                    if (!scoresByCandidate[data.candidateId]) {
                        scoresByCandidate[data.candidateId] = {};
                    }
                    const juryId = data.juryId || data.juryName;
                    scoresByCandidate[data.candidateId][juryId] = {
                        score1: data.score1,
                        score2: data.score2
                    };
                });
                
                // Calculer les scores totaux pour chaque candidat
                const candidateScores = [];
                let incompleteCount = 0;
                
                for (const c of candidatesInRound) {
                    const candidateScoreData = scoresByCandidate[c.id] || {};
                    let isComplete = true;
                    let totalScore = 0;
                    
                    for (const jury of juriesOnRound) {
                        const scores = candidateScoreData[jury.id];
                        if (!scores || 
                            !scores.score1 || scores.score1 === '-' ||
                            !scores.score2 || scores.score2 === '-') {
                            isComplete = false;
                            incompleteCount++;
                            break;
                        }
                        
                        // Calculer le score (EL = 0)
                        if (scores.score1 === 'EL' || scores.score2 === 'EL') {
                            totalScore += 0;
                        } else {
                            const s1 = parseFloat(scores.score1) || 0;
                            const s2 = parseFloat(scores.score2) || 0;
                            totalScore += (s1 * 3 + s2);
                        }
                    }
                    
                    candidateScores.push({
                        id: c.id,
                        name: c.name,
                        totalScore: totalScore,
                        isComplete: isComplete
                    });
                }
                
                // Avertir si des notes sont incompl√®tes
                const completeCount = candidateScores.filter(c => c.isComplete).length;
                
                // D√©terminer le nombre de candidats √† qualifier
                let qualifyCount;
                if (activeRound.nextRoundCandidates === 'ALL') {
                    qualifyCount = candidateScores.length;
                } else {
                    qualifyCount = parseInt(activeRound.nextRoundCandidates) || candidateScores.length;
                }
                
                // Confirmation
                const confirmMsg = `Qualifier les candidats du tour "${roundName}" ?\n\n` +
                    `üìã ${candidateScores.length} candidat(s) actif(s)\n` +
                    `‚úÖ ${completeCount} candidat(s) avec notes compl√®tes\n` +
                    `‚ö†Ô∏è ${incompleteCount > 0 ? incompleteCount + ' candidat(s) avec notes incompl√®tes' : 'Tous les candidats ont des notes'}\n\n` +
                    `üèÜ ${qualifyCount} candidat(s) seront qualifi√©(s)\n` +
                    `‚ùå ${Math.max(0, candidateScores.length - qualifyCount)} candidat(s) seront √©limin√©(s)\n\n` +
                    `Continuer ?`;
                
                if (!await customConfirm(confirmMsg)) {
                    return;
                }
                
                // Trier par score d√©croissant
                candidateScores.sort((a, b) => b.totalScore - a.totalScore);
                
                console.log(`üìä Classement des ${candidateScores.length} candidats:`);
                candidateScores.forEach((c, idx) => {
                    console.log(`  ${idx + 1}. ${c.name}: ${c.totalScore} pts ${c.isComplete ? '‚úì' : '‚ö†Ô∏è'}`);
                });
                
                // Qualifier les N premiers, √©liminer les autres
                let qualifiedCount = 0;
                let eliminatedCount = 0;
                
                candidateScores.forEach((scoreData, index) => {
                    const c = CANDIDATES.find(cand => cand.id === scoreData.id);
                    if (c) {
                        if (index < qualifyCount) {
                            c.status = 'Qualifie';
                            qualifiedCount++;
                            console.log(`  ‚úì ${c.name}: ${scoreData.totalScore} pts ‚Üí Qualifi√© (rang ${index + 1})`);
                        } else {
                            c.status = 'Elimine';
                            eliminatedCount++;
                            console.log(`  ‚úó ${c.name}: ${scoreData.totalScore} pts ‚Üí √âlimin√© (rang ${index + 1})`);
                        }
                    }
                });
                
                // Sauvegarder les candidats
                await saveCandidates();
                
                await customAlert(`‚úÖ Qualification termin√©e !\n\nüèÜ ${qualifiedCount} candidat(s) qualifi√©(s)\n‚ùå ${eliminatedCount} candidat(s) √©limin√©(s)`);
                
                // Rafra√Æchir l'affichage
                await renderNotesTable();
                await loadResults();
                
            } catch (e) {
                console.error('‚ùå Erreur:', e);
                await customAlert('‚ùå Erreur lors de la qualification:\n' + e.message);
            }
        };

        window.confirmDeleteAllDuels = async () => {
            if (!await customConfirm('Supprimer tous les duels (tous les tours) ?\n\nLes jurys, candidats et notes sont conserv√©s. Seuls les duels cr√©√©s seront supprim√©s.\n\nContinuer ?')) {
                return;
            }
            try {
                const duelSnap = await getDocs(collection(db, "duel_results"));
                const n = duelSnap.size;
                if (n === 0) {
                    await customAlert('Aucun duel √† supprimer.');
                    return;
                }
                const batch = writeBatch(db);
                duelSnap.docs.forEach(d => batch.delete(d.ref));
                await batch.commit();
                duelsList = [];
                if (document.getElementById('duels-empty-msg')) document.getElementById('duels-empty-msg').style.display = 'block';
                if (document.getElementById('duels-list')) document.getElementById('duels-list').style.display = 'none';
                await customAlert(`‚úì ${n} duel(s) supprim√©(s).`);
                loadDuelsData();
            } catch (e) {
                console.error('Erreur:', e);
                await customAlert('‚ùå Erreur lors de la suppression des duels:\n' + e.message);
            }
        };

        window.confirmDeleteAllClassementPoints = async () => {
            if (!await customConfirm('Supprimer tous les points de classement ?\n\n- Tous les classements des jurys (Mon classement) seront effac√©s\n- Les scores du classement seront remis √† la base (sans les points activ√©s)\n- La liste des candidats reste affich√©e pour r√©activer ensuite\n\nLes jurys, candidats, notes et duels sont conserv√©s.\n\nContinuer ?')) {
                return;
            }
            try {
                let count = 0;
                const juryRankingsSnap = await getDocs(collection(db, "jury_rankings"));
                if (juryRankingsSnap.size > 0) {
                    const batch = writeBatch(db);
                    juryRankingsSnap.docs.forEach(d => { batch.delete(d.ref); count++; });
                    await batch.commit();
                }
                const classementsSnap = await getDocs(collection(db, "classements"));
                for (const docSnap of classementsSnap.docs) {
                    const data = docSnap.data();
                    let entries = data.entries || [];
                    if (entries.length > 0) {
                        entries = entries.map(e => {
                            const base = e.score_base != null ? (typeof e.score_base === 'number' ? e.score_base : parseFloat(e.score_base) || 0) : 0;
                            return { ...e, score_appliqu√©: base, score_affich√©: base };
                        });
                        entries.sort((a, b) => (b.score_appliqu√© ?? b.score_affich√© ?? 0) - (a.score_appliqu√© ?? a.score_affich√© ?? 0));
                        entries.forEach((e, i) => { e.rank = i + 1; });
                        await setDoc(docSnap.ref, { ...data, entries, lastUpdateSource: 'admin_reset_classement_points', updatedAt: new Date() }, { merge: true });
                    } else {
                        const firstRoundId = ROUNDS.length ? [...ROUNDS].sort((a, b) => (a.order || 0) - (b.order || 0))[0].id : null;
                        const roundId = data.code || (docSnap.id.startsWith('classement_') ? docSnap.id.replace(/^classement_/, '') : null) || activationClassementRoundId || document.getElementById('activation-classement-round')?.value || firstRoundId;
                        if (roundId) {
                        const scoresQuery = query(collection(db, "scores"), where("roundId", "==", roundId));
                        const scoresSnap = await getDocs(scoresQuery);
                        const totalBaseByCandidate = {};
                        scoresSnap.forEach(d => {
                            const sd = d.data();
                            const cid = sd.candidateId;
                            const base = sd.score_base != null ? sd.score_base : 0;
                            totalBaseByCandidate[cid] = (totalBaseByCandidate[cid] || 0) + base;
                        });
                        const candidatesSnap = await getDoc(doc(db, "candidats", "liste_actuelle"));
                        const allCandidates = candidatesSnap.exists() ? (candidatesSnap.data().candidates || []) : [];
                        let roundCandidates = allCandidates.filter(c => (c.tour || '') === roundId);
                        if (roundCandidates.length === 0) roundCandidates = allCandidates;
                        const withScore = roundCandidates.map(c => ({
                            candidateId: c.id,
                            name: c.name,
                            score_base: totalBaseByCandidate[c.id] || 0
                        }));
                        withScore.sort((a, b) => b.score_base - a.score_base);
                        entries = withScore.map((x, i) => ({
                            rank: i + 1,
                            candidateId: x.candidateId,
                            name: x.name,
                            score_base: x.score_base,
                            score_appliqu√©: x.score_base,
                            score_affich√©: x.score_base
                        }));
                        if (entries.length > 0) {
                            await setDoc(docSnap.ref, { ...data, entries, code: roundId, lastUpdateSource: 'admin_reset_classement_points', updatedAt: new Date() }, { merge: true });
                        }
                        }
                    }
                    count++;
                }
                const activationsSnap = await getDocs(collection(db, "classement_activations"));
                const batch2 = writeBatch(db);
                activationsSnap.docs.forEach(d => { batch2.delete(d.ref); count++; });
                if (activationsSnap.size > 0) await batch2.commit();
                await customAlert('‚úì Points de classement supprim√©s.\n\nScores remis √† la base, liste des candidats conserv√©e. ' + (count > 0 ? count + ' √©l√©ment(s) r√©initialis√©(s).' : ''));
                if (typeof loadActivationClassementsData === 'function') loadActivationClassementsData();
            } catch (e) {
                console.error('Erreur:', e);
                await customAlert('‚ùå Erreur lors de la suppression des points de classement:\n' + e.message);
            }
        };

        /** Supprime toutes les notes et tout ce qui s'affiche dans le classement : scores, entries classement, activations, Mon classement jurys, gagnants duels. Tout devra √™tre rentr√© √† nouveau. */
        window.confirmClearAllNotesAndClassement = async () => {
            if (!await customConfirm('‚ö†Ô∏è Vider TOUT le classement (notes et bonus) ?\n\n‚ùå Toutes les notes (scores) seront supprim√©es\n‚ùå Tous les classements affich√©s seront vid√©s\n‚ùå Tous les points activ√©s et ¬´ Mon classement ¬ª des jurys seront effac√©s\n‚ùå Les gagnants des duels seront remis √† ¬´ non renseign√© ¬ª\n\n‚úÖ Les jurys et la liste des candidats sont conserv√©s.\n\nIl faudra tout rentrer √† nouveau. Cette action est IRR√âVERSIBLE !\n\nContinuer ?')) {
                return;
            }
            try {
                let scoresDeleted = 0;
                const scoresSnap = await getDocs(collection(db, "scores"));
                const BATCH_SIZE = 500;
                for (let i = 0; i < scoresSnap.docs.length; i += BATCH_SIZE) {
                    const batch = writeBatch(db);
                    scoresSnap.docs.slice(i, i + BATCH_SIZE).forEach(d => { batch.delete(d.ref); scoresDeleted++; });
                    await batch.commit();
                }
                const classementsSnap = await getDocs(collection(db, "classements"));
                for (const docSnap of classementsSnap.docs) {
                    const data = docSnap.data();
                    await setDoc(docSnap.ref, { ...data, entries: [], duelBonusEnabled: [], lastUpdateSource: 'admin_clear_all_notes_and_classement', updatedAt: new Date() }, { merge: true });
                }
                const activationsSnap = await getDocs(collection(db, "classement_activations"));
                for (const docSnap of activationsSnap.docs) {
                    await setDoc(docSnap.ref, { activated: [], updatedAt: new Date() }, { merge: true });
                }
                const juryRankingsSnap = await getDocs(collection(db, "jury_rankings"));
                for (let i = 0; i < juryRankingsSnap.docs.length; i += BATCH_SIZE) {
                    const batch = writeBatch(db);
                    juryRankingsSnap.docs.slice(i, i + BATCH_SIZE).forEach(d => batch.delete(d.ref));
                    await batch.commit();
                }
                const duelSnap = await getDocs(collection(db, "duel_results"));
                for (const d of duelSnap.docs) {
                    const data = d.data();
                    const currentDuels = data.duels || [];
                    const duels = currentDuels.map(duel => ({ ...duel, winnerId: null }));
                    if (currentDuels.some((x, i) => x && x.winnerId != null)) {
                        await setDoc(d.ref, { ...data, duels, updatedAt: new Date() });
                        if (typeof syncDuelBonusEnabledWithDuelWinners === 'function') await syncDuelBonusEnabledWithDuelWinners(d.id, []);
                    }
                }
                if (typeof loadActivationClassementsData === 'function') loadActivationClassementsData();
                if (typeof loadDuelsData === 'function') loadDuelsData();
                await customAlert('‚úì Tout a √©t√© vid√©.\n\n- ' + scoresDeleted + ' note(s) supprim√©e(s)\n- Classements et points activ√©s effac√©s\n- ¬´ Mon classement ¬ª des jurys effac√©\n- Gagnants des duels r√©initialis√©s\n\nLes jurys et candidats sont conserv√©s. Vous devrez tout rentrer √† nouveau.');
            } catch (e) {
                console.error('Erreur:', e);
                await customAlert('‚ùå Erreur : ' + (e.message || e));
            }
        };

        window.confirmResetDuelWinners = async () => {
            if (!await customConfirm('Supprimer les gagnants de tous les duels ?\n\nLes duels et candidats restent en place. Seuls les gagnants seront effac√©s (boutons repassent en blanc).\n\nContinuer ?')) {
                return;
            }
            try {
                const duelSnap = await getDocs(collection(db, "duel_results"));
                let updated = 0;
                for (const d of duelSnap.docs) {
                    const data = d.data();
                    const currentDuels = data.duels || [];
                    const duels = currentDuels.map(duel => ({ ...duel, winnerId: null }));
                    if (duels.some((x, i) => currentDuels[i] && currentDuels[i].winnerId != null)) {
                        await setDoc(d.ref, { ...data, duels, updatedAt: new Date() });
                        await syncDuelBonusEnabledWithDuelWinners(d.id, []);
                        updated++;
                    }
                }
                await customAlert(updated > 0 ? '‚úì Gagnants des duels supprim√©s.\n\n' + updated + ' tour(s) de duels r√©initialis√©(s).' : 'Aucun gagnant de duel √† supprimer.');
                loadDuelsData();
            } catch (e) {
                console.error('Erreur:', e);
                await customAlert('‚ùå Erreur lors de la suppression des gagnants:\n' + e.message);
            }
        };

        window.confirmResetAllScoresAndRounds = async () => {
            if (!await customConfirm('‚ö†Ô∏è ATTENTION : R√©initialiser tous les scores et tours ?\n\n‚ùå Toutes les notes de tous les tours seront supprim√©es\n‚ùå Tous les duels seront supprim√©s\nüîÑ Tous les candidats seront remis en "Actif" au premier tour\n‚úÖ Les jurys et la liste des candidats seront conserv√©s\n\nCette action est IRR√âVERSIBLE !\n\nContinuer ?')) {
                return;
            }
            
            try {
                console.log('üîÑ R√©initialisation de tous les scores, tours et duels...');
                
                // 1. Supprimer TOUS les scores
                const scoresSnap = await getDocs(collection(db, "scores"));
                console.log(`üìä ${scoresSnap.size} score(s) √† supprimer`);
                
                const batch = writeBatch(db);
                scoresSnap.docs.forEach(docSnap => {
                    batch.delete(docSnap.ref);
                });
                await batch.commit();
                console.log('‚úÖ Tous les scores supprim√©s');
                
                // 1b. Supprimer tous les duels
                const duelSnap = await getDocs(collection(db, "duel_results"));
                if (duelSnap.size > 0) {
                    const batchDuels = writeBatch(db);
                    duelSnap.docs.forEach(d => batchDuels.delete(d.ref));
                    await batchDuels.commit();
                    console.log(`‚úÖ ${duelSnap.size} duel(s) supprim√©(s)`);
                }
                
                // 2. Charger les candidats
                const candidatesDoc = await getDoc(doc(db, "candidats", "liste_actuelle"));
                if (!candidatesDoc.exists()) {
                    await customAlert('Aucun candidat trouv√©');
                    return;
                }
                
                const allCandidates = candidatesDoc.data().candidates || [];
                console.log(`üìã ${allCandidates.length} candidat(s) trouv√©(s)`);
                
                // 3. Trouver le premier tour (par ordre)
                const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
                const firstRound = sortedRounds.length > 0 ? sortedRounds[0] : { id: 'round1' };
                console.log(`üéØ Premier tour : ${firstRound.id} (${firstRound.name || firstRound.id})`);
                
                // 4. Remettre tous les candidats au premier tour en statut "Actif"
                allCandidates.forEach(candidate => {
                    candidate.tour = firstRound.id;
                    candidate.status = 'Actif';
                });
                
                // 5. Sauvegarder les candidats
                await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: allCandidates });
                console.log(`‚úÖ ${allCandidates.length} candidat(s) remis en "Actif" au tour ${firstRound.id}`);
                
                // 6. R√©initialiser le tour actif au premier tour
                ROUNDS.forEach(r => r.active = (r.id === firstRound.id));
                activeRoundId = firstRound.id;
                await saveRounds();
                console.log(`‚úÖ Tour actif r√©initialis√© √† ${firstRound.id}`);
                
                // 7. R√©initialiser les verrous
                await setDoc(doc(db, "config", "locks"), { locks: {} });
                console.log('‚úÖ Verrous r√©initialis√©s');
                
                const duelMsg = duelSnap.size > 0 ? `\n‚ùå ${duelSnap.size} duel(s) supprim√©(s)` : '';
                await customAlert(`‚úì R√©initialisation termin√©e !\n\n‚ùå ${scoresSnap.size} note(s) supprim√©e(s)${duelMsg}\nüîÑ ${allCandidates.length} candidat(s) remis en "Actif" au tour "${firstRound.name || firstRound.id}"\nüéØ Tour actif r√©initialis√© √† "${firstRound.name || firstRound.id}"\n‚úÖ Jurys et candidats conserv√©s`);
                
                // Rafra√Æchir l'affichage
                CANDIDATES = allCandidates;
                duelsList = [];
                await loadList();
                await renderNotesTable();
                loadDuelsData();
            } catch (e) {
                console.error('‚ùå Erreur:', e);
                await customAlert('‚ùå Erreur lors de la r√©initialisation:\n' + e.message);
            }
        };

        window.confirmResetAll = async () => {
            const confirmation = await customPrompt('Pour confirmer la r√©initialisation TOTALE, tapez "RESET":');
            if (confirmation !== 'RESET') {
                await customAlert('R√©initialisation annul√©e');
                return;
            }
            
            try {
                // Supprimer les scores
                const scoresSnap = await getDocs(collection(db, "scores"));
                const batch1 = writeBatch(db);
                scoresSnap.docs.forEach(d => batch1.delete(d.ref));
                await batch1.commit();
                
                // Supprimer tous les duels
                const duelSnap = await getDocs(collection(db, "duel_results"));
                if (duelSnap.size > 0) {
                    const batchDuels = writeBatch(db);
                    duelSnap.docs.forEach(d => batchDuels.delete(d.ref));
                    await batchDuels.commit();
                }

                // Supprimer tous les points de classement (jury_rankings, classements, classement_activations)
                const juryRankingsSnap = await getDocs(collection(db, "jury_rankings"));
                if (juryRankingsSnap.size > 0) {
                    const batchCR = writeBatch(db);
                    juryRankingsSnap.docs.forEach(d => batchCR.delete(d.ref));
                    await batchCR.commit();
                }
                const classementsSnap = await getDocs(collection(db, "classements"));
                for (const d of classementsSnap.docs) {
                    await setDoc(d.ref, { ...d.data(), entries: [], updatedAt: new Date() }, { merge: true });
                }
                const activationsSnap = await getDocs(collection(db, "classement_activations"));
                if (activationsSnap.size > 0) {
                    const batchAct = writeBatch(db);
                    activationsSnap.docs.forEach(d => batchAct.delete(d.ref));
                    await batchAct.commit();
                }
                
                // Supprimer tous les jurys
                const accountsSnap = await getDocs(collection(db, "accounts"));
                const batch2 = writeBatch(db);
                accountsSnap.docs.forEach(d => batch2.delete(d.ref));
                await batch2.commit();
                
                // Supprimer les candidats
                await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: [] });
                
                // R√©initialiser les verrous
                await setDoc(doc(db, "config", "locks"), { locks: {} });
                
                // R√©initialiser le tour actif au premier tour (round1)
                // Recharger les ROUNDS pour √™tre s√ªr d'avoir les donn√©es √† jour
                const roundsDoc = await getDoc(doc(db, "config", "rounds"));
                let firstRoundId = 'round1'; // Valeur par d√©faut
                let loadedRounds = [];
                if (roundsDoc.exists() && roundsDoc.data().rounds) {
                    loadedRounds = roundsDoc.data().rounds;
                    const sortedRounds = [...loadedRounds].sort((a, b) => a.order - b.order);
                    if (sortedRounds.length > 0) {
                        firstRoundId = sortedRounds[0].id;
                    }
                }
                // Le tour actif est stock√© dans config/rounds avec le champ activeRoundId
                await setDoc(doc(db, "config", "rounds"), { 
                    rounds: loadedRounds,
                    activeRoundId: firstRoundId 
                });
                console.log(`‚úÖ Tour actif r√©initialis√© √†: ${firstRoundId}`);
                
                await customAlert('‚úì R√©initialisation compl√®te effectu√©e\n\n- Tous les jurys supprim√©s\n- Tous les candidats supprim√©s\n- Toutes les notations supprim√©es\n- Tous les duels supprim√©s\n- Tous les points de classement supprim√©s\n- Tous les verrous supprim√©s\n- Tour actif remis au premier tour');
                location.reload();
            } catch (e) {
                console.error('Erreur:', e);
                await customAlert('‚ùå Erreur lors de la r√©initialisation:\n' + e.message);
            }
        };

        // Export vers CSV
        // Export des notes en CSV (format √©ditable)
        window.exportNotesToCSV = async () => {
            try {
                // R√©cup√©rer les scores du tour actif
                const q = query(
                    collection(db, "scores"),
                    where("roundId", "==", activeRoundId || 'round1')
                );
                const scoresSnap = await getDocs(q);
                const juries = new Set();
                const scoresByCandidate = {};
                
                scoresSnap.forEach(d => {
                    const data = d.data();
                    juries.add(data.juryName);
                    
                    if (!scoresByCandidate[data.candidateId]) {
                        scoresByCandidate[data.candidateId] = {};
                    }
                    scoresByCandidate[data.candidateId][data.juryName] = data;
                });
                
                const sortedJuries = Array.from(juries).sort();
                
                // Cr√©er l'en-t√™te CSV (avec Tour et Statut)
                let csv = 'CandidatID,CandidatNom,Tour,Statut';
                sortedJuries.forEach(jury => {
                    csv += `,${jury}_Note1,${jury}_Note2`;
                });
                csv += '\n';
                
                // Ajouter les donn√©es
                CANDIDATES.forEach(c => {
                    // Trouver le nom du tour
                    const roundObj = ROUNDS.find(r => r.id === c.tour);
                    const tourName = roundObj ? roundObj.name : (c.tour || '');
                    
                    let row = `${c.id},"${c.name}","${tourName}","${c.status || 'Actif'}"`;
                    
                    sortedJuries.forEach(jury => {
                        const scores = scoresByCandidate[c.id]?.[jury];
                        let note1 = scores?.score1 || '-';
                        let note2 = scores?.score2 || '-';
                        
                        // Remplacer "EL" par "0" dans l'export CSV
                        if (note1 === 'EL') note1 = '0';
                        if (note2 === 'EL') note2 = '0';
                        
                        // Remplacer "-" par case vide dans l'export CSV
                        if (note1 === '-') note1 = '';
                        if (note2 === '-') note2 = '';
                        
                        row += `,${note1},${note2}`;
                    });
                    
                    csv += row + '\n';
                });
                
                // T√©l√©charger
                const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                const date = new Date().toISOString().split('T')[0];
                link.setAttribute('href', url);
                link.setAttribute('download', `notes_${date}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                alert('‚úì Export CSV r√©ussi !');
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de l\'export: ' + e.message);
            }
        };
        
        // Import des notes depuis CSV
        window.importNotesFromCSV = async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!await customConfirm(`‚ö†Ô∏è ATTENTION ‚ö†Ô∏è\n\nImporter depuis CSV va :\n- V√©rifier le format du fichier\n- Mettre √† jour les notes existantes\n- Mettre √† jour le tour et statut des candidats\n- Cr√©er de nouvelles notes si n√©cessaire\n\nLes donn√©es actuelles seront modifi√©es !\n\nContinuer ?`)) {
                event.target.value = '';
                return;
            }
            
            // Afficher un message d'attente
            const loadingOverlay = document.createElement('div');
            loadingOverlay.id = 'import-loading-overlay';
            loadingOverlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 10000;';
            loadingOverlay.innerHTML = `
                <div style="background: var(--card-bg, #2a2a4a); padding: 40px; border-radius: 15px; text-align: center; color: var(--text-color, white);">
                    <div style="font-size: 48px; margin-bottom: 20px;">‚è≥</div>
                    <div style="font-size: 18px; font-weight: 600;">Import en cours...</div>
                    <div id="import-progress" style="margin-top: 15px; font-size: 14px; color: #888;">Pr√©paration...</div>
                </div>
            `;
            document.body.appendChild(loadingOverlay);
            
            const updateProgress = (text) => {
                const progressEl = document.getElementById('import-progress');
                if (progressEl) progressEl.textContent = text;
            };
            
            try {
                updateProgress('Lecture du fichier...');
                const text = await file.text();
                const lines = text.split('\n').filter(l => l.trim());
                
                if (lines.length < 2) {
                    throw new Error('Fichier CSV vide ou invalide');
                }
                
                // Parser l'en-t√™te
                const header = lines[0].split(',').map(h => h.trim());
                
                // V√©rifier le format de base
                if (header[0] !== 'CandidatID' || header[1] !== 'CandidatNom') {
                    throw new Error('Format CSV invalide. L\'en-t√™te doit commencer par: CandidatID,CandidatNom');
                }
                
                // D√©tecter si les colonnes Tour et Statut sont pr√©sentes
                const hasTourStatut = header[2] === 'Tour' && header[3] === 'Statut';
                const juryStartIndex = hasTourStatut ? 4 : 2;
                
                // Extraire les jurys de l'en-t√™te et mapper aux IDs
                updateProgress('Chargement des jurys...');
                await loadJuries();
                const juries = [];
                for (let i = juryStartIndex; i < header.length; i += 2) {
                    const juryName = header[i].replace('_Note1', '');
                    const jury = JURIES.find(j => j.name === juryName);
                    juries.push({
                        name: juryName,
                        id: jury ? jury.id : null
                    });
                }
                
                if (juries.length === 0) {
                    throw new Error('Aucun jury trouv√© dans le fichier CSV');
                }
                
                let imported = 0;
                let candidatesUpdated = 0;
                let errors = [];
                const totalLines = lines.length - 1;
                
                // Parser chaque ligne
                for (let i = 1; i < lines.length; i++) {
                    updateProgress(`Traitement ligne ${i}/${totalLines}...`);
                    
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    // Parser les valeurs en g√©rant les guillemets et les cases vides
                    const values = [];
                    let current = '';
                    let inQuotes = false;
                    for (let c = 0; c < line.length; c++) {
                        const char = line[c];
                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            values.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    values.push(current.trim()); // Derni√®re valeur
                    
                    const candidatId = values[0];
                    
                    // V√©rifier que le candidat existe
                    const candidate = CANDIDATES.find(c => c.id === candidatId);
                    if (!candidate) {
                        errors.push(`Ligne ${i + 1}: Candidat "${candidatId}" non trouv√©`);
                        continue;
                    }
                    
                    // Mettre √† jour Tour et Statut si pr√©sents dans le CSV
                    if (hasTourStatut) {
                        const tourName = values[2];
                        const statut = values[3];
                        
                        // Trouver le roundId correspondant au nom du tour
                        if (tourName) {
                            const round = ROUNDS.find(r => r.name === tourName);
                            if (round) {
                                candidate.tour = round.id;
                            }
                        }
                        
                        // Mettre √† jour le statut
                        if (statut && ['Actif', 'Qualifie', 'Elimine'].includes(statut)) {
                            candidate.status = statut;
                        }
                        candidatesUpdated++;
                    }
                    
                    // Importer les notes pour chaque jury
                    for (let j = 0; j < juries.length; j++) {
                        const jury = juries[j];
                        const juryName = jury.name;
                        const juryId = jury.id;
                        const noteIndex = juryStartIndex + j * 2;
                        const note1 = values[noteIndex];
                        const note2 = values[noteIndex + 1];
                        
                        // V√©rifier que le jury existe
                        if (!juryId) {
                            errors.push(`Ligne ${i + 1}: Jury "${juryName}" non trouv√© dans la base de donn√©es`);
                            continue;
                        }
                        
                        // Transformer les valeurs import√©es
                        let processedNote1 = note1;
                        let processedNote2 = note2;
                        
                        // Case vide ‚Üí '-'
                        if (!processedNote1 || processedNote1 === '') {
                            processedNote1 = '-';
                        }
                        if (!processedNote2 || processedNote2 === '') {
                            processedNote2 = '-';
                        }
                        
                        // D√©terminer si c'est un tour de rep√™chage
                        const currentRound = ROUNDS.find(r => r.id === (activeRoundId || 'round1'));
                        const isRepechage = currentRound && currentRound.type === 'Rep√™chage';
                        
                        // Pour les tours NON rep√™chage : 0 ‚Üí 'EL'
                        if (!isRepechage) {
                            if (processedNote1 === '0') processedNote1 = 'EL';
                            if (processedNote2 === '0') processedNote2 = 'EL';
                        }
                        
                        // Valider les notes
                        const validValues = ['-', '5', '10', '15', '20', 'EL', 'Elimine', '0', '1'];
                        if (!validValues.includes(processedNote1) || !validValues.includes(processedNote2)) {
                            errors.push(`Ligne ${i + 1}, ${juryName}: Notes invalides (${processedNote1}, ${processedNote2})`);
                            continue;
                        }
                        
                        // Chercher si un score existe d√©j√† pour ce tour (par juryId)
                        const q = query(
                            collection(db, "scores"),
                            where("candidateId", "==", candidatId),
                            where("juryId", "==", juryId),
                            where("roundId", "==", activeRoundId || 'round1')
                        );
                        const existingScores = await getDocs(q);
                        
                        const scoreData = {
                            candidateId: candidatId,
                            juryId: juryId,
                            juryName: juryName,
                            roundId: activeRoundId || 'round1',
                            score1: processedNote1,
                            score2: processedNote2,
                            timestamp: new Date()
                        };
                        
                        if (!existingScores.empty) {
                            await setDoc(doc(db, "scores", existingScores.docs[0].id), scoreData);
                        } else {
                            await addDoc(collection(db, "scores"), scoreData);
                        }
                        
                        imported++;
                    }
                }
                
                // Sauvegarder les candidats si des tours/statuts ont √©t√© modifi√©s
                if (hasTourStatut && candidatesUpdated > 0) {
                    updateProgress('Sauvegarde des candidats...');
                    await saveCandidates();
                }
                
                updateProgress('Mise √† jour de l\'affichage...');
                
                // Supprimer le message d'attente
                document.body.removeChild(loadingOverlay);
                
                event.target.value = '';
                
                let message = `‚úÖ Import termin√© !\n\nüìä ${imported} note(s) import√©e(s)`;
                if (hasTourStatut) {
                    message += `\nüë§ ${candidatesUpdated} candidat(s) mis √† jour (tour/statut)`;
                }
                if (errors.length > 0) {
                    message += `\n\n‚ö†Ô∏è ${errors.length} erreur(s) :\n${errors.slice(0, 5).join('\n')}`;
                    if (errors.length > 5) {
                        message += `\n... et ${errors.length - 5} autre(s)`;
                    }
                }
                
                await customAlert(message);
                
                // Rafra√Æchir l'affichage
                await renderNotesTable();
                await loadResults();
                
                console.log('‚úÖ Tableau recharg√© apr√®s import CSV');
            } catch (e) {
                // Supprimer le message d'attente en cas d'erreur
                const overlay = document.getElementById('import-loading-overlay');
                if (overlay) document.body.removeChild(overlay);
                
                console.error('Erreur:', e);
                await customAlert('‚ùå Erreur lors de l\'import:\n' + e.message);
                event.target.value = '';
            }
        };

        window.exportToExcel = async () => {
            if (!CANDIDATES.length || !Object.keys(aggregatedData).length) {
                await alert('Veuillez d\'abord charger les r√©sultats (bouton "Charger et Calculer")');
                return;
            }

            // R√©cup√©rer les jurys
            const juries = new Set();
            Object.values(aggregatedData).forEach(candidate => {
                Object.keys(candidate.juryScores).forEach(jury => juries.add(jury));
            });
            const sortedJuries = Array.from(juries).sort();

            // Cr√©er l'en-t√™te CSV
            let csv = 'Candidat,' + sortedJuries.join(',') + ',Total\n';

            // Ajouter les donn√©es des candidats
            CANDIDATES.forEach(c => {
                const data = aggregatedData[c.id];
                if (!data.hasScores) return;

                let row = `"${c.name}",`;
                
                // Scores par jury
                sortedJuries.forEach((jury, index) => {
                    const scoreObj = data.juryScores[jury];
                    if (scoreObj) {
                        // Remplacer "EL" par "0" dans l'export
                        let score1Display = scoreObj.score1 === 'EL' ? '0' : scoreObj.score1;
                        let score2Display = scoreObj.score2 === 'EL' ? '0' : scoreObj.score2;
                        
                        // Recalculer le score pond√©r√© pour l'export
                        let weightedScore = 0;
                        if (scoreObj.score1 && scoreObj.score1 !== '-' && 
                            scoreObj.score2 && scoreObj.score2 !== '-') {
                            // Si un score est "EL", le score pond√©r√© = 0
                            if (scoreObj.score1 === 'EL' || scoreObj.score2 === 'EL') {
                                weightedScore = 0;
                            } else {
                                weightedScore = (parseInt(scoreObj.score1) * 3) + parseInt(scoreObj.score2);
                            }
                        }
                        row += `"${score1Display}|${score2Display} (${weightedScore})"`;
                    } else {
                        row += '-';
                    }
                    if (index < sortedJuries.length - 1) row += ',';
                });

                // Total
                row += `,${data.total}`;
                csv += row + '\n';
            });

            // T√©l√©charger le fichier
            const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            const date = new Date().toISOString().split('T')[0];
            link.setAttribute('href', url);
            link.setAttribute('download', `resultats_concours_${date}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };

        // Export du podium en image
        window.exportPodiumToImage = async () => {
            const podiumTable = document.getElementById('podium-table');
            
            if (!podiumTable || !podiumTable.querySelector('tbody').children.length) {
                alert('Veuillez d\'abord charger les r√©sultats (bouton "Charger et Calculer")');
                return;
            }

            try {
                // V√©rifier si html2canvas est charg√©
                if (typeof html2canvas === 'undefined') {
                    alert('Erreur: html2canvas n\'est pas charg√©');
                    return;
                }

                // Cr√©er un conteneur temporaire avec le titre
                const container = document.createElement('div');
                container.style.padding = '30px';
                container.style.background = 'white';
                container.style.width = 'fit-content';
                
                const title = document.createElement('h1');
                title.textContent = 'Classement Officiel - Concours d\'√âloquence';
                title.style.color = '#007bff';
                title.style.textAlign = 'center';
                title.style.marginBottom = '20px';
                title.style.fontSize = '24px';
                
                const tableClone = podiumTable.cloneNode(true);
                tableClone.style.fontSize = '16px';
                
                container.appendChild(title);
                container.appendChild(tableClone);
                
                // Ajouter temporairement au document
                container.style.position = 'absolute';
                container.style.left = '-9999px';
                document.body.appendChild(container);

                // Capturer avec html2canvas
                const canvas = await html2canvas(container, {
                    backgroundColor: '#ffffff',
                    scale: 2, // Haute r√©solution
                    logging: false
                });

                // Supprimer le conteneur temporaire
                document.body.removeChild(container);

                // T√©l√©charger l'image
                const date = new Date().toISOString().split('T')[0];
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `podium_concours_${date}.png`;
                    link.click();
                    URL.revokeObjectURL(url);
                });

            } catch (e) {
                console.error('Erreur lors de l\'export:', e);
                alert('Erreur lors de la g√©n√©ration de l\'image: ' + e.message);
            }
        };

        // Modal pour changement de mot de passe
        window.showPasswordModal = async function() {
            try {
                // 1. Demander le mot de passe actuel
                const currentPassword = await prompt('√âtape 1/3: Entrez le mot de passe actuel:');
                
                if (!currentPassword) {
                    return; // Annul√©
                }

                // V√©rifier le mot de passe actuel
                const adminDoc = await getDoc(doc(db, "config", "admin"));
                const storedPassword = adminDoc.exists() ? adminDoc.data().password : 'admin';

                if (currentPassword !== storedPassword) {
                    alert('Mot de passe actuel incorrect !');
                    return;
                }

                // 2. Demander le nouveau mot de passe
                const newPassword = await prompt('√âtape 2/3: Entrez le nouveau mot de passe:\n(minimum 4 caract√®res)');
                
                if (!newPassword) {
                    return; // Annul√©
                }

                if (newPassword.length < 4) {
                    alert('Le mot de passe doit contenir au moins 4 caract√®res');
                    return;
                }

                // 3. Demander la confirmation
                const confirmPassword = await prompt('√âtape 3/3: Confirmez le nouveau mot de passe:');
                
                if (!confirmPassword) {
                    return; // Annul√©
                }

                if (newPassword !== confirmPassword) {
                    alert('Les mots de passe ne correspondent pas !');
                    return;
                }

                // Tout est OK, changer le mot de passe
                await changeAdminPassword(newPassword);
                
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la v√©rification du mot de passe');
            }
        };

        // Changement du mot de passe administrateur
        async function changeAdminPassword(newPassword) {
            try {
                await setDoc(doc(db, "config", "admin"), { password: newPassword });
                alert('Mot de passe chang√© avec succ√®s !');
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors du changement de mot de passe');
            }
        }

        // D√©connexion admin
        window.adminLogout = async function() {
            if (await confirm('Voulez-vous vous d√©connecter ?')) {
                window.location.href = 'index.html';
            }
        };

        // Theme Toggle Logic - Propre √† l'admin
        function initTheme() {
            const savedTheme = localStorage.getItem('theme_admin') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            const toggle = document.getElementById('theme-toggle');
            if (toggle) {
                if (savedTheme === 'dark') {
                    toggle.classList.add('active');
                }
            }
        }

        window.toggleTheme = async function() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            
            // Sauvegarder avec une cl√© sp√©cifique √† l'admin
            localStorage.setItem('theme_admin', newTheme);
            
            // Sauvegarder aussi dans Firebase avec merge pour pr√©server le mot de passe
            try {
                await setDoc(doc(db, "config", "admin"), {
                    theme: newTheme
                }, { merge: true });
            } catch (e) {
                console.log('Impossible de sauvegarder le th√®me admin dans Firebase:', e);
            }
            
            const toggle = document.getElementById('theme-toggle');
            if (toggle) {
                if (newTheme === 'dark') {
                    toggle.classList.add('active');
                } else {
                    toggle.classList.remove('active');
                }
            }
        };

        window.toggleMenu = function() {
            const menu = document.getElementById('menu-content');
            if (menu) {
                menu.classList.toggle('active');
            }
        };

        // Close menu when clicking outside
        document.addEventListener('click', function(event) {
            const menu = document.getElementById('menu-content');
            const burgerIcon = document.querySelector('.burger-icon');
            if (menu && burgerIcon && !menu.contains(event.target) && !burgerIcon.contains(event.target)) {
                menu.classList.remove('active');
            }
        });

        // Initialize theme on page load
        initTheme();
    </script>
    
    <script>window.useCustomModals = true;</script>
    <script src="modal.js"></script>
</body>
</html>