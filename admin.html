<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="description" content="Tableau de bord administrateur - Gestion des r√©sultats du concours">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <title>üèÜ Administration - R√©sultats Concours</title>
    <style>
        /* Modern Admin Dashboard Styles - Responsive */
        :root {
            /* Light Mode (Default) */
            --primary: #007bff;
            --success: #28a745;
            --warning: #ffc107;
            --danger: #dc3545;
            --danger-color: #dc3545;
            --danger-dark: #c82333;
            --neutral: #6c757d;
            --neutral-color: #6c757d;
            --white: #ffffff;
            --text-color: #333;
            --text-secondary: #666;
            --border-color: #ddd;
            --bg-gradient-start: #667eea;
            --bg-gradient-end: #764ba2;
            --card-bg: #ffffff;
            --input-bg: #ffffff;
            --info-bg-start: #e3f2fd;
            --info-bg-end: #bbdefb;
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 8px rgba(0,0,0,0.12);
            --shadow-lg: 0 8px 16px rgba(0,0,0,0.15);
            --radius: 10px;
            --spacing: 20px;
        }

        /* Dark Mode */
        [data-theme="dark"] {
            --primary: #4da3ff;
            --success: #4caf50;
            --warning: #ffa726;
            --danger: #f44336;
            --danger-color: #f44336;
            --danger-dark: #d32f2f;
            --neutral: #9e9e9e;
            --neutral-color: #9e9e9e;
            --white: #ffffff;
            --text-color: #e0e0e0;
            --text-secondary: #b0b0b0;
            --border-color: #444;
            --bg-gradient-start: #3d5266;
            --bg-gradient-end: #1a252f;
            --card-bg: #2d2d3a;
            --input-bg: #3a3a4a;
            --info-bg-start: #1e3a5f;
            --info-bg-end: #2c4f7c;
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.5);
        }

        * {
            box-sizing: border-box;
        }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            padding: clamp(12px, 3vw, 20px);
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            margin: 0;
            min-height: 100vh;
            line-height: 1.6;
            transition: background 0.3s ease;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--card-bg);
            padding: clamp(15px, 4vw, 40px);
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            position: relative;
        }

        h1 { 
            color: var(--primary);
            border-bottom: 3px solid var(--primary);
            padding-bottom: 15px;
            margin-top: 0;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            font-weight: 700;
        }

        h2 { 
            color: var(--primary);
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
            margin-top: var(--spacing);
            font-size: clamp(1.2rem, 3vw, 1.8rem);
            font-weight: 600;
        }

        /* Action Buttons */
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: var(--spacing);
        }

        .action-button { 
            padding: clamp(10px, 2vw, 14px) clamp(16px, 3vw, 24px);
            font-size: clamp(0.95rem, 2vw, 1.1rem);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-sm);
            flex: 1 1 auto;
            min-width: 140px;
        }

        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .action-button:active {
            transform: translateY(0);
        }

        .load-button { 
            background: linear-gradient(135deg, var(--success) 0%, #1e7e34 100%);
            color: white;
        }

        .export-button { 
            background: linear-gradient(135deg, var(--warning) 0%, #e0a800 100%);
            color: #212529;
        }

        .export-button.excel { 
            background: linear-gradient(135deg, var(--primary) 0%, #0056b3 100%);
            color: white;
        }
        
        .import-button {
            background: linear-gradient(135deg, #ff8c00 0%, #ff6b00 100%) !important;
            color: white !important;
        }

        /* Candidate Zone */
        .candidate-zone { 
            margin-top: 10px;
            padding: clamp(15px, 3vw, 25px);
            border: 2px solid var(--border-color);
            background: var(--input-bg);
            border-radius: var(--radius);
            box-shadow: var(--shadow-sm);
        }

        .candidate-zone h2 {
            margin-top: 0;
            color: var(--primary);
        }

        .candidate-zone h3 {
            margin-top: 0;
            margin-bottom: 10px;
        }

        .candidate-zone textarea { 
            width: 100%;
            min-height: 120px;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-family: inherit;
            font-size: clamp(0.95rem, 2vw, 1.05rem);
            transition: all 0.3s ease;
            resize: vertical;
            background: var(--card-bg);
            color: var(--text-color);
        }

        .candidate-zone textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
        }

        /* Tables */
        .table-container {
            overflow-x: auto;
            max-width: 100%;
            margin: var(--spacing) 0;
            border-radius: var(--radius);
            box-shadow: var(--shadow-md);
        }

        #scores-matrix { 
            width: 100%;
            border-collapse: collapse;
            background: var(--card-bg);
            font-size: clamp(0.8rem, 1.5vw, 0.95rem);
        }

        #scores-matrix th, #scores-matrix td { 
            border: 1px solid var(--border-color);
            padding: clamp(8px, 2vw, 12px);
            text-align: center;
            color: var(--text-color);
        }

        #scores-matrix th { 
            background: var(--input-bg);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            color: var(--text-color);
            cursor: pointer;
            user-select: none;
        }
        
        #scores-matrix th:hover {
            background: var(--border-color);
        }
        
        #scores-matrix th.sorted-asc::after {
            content: ' ‚ñ≤';
            font-size: 0.7em;
        }
        
        #scores-matrix th.sorted-desc::after {
            content: ' ‚ñº';
            font-size: 0.7em;
        }

        .detail-note { 
            font-size: 0.85em;
            color: var(--text-secondary);
            display: block;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 3px;
            margin-bottom: 5px;
        }

        .weighted-total { 
            font-weight: bold;
            color: var(--primary);
            font-size: 1.1em;
        }

        .total-score { 
            background: linear-gradient(135deg, #ffc107 0%, #ffb300 100%);
            font-weight: bold;
            font-size: 1.15em;
            color: #212529;
        }

        .eliminado { 
            background: linear-gradient(135deg, var(--danger) 0%, #c82333 100%);
            color: white;
            font-weight: 600;
        }

        /* Podium Table */
        #podium-table { 
            width: 100%;
            max-width: 800px;
            border-collapse: collapse;
            background: var(--card-bg);
            box-shadow: var(--shadow-md);
            border-radius: var(--radius);
            overflow: hidden;
        }

        #podium-table th, #podium-table td { 
            border: 1px solid var(--border-color);
            padding: clamp(10px, 2.5vw, 15px);
            text-align: center;
            color: var(--text-color);
        }

        #podium-table th {
            background: var(--neutral-color);
            color: var(--white);
            font-weight: 600;
        }

        #podium-table td {
            color: var(--text-color);
        }

        .rank-1 { 
            background: linear-gradient(135deg, gold 0%, #ffed4e 100%);
            font-weight: bold;
            font-size: 1.1em;
        }
        
        .rank-1 td {
            color: #212529 !important;
        }

        .rank-2 { 
            background: linear-gradient(135deg, silver 0%, #e0e0e0 100%);
            font-weight: bold;
            font-size: 1.05em;
        }
        
        .rank-2 td {
            color: #212529 !important;
        }

        .rank-3 { 
            background: linear-gradient(135deg, #cd7f32 0%, #b87333 100%);
            font-weight: bold;
        }
        
        .rank-3 td {
            color: white !important;
        }

        .eliminated-row { 
            background: linear-gradient(135deg, var(--neutral) 0%, #5a6268 100%);
            color: white;
            opacity: 0.8;
        }

        /* Reset Zone */
        .reset-zone { 
            margin-top: 50px;
            padding: clamp(15px, 3vw, 25px);
            border: 3px solid var(--danger-color);
            background: rgba(220, 53, 69, 0.1);
            border-radius: var(--radius);
            box-shadow: var(--shadow-sm);
        }

        .reset-zone h2 {
            color: var(--danger-color);
            margin-top: 0;
        }
        
        .reset-zone p {
            color: var(--text-color);
        }

        .reset-zone .action-button {
            background: linear-gradient(135deg, var(--danger-color) 0%, var(--danger-dark) 100%);
            color: white;
        }

        hr {
            border: none;
            border-top: 2px solid var(--border-color);
            margin: calc(var(--spacing) * 1.5) 0;
        }

        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            gap: 5px;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: var(--spacing);
            flex-wrap: wrap;
        }

        .tab-btn {
            padding: 12px 24px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .tab-btn:hover {
            color: var(--primary);
            background: rgba(0, 123, 255, 0.05);
        }

        .tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Candidate Table */
        .candidate-table {
            width: 100%;
            border-collapse: collapse;
            margin: var(--spacing) 0;
        }

        .candidate-table th,
        .candidate-table td {
            border: 1px solid var(--border-color);
            padding: 12px;
            text-align: left;
            color: var(--text-color);
        }

        .candidate-table th {
            background: var(--input-bg);
            font-weight: 600;
            color: var(--text-color);
        }

        .candidate-table input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background: var(--card-bg);
            color: var(--text-color);
            font-family: inherit;
        }

        .candidate-table .actions {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2em;
            padding: 4px 8px;
            transition: all 0.3s ease;
        }

        .icon-btn:hover {
            transform: scale(1.2);
        }

        .icon-btn.delete {
            color: var(--danger-color);
        }

        .icon-btn.reset {
            color: var(--warning);
        }

        .icon-btn.lock {
            color: var(--neutral-color);
        }

        .icon-btn.lock.locked {
            color: var(--danger-color);
        }

        /* Notes Table */
        .notes-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
            table-layout: auto;
        }
        
        #notes-table {
            width: max-content;
            min-width: 100%;
        }

        .notes-table th,
        .notes-table td {
            border: 1px solid var(--border-color);
            padding: 8px;
            text-align: center;
            overflow: visible;
            color: var(--text-color);
        }

        .notes-table th {
            background: var(--input-bg);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            color: var(--text-color);
        }

        .notes-table select {
            width: 100%;
            min-width: 80px;
            max-width: 90px;
            padding: 6px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: var(--card-bg);
            color: var(--text-color);
            text-align: center;
            font-size: 14px;
            font-family: inherit;
        }

        .notes-table .candidate-name {
            text-align: left;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .notes-table .locked-cell {
            background: rgba(220, 53, 69, 0.1);
        }

        .notes-table .col-actions {
            width: 100px;
        }

        .notes-table .col-candidate {
            width: 150px;
        }

        .notes-table .col-score {
            min-width: 90px;
            width: 90px;
            text-align: center;
        }

        /* Burger Menu & Theme Toggle */
        .burger-menu {
            position: absolute;
            top: var(--spacing);
            right: var(--spacing);
            z-index: 9999;
        }

        .burger-icon {
            width: 36px;
            height: 36px;
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 4px;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-sm);
        }

        .burger-icon:hover {
            box-shadow: var(--shadow-md);
        }

        .burger-icon span {
            width: 20px;
            height: 2px;
            background: var(--text-color);
            transition: all 0.3s ease;
        }

        .burger-menu-content {
            position: absolute;
            top: 45px;
            right: 0;
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 5px;
            box-shadow: var(--shadow-lg);
            padding: 0;
            min-width: 200px;
            display: none;
            overflow: hidden;
            z-index: 10000;
        }

        .burger-menu-content.active {
            display: block;
        }

        .burger-menu-content > * {
            padding: 12px;
        }

        .burger-menu-content > *:not(:last-child) {
            border-bottom: 1px solid var(--border-color);
        }

        .theme-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: var(--text-color);
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: var(--neutral-color);
            border-radius: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-switch.active {
            background: var(--primary);
        }

        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(24px);
        }

        .menu-item {
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 12px;
            color: var(--text-color);
            border: none;
            background: transparent;
            width: 100%;
            text-align: left;
            font-size: clamp(0.9rem, 2vw, 1rem);
            font-family: inherit;
            margin: 0;
        }

        .menu-item:hover {
            background: var(--info-bg-start, rgba(0, 123, 255, 0.1));
        }

        #menu-content .menu-item {
            padding: 12px;
        }

        /* Responsive Design */
        @media (max-width: 767px) {
            .button-group {
                flex-direction: column;
            }

            .action-button {
                width: 100%;
                min-width: unset;
            }

            #scores-matrix {
                font-size: 0.75rem;
            }

            #scores-matrix th,
            #scores-matrix td {
                padding: 6px;
            }

            #podium-table {
                font-size: 0.85rem;
            }
        }

        @media (min-width: 768px) and (max-width: 1023px) {
            .button-group {
                justify-content: flex-start;
            }

            .action-button {
                flex: 0 1 calc(50% - 6px);
            }
        }

        @media (min-width: 1024px) {
            .action-button {
                flex: 0 1 auto;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .action-button {
                min-height: 44px;
            }
        }

        /* Print styles */
        @media print {
            body {
                background: white;
            }

            .container {
                box-shadow: none;
            }

            .candidate-zone,
            .reset-zone,
            .action-button {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="burger-menu">
            <div class="burger-icon" onclick="toggleMenu()">
                <span></span>
                <span></span>
                <span></span>
            </div>
            <div class="burger-menu-content" id="menu-content">
                <div class="theme-toggle">
                    <span>Mode sombre</span>
                    <div class="toggle-switch" id="theme-toggle" onclick="toggleTheme()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
                <div class="menu-item" onclick="showPasswordModal()">
                    <span>Changer le mot de passe</span>
                </div>
                <div class="menu-item" onclick="adminLogout()" style="color: var(--danger-color); font-weight: 600;">
                    <span>D√©connexion</span>
                </div>
            </div>
        </div>

    <h1>Tableau de bord Administrateur</h1>
    
        <!-- Tab Navigation -->
        <div class="tab-navigation">
            <button class="tab-btn active" onclick="switchTab('candidats')">Candidats</button>
            <button class="tab-btn" onclick="switchTab('jury')">Jury</button>
            <button class="tab-btn" onclick="switchTab('tours')">Tours</button>
            <button class="tab-btn" onclick="switchTab('notes')">Notes</button>
            <button class="tab-btn" onclick="switchTab('podium')">Podium</button>
            <button class="tab-btn" onclick="switchTab('reinitialiser')">R√©initialiser</button>
        </div>

        <!-- TAB 1: CANDIDATS -->
        <div id="tab-candidats" class="tab-content active">
    <div class="candidate-zone">
                <h3 style="color: var(--text-color);">Import rapide (copier-coller)</h3>
                <p style="color: var(--text-color); font-size: 0.9em; margin: 5px 0;">Les candidats de la liste seront <strong>ajout√©s</strong> aux candidats existants (pas de remplacement).</p>
                <textarea id="candidate-names" placeholder="Un nom par ligne...&#10;Exemple:&#10;Alice Martin&#10;Bob Dupont&#10;Claire Bernard"></textarea>
                <div style="display: flex; align-items: center; gap: 8px; margin: 10px 0;">
                    <input type="checkbox" id="random-ids-checkbox" checked style="width: 18px; height: 18px; cursor: pointer;">
                    <label for="random-ids-checkbox" style="color: var(--text-color); cursor: pointer; font-size: 0.95em;">D√©finir des IDs al√©atoires (sinon 001, 002, 003...)</label>
                </div>
                <button onclick="importCandidates()" class="action-button" style="background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); color:white;">Ajouter les nouveaux candidats</button>
    </div>

            <h3 style="color: var(--text-color);">Liste des candidats</h3>
            <button onclick="addCandidate()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); color:white;">+ Ajouter un candidat</button>
            
            <table class="candidate-table" id="candidate-table">
                <thead>
                    <tr>
                        <th style="width: 80px;">ID</th>
                        <th>Nom du candidat</th>
                        <th style="width: 100px;">Actions</th>
                    </tr>
                </thead>
                <tbody id="candidate-table-body">
                    <!-- Rempli dynamiquement -->
                </tbody>
            </table>
    </div>

        <!-- TAB 2: JURY -->
        <div id="tab-jury" class="tab-content">
            <div class="candidate-zone">
                <h3 style="color: var(--text-color);">Import rapide (copier-coller)</h3>
                <p style="color: var(--text-color); font-size: 0.9em; margin: 5px 0;">Les jurys de la liste seront <strong>ajout√©s</strong> aux jurys existants (pas de remplacement).</p>
                <textarea id="jury-names" placeholder="Un nom par ligne...&#10;Exemple:&#10;Pierre Dubois&#10;Marie Martin&#10;Jacques Bernard"></textarea>
                <button onclick="importJuries()" class="action-button" style="background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); color:white;">Ajouter les nouveaux jurys</button>
            </div>

            <h3 style="color: var(--text-color);">Liste des jurys</h3>
            <button onclick="addJury()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); color:white;">+ Ajouter un jury</button>
            
            <table class="candidate-table" id="jury-table">
                <thead>
                    <tr>
                        <th style="width: 60px;">ID</th>
                        <th>Nom du jury</th>
                        <th style="width: 100px;">Mot de passe</th>
                        <th style="width: 150px;">Actions</th>
                    </tr>
                </thead>
                <tbody id="jury-table-body">
                    <!-- Rempli dynamiquement -->
                </tbody>
            </table>
        </div>

        <!-- TAB 3: TOURS -->
        <div id="tab-tours" class="tab-content">
            <p style="color: var(--text-secondary); margin-bottom: 20px;">
                D√©finissez les diff√©rents tours du concours. Chaque tour peut avoir un type diff√©rent.
            </p>
            
            <div style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">
                <button onclick="addRound()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); color:white;">+ Ajouter un tour</button>
                
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="active-round-select" style="color: var(--text-color); font-weight: 600;">Tour actif :</label>
                    <select id="active-round-select" onchange="setActiveRound(this.value)" style="padding: 8px 12px; border: 2px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-color); font-size: 1em; font-family: inherit; min-width: 200px;">
                        <!-- Rempli dynamiquement -->
                    </select>
                    <button onclick="finishRound()" class="action-button" style="background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); color:white; padding: 8px 16px;">‚úì Terminer le tour</button>
                </div>
            </div>
            
            <div class="table-container">
                <table class="notes-table" id="rounds-table">
                    <thead>
                        <tr>
                            <th style="width: 70px;">Actions</th>
                            <th style="width: 60px;">Ordre</th>
                            <th style="width: 20%;">Nom du tour</th>
                            <th style="min-width: 220px; width: 35%;">Type</th>
                            <th style="width: 140px;">Candidats suivants</th>
                        </tr>
                    </thead>
                    <tbody id="rounds-table-body">
                        <!-- Rempli dynamiquement -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- TAB 4: NOTES -->
        <div id="tab-notes" class="tab-content">
            <p style="color: var(--text-secondary); margin-bottom: 20px;">
                Modifiez les notes directement dans le tableau. Les modifications sont sauvegard√©es automatiquement.
            </p>
            
            <div style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 15px;">
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <label for="notes-round-select" style="color: var(--text-color); font-weight: 600;">Tour √† afficher :</label>
                        <select id="notes-round-select" onchange="changeNotesRound(this.value)" style="padding: 8px 12px; border: 2px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-color); font-size: 1em; font-family: inherit; min-width: 200px;">
                            <!-- Rempli dynamiquement -->
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="notes-filter-current-round" onchange="renderNotesTable()" checked style="width: 18px; height: 18px; cursor: pointer;">
                        <label for="notes-filter-current-round" style="color: var(--text-color); cursor: pointer;">Candidats en cours sur ce tour</label>
                    </div>
                </div>
                
                <div class="button-group">
                    <button onclick="exportNotesToCSV()" class="action-button export-button excel">üì• Exporter en CSV</button>
                    <input type="file" id="csv-import-file" accept=".csv" style="display: none;" onchange="importNotesFromCSV(event)">
                    <button onclick="document.getElementById('csv-import-file').click()" class="action-button import-button">üì§ Importer depuis CSV</button>
                </div>
            </div>
            
            <div class="table-container">
                <table class="notes-table" id="notes-table">
                    <thead>
                        <tr>
                            <!-- En-t√™te g√©n√©r√© dynamiquement -->
                        </tr>
                    </thead>
                    <tbody id="notes-table-body">
                        <!-- Rempli dynamiquement -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- TAB 5: PODIUM -->
        <div id="tab-podium" class="tab-content">
    <h2>Classement Officiel</h2>
            
            <div style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="podium-round-select" style="color: var(--text-color); font-weight: 600;">Tour √† afficher :</label>
                    <select id="podium-round-select" onchange="changePodiumRound(this.value)" style="padding: 8px 12px; border: 2px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-color); font-size: 1em; font-family: inherit; min-width: 200px;">
                        <!-- Rempli dynamiquement -->
                    </select>
                </div>
                
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="result-limit" style="font-weight: 600; color: var(--text-color);">Nombre de candidats :</label>
                    <input type="number" id="result-limit" value="3" min="1" oninput="renderPodium()" style="width: 80px; padding: 8px; border: 2px solid var(--border-color); border-radius: 5px; background: var(--card-bg); color: var(--text-color);">
                    <button onclick="exportPodiumToImage()" class="action-button export-button">Exporter en image</button>
                </div>
            </div>

            <div class="table-container">
    <table id="podium-table">
        <thead>
            <tr><th>Rang</th><th>Candidat</th><th>Score Pond√©r√©</th><th>Statut</th></tr>
        </thead>
        <tbody id="podium-body"></tbody>
    </table>
            </div>
        </div>

        <!-- TAB 7: REINITIALISER -->
        <div id="tab-reinitialiser" class="tab-content">
        <h2>Zone de Danger</h2>
            <p style="color: var(--danger-color); font-weight: 600; margin-bottom: 20px;">
                ‚ö†Ô∏è Attention: Ces actions sont irr√©versibles !
            </p>

            <div class="reset-zone" style="background: var(--info-bg-start); border: 2px solid var(--primary);">
                <h3 style="color: var(--primary);">üîß Utilitaires</h3>
                <p>V√©rifier et nettoyer la base de donn√©es : supprime les doublons, les scores orphelins (candidats/jurys supprim√©s), et les valeurs calcul√©es obsol√®tes.</p>
                <p style="font-weight: 600; color: var(--warning-color); margin-top: 10px;">‚ö†Ô∏è Recommand√© : Sauvegardez votre base de donn√©es avant de lancer cette op√©ration.</p>
                <button onclick="cleanDatabase()" class="action-button" style="background: var(--primary);">Nettoyer la base de donn√©es</button>
            </div>

            <div class="reset-zone" style="background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%); border: 2px solid #ffc107;">
                <h3 style="color: #856404;">üß™ Tests</h3>
                <p style="color: #212529;">Ins√©rer des candidats et jurys de test pour simuler rapidement un concours.</p>
                <button onclick="insertTestData()" class="action-button" style="background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%); color: #212529; margin-bottom: 10px;">üìã Ins√©rer candidats et jurys de test</button>
                
                <p style="color: #212529; margin-top: 15px;">Auto-remplir les notes des candidats actifs du tour en cours avec "-" et les passer en "Qualifi√©".</p>
                <p style="font-weight: 600; color: #856404; margin-top: 10px;">‚ö†Ô∏è Utile pour les tests rapides.</p>
                <button onclick="autoFillActiveRound()" class="action-button" style="background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%); color: #212529;">‚úì Auto-remplir et qualifier le tour actif</button>
            </div>

            <div class="reset-zone" style="background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); border: 2px solid #28a745;">
                <h3 style="color: #1e7e34;">üíæ Sauvegarde & Restauration</h3>
                <p style="color: #212529;">T√©l√©charger toutes les donn√©es (candidats, scores, verrous, configuration) en format JSON.</p>
                <button onclick="downloadDatabase()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); color: white;">üì• T√©l√©charger la base de donn√©es</button>
                
                <p style="margin-top: 15px; color: #212529;">Restaurer les donn√©es depuis un fichier JSON de sauvegarde.</p>
                <input type="file" id="db-upload-file" accept=".json" style="display: none;" onchange="uploadDatabase(event)">
                <button onclick="document.getElementById('db-upload-file').click()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); color: white;">üì§ Restaurer depuis un fichier</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">Supprimer TOUS les jurys</h3>
                <p>Supprime toutes les notations de tous les jurys (mais conserve la liste des candidats).</p>
                <button onclick="confirmDeleteAllJuries()" class="action-button" style="background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); color: white;">Supprimer tous les jurys</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">R√©initialiser les scores</h3>
                <p>Remet toutes les notations √† "-" mais conserve la structure (jurys et candidats).</p>
                <button onclick="confirmResetScores()" class="action-button">R√©initialiser les scores uniquement</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px;">
                <h3 style="color: var(--text-color);">R√©initialisation compl√®te</h3>
                <p>Supprime TOUS les candidats ET toutes les notations. Remet l'application √† z√©ro.</p>
                <button onclick="confirmResetAll()" class="action-button">R√âINITIALISER TOUT (Candidats + Scores)</button>
            </div>
        </div>
    </div>

    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script type="module">
        import { db } from './firebase-init.js';
        import { collection, getDocs, deleteDoc, doc, setDoc, getDoc, addDoc, query, where, writeBatch } from "https://www.gstatic.com/firebasejs/10.1.0/firebase-firestore.js";

        let CANDIDATES = [];
        let ROUNDS = [];
        let activeRoundId = null;
        let aggregatedData = {};
        let candidateLocks = {}; // {candidateId: {juryName: boolean}}

        // --- TAB SWITCHING ---
        window.switchTab = function(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(`tab-${tabName}`).classList.add('active');
            event.target.classList.add('active');
            
            // Load tab-specific data
            if (tabName === 'candidats') {
                renderCandidateTable();
            } else if (tabName === 'jury') {
                renderJuryTable();
            } else if (tabName === 'tours') {
                renderRoundsTable();
            } else if (tabName === 'notes') {
                populateNotesRoundDropdown();
                renderNotesTable();
            } else if (tabName === 'podium') {
                populatePodiumRoundDropdown();
                loadResults();
            }
        };

        // --- GESTION CANDIDATS ---
        
        // G√©n√®re un ID al√©atoire unique entre 001 et 999
        function generateUniqueCandidateId() {
            const existingIds = new Set(CANDIDATES.map(c => c.id));
            let attempts = 0;
            const maxAttempts = 1000;
            
            while (attempts < maxAttempts) {
                // G√©n√©rer un nombre al√©atoire entre 1 et 999
                const randomNum = Math.floor(Math.random() * 999) + 1;
                // Formater avec des z√©ros devant (001, 002, etc.)
                const id = String(randomNum).padStart(3, '0');
                
                if (!existingIds.has(id)) {
                    return id;
                }
                attempts++;
            }
            
            // Si tous les IDs sont pris (tr√®s improbable), chercher le premier disponible
            for (let i = 1; i <= 999; i++) {
                const id = String(i).padStart(3, '0');
                if (!existingIds.has(id)) {
                    return id;
                }
            }
            
            // Si vraiment tous les IDs sont pris (999 candidats), retourner null
            return null;
        }
        
        const loadList = async () => {
            const snap = await getDoc(doc(db, "candidats", "liste_actuelle"));
            if (snap.exists()) {
                CANDIDATES = snap.data().candidates || [];
                
                // Initialiser les nouveaux champs tour et status s'ils n'existent pas
                CANDIDATES = CANDIDATES.map(c => ({
                    ...c,
                    tour: c.tour || activeRoundId || 'round1',
                    status: c.status || 'Actif'
                }));
                
                document.getElementById('candidate-names').value = CANDIDATES.map(c => c.name).join('\n');
                renderCandidateTable();
            }
            
            // Charger les verrous
            const lockSnap = await getDoc(doc(db, "config", "locks"));
            if (lockSnap.exists()) {
                candidateLocks = lockSnap.data().locks || {};
            }
        };

        function generateSequentialCandidateId() {
            // Trouver le prochain ID s√©quentiel disponible
            const usedIds = new Set(CANDIDATES.map(c => c.id));
            for (let i = 1; i <= 999; i++) {
                const id = String(i).padStart(3, '0');
                if (!usedIds.has(id)) {
                    return id;
                }
            }
            return null; // Tous les IDs sont utilis√©s
        }

        window.importCandidates = async () => {
            const names = document.getElementById('candidate-names').value.split('\n').map(n => n.trim()).filter(n => n !== "");
            if (names.length === 0) {
                await customAlert("Veuillez entrer au moins un candidat");
                return;
            }
            
            // V√©rifier si l'utilisateur veut des IDs al√©atoires ou s√©quentiels
            const useRandomIds = document.getElementById('random-ids-checkbox').checked;
            
            // Charger les candidats existants
            const docSnap = await getDoc(doc(db, "candidats", "liste_actuelle"));
            const existingCandidates = docSnap.exists() ? (docSnap.data().candidates || []) : [];
            
            // Cr√©er une copie de CANDIDATES pour la g√©n√©ration d'ID (√©viter les modifications par r√©f√©rence)
            CANDIDATES = [...existingCandidates];
            
            // Cr√©er un Set des noms existants pour v√©rification rapide
            const existingNames = new Set(existingCandidates.map(c => c.name.toLowerCase()));
            
            // Ajouter uniquement les nouveaux candidats
            const newCandidates = [];
            const duplicates = [];
            
            names.forEach(name => {
                if (existingNames.has(name.toLowerCase())) {
                    duplicates.push(name);
                } else {
                    // G√©n√©rer l'ID selon le choix de l'utilisateur
                    const newId = useRandomIds ? generateUniqueCandidateId() : generateSequentialCandidateId();
                    if (newId) {
                        const newCandidate = { 
                            id: newId, 
                            name: name,
                            tour: activeRoundId || 'round1',
                            status: 'Actif'
                        };
                        newCandidates.push(newCandidate);
                        existingNames.add(name.toLowerCase());
                        // Ajouter temporairement √† CANDIDATES pour les prochaines g√©n√©rations d'ID
                        CANDIDATES.push(newCandidate);
                    }
                }
            });
            
            // Fusionner avec les candidats existants
            const updatedList = [...existingCandidates, ...newCandidates];
            
            // Sauvegarder
            await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: updatedList });
            
            // Message de confirmation
            let message = `‚úì ${newCandidates.length} nouveau(x) candidat(s) ajout√©(s)`;
            if (useRandomIds) {
                message += '\n(IDs al√©atoires)';
            } else {
                message += '\n(IDs s√©quentiels)';
            }
            if (duplicates.length > 0) {
                message += `\n‚ö†Ô∏è ${duplicates.length} candidat(s) d√©j√† existant(s) ignor√©(s):\n${duplicates.join(', ')}`;
            }
            await customAlert(message);
            
            CANDIDATES = updatedList;
            renderCandidateTable();
        };

        window.addCandidate = async () => {
            // G√©n√©rer un ID al√©atoire unique
            const newId = generateUniqueCandidateId();
            if (!newId) {
                await customAlert("Impossible d'ajouter un candidat : tous les IDs (001-999) sont utilis√©s.");
                return;
            }
            
            CANDIDATES.push({ 
                id: newId, 
                name: `Candidat ${newId}`,
                tour: activeRoundId || 'round1',
                status: 'Actif'
            });
            saveCandidates();
        };

        window.deleteCandidate = async (candidateId) => {
            if (!await confirm(`Supprimer ce candidat et toutes ses notes ?`)) return;
            
            CANDIDATES = CANDIDATES.filter(c => c.id !== candidateId);
            
            // Supprimer aussi les scores de ce candidat
            const scoresQuery = query(collection(db, "scores"), where("candidateId", "==", candidateId));
            const scoresSnap = await getDocs(scoresQuery);
            for (const scoreDoc of scoresSnap.docs) {
                await deleteDoc(doc(db, "scores", scoreDoc.id));
            }
            
            saveCandidates();
        };

        window.updateCandidateId = async (oldId, newId) => {
            // Nettoyer et valider le nouvel ID
            newId = newId.trim();
            
            // V√©rifier le format (doit √™tre un nombre entre 001 et 999)
            if (!/^\d{3}$/.test(newId)) {
                await customAlert("L'ID doit √™tre un nombre √† 3 chiffres (001 √† 999)");
                renderCandidateTable(); // Restaurer l'ancien ID
                return;
            }
            
            const numericId = parseInt(newId);
            if (numericId < 1 || numericId > 999) {
                await customAlert("L'ID doit √™tre entre 001 et 999");
                renderCandidateTable();
                return;
            }
            
            // V√©rifier l'unicit√©
            if (oldId !== newId && CANDIDATES.some(c => c.id === newId)) {
                await customAlert(`L'ID ${newId} est d√©j√† utilis√© par un autre candidat`);
                renderCandidateTable();
                return;
            }
            
            // Si l'ID n'a pas chang√©, ne rien faire
            if (oldId === newId) {
                return;
            }
            
            // Mettre √† jour l'ID du candidat
            const candidate = CANDIDATES.find(c => c.id === oldId);
            if (candidate) {
                candidate.id = newId;
                
                // Mettre √† jour tous les scores associ√©s √† ce candidat
                const scoresQuery = query(collection(db, "scores"), where("candidateId", "==", oldId));
                const scoresSnap = await getDocs(scoresQuery);
                
                for (const scoreDoc of scoresSnap.docs) {
                    await updateDoc(doc(db, "scores", scoreDoc.id), {
                        candidateId: newId
                    });
                }
                
                // Mettre √† jour les verrous si n√©cessaire
                if (candidateLocks[oldId]) {
                    candidateLocks[newId] = candidateLocks[oldId];
                    delete candidateLocks[oldId];
                    await setDoc(doc(db, "config", "locks"), { locks: candidateLocks });
                }
                
                await saveCandidates();
                await customAlert(`ID mis √† jour : ${oldId} ‚Üí ${newId}`);
            }
        };
        
        window.updateCandidateName = (candidateId, newName) => {
            const candidate = CANDIDATES.find(c => c.id === candidateId);
            if (candidate) {
                candidate.name = newName;
                saveCandidates();
            }
        };

        async function saveCandidates() {
            await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: CANDIDATES });
            renderCandidateTable();
        }

        function renderCandidateTable() {
            const tbody = document.getElementById('candidate-table-body');
            tbody.innerHTML = '';
            
            // Trier les candidats par ID (num√©riquement)
            const sortedCandidates = [...CANDIDATES].sort((a, b) => {
                const idA = parseInt(a.id) || 0;
                const idB = parseInt(b.id) || 0;
                return idA - idB;
            });
            
            sortedCandidates.forEach(candidate => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td><input type="text" value="${candidate.id}" onchange="updateCandidateId('${candidate.id}', this.value)" style="width: 70px; padding: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px; text-align: center; font-family: monospace;"></td>
                    <td><input type="text" value="${candidate.name}" onchange="updateCandidateName('${candidate.id}', this.value)" style="width: 100%; padding: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px;"></td>
                    <td class="actions">
                        <button class="icon-btn delete" onclick="deleteCandidate('${candidate.id}')" title="Supprimer">üóëÔ∏è</button>
                    </td>
                `;
            });
        }

        loadList();

        // --- GESTION JURY ---
        let JURIES = [];
        
        const loadJuries = async () => {
            const accountsSnap = await getDocs(collection(db, "accounts"));
            JURIES = [];
            accountsSnap.forEach(docSnap => {
                JURIES.push({
                    id: docSnap.id,  // ID num√©rique (jury1, jury2, etc.)
                    name: docSnap.data().name || docSnap.id,  // Nom affich√©
                    password: docSnap.data().password || '',
                    theme: docSnap.data().theme || 'light',
                    createdAt: docSnap.data().createdAt
                });
            });
            
            // Trier par ID
            JURIES.sort((a, b) => {
                const numA = parseInt(a.id.replace('jury', ''));
                const numB = parseInt(b.id.replace('jury', ''));
                return numA - numB;
            });
            
            // Mettre √† jour le textarea avec la liste des noms de jurys
            const textarea = document.getElementById('jury-names');
            if (textarea) {
                textarea.value = JURIES.map(j => j.name).join('\n');
            }
            
            renderJuryTable();
        };
        
        // Fonction utilitaire pour g√©n√©rer le prochain ID de jury
        async function getNextJuryId() {
            const accountsSnap = await getDocs(collection(db, "accounts"));
            let maxNum = 0;
            accountsSnap.forEach(doc => {
                const match = doc.id.match(/^jury(\d+)$/);
                if (match) {
                    const num = parseInt(match[1]);
                    if (num > maxNum) maxNum = num;
                }
            });
            return `jury${maxNum + 1}`;
        }
        
        window.importJuries = async () => {
            const names = document.getElementById('jury-names').value.split('\n').map(n => n.trim()).filter(n => n !== "");
            if (names.length === 0) {
                alert("Veuillez entrer au moins un jury");
                return;
            }
            
            // Charger les jurys existants
            await loadJuries();
            
            // Cr√©er un Set des noms existants pour v√©rification rapide
            const existingNames = new Set(JURIES.map(j => j.name.toLowerCase()));
            
            // Ajouter uniquement les nouveaux jurys
            const newJuries = [];
            const duplicates = [];
            
            for (const name of names) {
                if (existingNames.has(name.toLowerCase())) {
                    duplicates.push(name);
                } else {
                    const juryId = await getNextJuryId();
                    await setDoc(doc(db, "accounts", juryId), {
                        name: name,
                        password: '',
                        theme: 'light',
                        createdAt: new Date()
                    });
                    newJuries.push(name);
                    existingNames.add(name.toLowerCase());
                }
            }
            
            // Message de confirmation
            let message = `‚úì ${newJuries.length} nouveau(x) jury(s) ajout√©(s)`;
            if (duplicates.length > 0) {
                message += `\n‚ö†Ô∏è ${duplicates.length} jury(s) d√©j√† existant(s) ignor√©(s):\n${duplicates.join(', ')}`;
            }
            alert(message);
            
            await loadJuries();
        };
        
        window.addJury = async () => {
            // Ajouter un jury avec un nom par d√©faut
            const juryId = await getNextJuryId();
            const juryNumber = JURIES.length + 1;
            
            await setDoc(doc(db, "accounts", juryId), {
                name: `Jury ${juryNumber}`,
                password: '',
                theme: 'light',
                createdAt: new Date()
            });
            
            await loadJuries();
        };
        
        window.deleteJury = async (juryId) => {
            const jury = JURIES.find(j => j.id === juryId);
            if (!jury) return;
            
            if (!await confirm(`Supprimer le jury "${jury.name}" et toutes ses notations ?`)) return;
            
            // Supprimer le compte
            await deleteDoc(doc(db, "accounts", juryId));
            
            // Supprimer toutes les notations de ce jury
            const scoresQuery = query(collection(db, "scores"), where("juryId", "==", juryId));
            const scoresSnap = await getDocs(scoresQuery);
            const batch = writeBatch(db);
            scoresSnap.forEach(doc => batch.delete(doc.ref));
            await batch.commit();
            
            await loadJuries();
        };
        
        window.updateJuryName = async (juryId, newName) => {
            if (!newName || !newName.trim()) {
                await loadJuries();
                return;
            }
            
            const jury = JURIES.find(j => j.id === juryId);
            if (!jury || jury.name === newName.trim()) {
                await loadJuries();
                return;
            }
            
            // Simplement mettre √† jour le nom dans le document
            await setDoc(doc(db, "accounts", juryId), {
                name: newName.trim()
            }, { merge: true });
            
            // Mettre √† jour le champ d√©normalis√© juryName dans tous les scores
            const scoresQuery = query(collection(db, "scores"), where("juryId", "==", juryId));
            const scoresSnap = await getDocs(scoresQuery);
            if (!scoresSnap.empty) {
                const batch = writeBatch(db);
                scoresSnap.forEach(docSnap => {
                    batch.update(docSnap.ref, { juryName: newName.trim() });
                });
                await batch.commit();
            }
            
            await loadJuries();
        };
        
        window.resetJuryPassword = async (juryId) => {
            const jury = JURIES.find(j => j.id === juryId);
            if (!jury) return;
            
            if (!await confirm(`R√©initialiser le mot de passe de "${jury.name}" (vide) ?`)) return;
            
            await setDoc(doc(db, "accounts", juryId), {
                password: ''
            }, { merge: true });
            
            alert('Mot de passe r√©initialis√© √† vide');
            await loadJuries();
        };
        
        function renderJuryTable() {
            const tbody = document.getElementById('jury-table-body');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            
            JURIES.forEach(jury => {
                const row = tbody.insertRow();
                const passwordDisplay = jury.password ? 'üîí D√©fini' : 'üîì Vide';
                // Extraire le num√©ro de l'ID (jury1 -> 1, jury2 -> 2, etc.)
                const juryNumber = jury.id.replace('jury', '');
                row.innerHTML = `
                    <td style="text-align: center; color: var(--text-secondary); font-family: monospace;">${juryNumber}</td>
                    <td><input type="text" value="${jury.name}" onchange="updateJuryName('${jury.id}', this.value)" style="width: 100%; padding: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px;"></td>
                    <td style="text-align: center;">${passwordDisplay}</td>
                    <td class="actions">
                        <button class="icon-btn" onclick="resetJuryPassword('${jury.id}')" title="R√©initialiser le mot de passe">üîë</button>
                        <button class="icon-btn delete" onclick="deleteJury('${jury.id}')" title="Supprimer">üóëÔ∏è</button>
                    </td>
                `;
            });
        }
        
        loadJuries();
        
        // Charger le th√®me admin depuis Firebase au chargement
        async function loadAdminTheme() {
            try {
                const adminDoc = await getDoc(doc(db, "config", "admin"));
                if (adminDoc.exists()) {
                    const adminTheme = adminDoc.data().theme || 'light';
                    localStorage.setItem('theme_admin', adminTheme);
                    // R√©appliquer le th√®me
                    initTheme();
                }
            } catch (e) {
                console.log('Impossible de charger le th√®me admin:', e);
            }
        }
        loadAdminTheme();

        // --- GESTION TOURS ---
        const loadRounds = async () => {
            const snap = await getDoc(doc(db, "config", "rounds"));
            if (snap.exists()) {
                ROUNDS = snap.data().rounds || [];
                activeRoundId = snap.data().activeRoundId || null;
            }
            
            // Initialiser avec les tours par d√©faut si aucun n'existe
            if (ROUNDS.length === 0) {
                ROUNDS = [
                    {
                        id: 'round1',
                        order: 1,
                        name: '1er tour',
                        type: 'Notation individuelle',
                        nextRoundCandidates: 'ALL',
                        active: true
                    },
                    {
                        id: 'round2',
                        order: 2,
                        name: 'Repechage 1er tour',
                        type: 'Rep√™chage',
                        nextRoundCandidates: 18,
                        active: false
                    },
                    {
                        id: 'round3',
                        order: 3,
                        name: '2eme tour',
                        type: 'Duels',
                        nextRoundCandidates: 'ALL',
                        active: false
                    },
                    {
                        id: 'round4',
                        order: 4,
                        name: 'Repechage 2eme tour',
                        type: 'Rep√™chage',
                        nextRoundCandidates: 7,
                        active: false
                    },
                    {
                        id: 'round5',
                        order: 5,
                        name: 'Demi-finale',
                        type: 'Duels',
                        nextRoundCandidates: 3,
                        active: false
                    },
                    {
                        id: 'round6',
                        order: 6,
                        name: 'Finale',
                        type: 'Duels',
                        nextRoundCandidates: 1,
                        active: false
                    }
                ];
                activeRoundId = 'round1';
                await saveRounds();
            }
            
            renderRoundsTable();
        };
        
        async function saveRounds() {
            await setDoc(doc(db, "config", "rounds"), { 
                rounds: ROUNDS,
                activeRoundId: activeRoundId
            });
            renderRoundsTable();
        }
        
        function renderRoundsTable() {
            const tbody = document.getElementById('rounds-table-body');
            const select = document.getElementById('active-round-select');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            
            // Trier par ordre
            const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
            
            sortedRounds.forEach(round => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td class="actions">
                        <button class="icon-btn delete" onclick="deleteRound('${round.id}')" title="Supprimer">üóëÔ∏è</button>
                    </td>
                    <td><input type="number" value="${round.order}" onchange="updateRoundField('${round.id}', 'order', parseInt(this.value))" style="width: 60px; padding: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px;"></td>
                    <td><input type="text" value="${round.name}" onchange="updateRoundField('${round.id}', 'name', this.value)" style="width: 100%; padding: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px;"></td>
                    <td>
                        <select onchange="updateRoundField('${round.id}', 'type', this.value)" style="width: 100%; min-width: 200px; padding: 6px 8px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px; font-size: 13px;">
                            <option value="Notation individuelle" ${round.type === 'Notation individuelle' ? 'selected' : ''}>Notation individuelle</option>
                            <option value="Rep√™chage" ${round.type === 'Rep√™chage' ? 'selected' : ''}>Rep√™chage</option>
                            <option value="Duels" ${round.type === 'Duels' ? 'selected' : ''}>Duels</option>
                            <option value="Classement" ${round.type === 'Classement' ? 'selected' : ''}>Classement</option>
                        </select>
                    </td>
                    <td><input type="text" value="${round.nextRoundCandidates}" onchange="updateRoundField('${round.id}', 'nextRoundCandidates', this.value)" style="width: 100%; padding: 5px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px;" placeholder="ALL ou nombre"></td>
                `;
            });
            
            // Mettre √† jour le dropdown du tour actif
            if (select) {
                select.innerHTML = '<option value="">-- S√©lectionner un tour --</option>';
                sortedRounds.forEach(round => {
                    const option = document.createElement('option');
                    option.value = round.id;
                    option.textContent = round.name;
                    option.selected = (round.id === activeRoundId);
                    select.appendChild(option);
                });
            }
            
        }
        
        window.addRound = () => {
            // Cr√©er un nouveau tour avec des valeurs par d√©faut
            const newId = `round${Date.now()}`;
            const newOrder = ROUNDS.length > 0 ? Math.max(...ROUNDS.map(r => r.order)) + 1 : 1;
            const roundNumber = ROUNDS.length + 1;
            
            ROUNDS.push({
                id: newId,
                order: newOrder,
                name: `Tour #${roundNumber}`,
                type: 'Notation individuelle',
                nextRoundCandidates: 'ALL',
                active: false
            });
            
            saveRounds();
        };
        
        window.editRound = async (roundId) => {
            const round = ROUNDS.find(r => r.id === roundId);
            if (!round) return;
            
            const name = await prompt("Nom du tour:", round.name);
            if (!name || !name.trim()) return;
            
            const typeNum = {
                'Notation individuelle': '1',
                'Rep√™chage': '2',
                'Duels': '3',
                'Classement': '4'
            }[round.type] || '1';
            
            const type = await prompt(`Type du tour:\n1 - Notation individuelle\n2 - Rep√™chage\n3 - Duels\n4 - Classement\n\nEntrez le num√©ro:`, typeNum);
            const types = {
                '1': 'Notation individuelle',
                '2': 'Rep√™chage',
                '3': 'Duels',
                '4': 'Classement'
            };
            
            if (!types[type]) {
                alert("Type invalide");
                return;
            }
            
            const nextCandidates = await prompt("Nombre de candidats pour le tour suivant (ou 'ALL' pour tous):", 
                round.nextRoundCandidates === 'ALL' ? 'ALL' : round.nextRoundCandidates.toString());
            if (!nextCandidates || !nextCandidates.trim()) return;
            
            const candidates = nextCandidates.toUpperCase() === 'ALL' ? 'ALL' : parseInt(nextCandidates);
            if (candidates !== 'ALL' && isNaN(candidates)) {
                alert("Nombre invalide");
                return;
            }
            
            round.name = name.trim();
            round.type = types[type];
            round.nextRoundCandidates = candidates;
            
            saveRounds();
        };
        
        window.deleteRound = async (roundId) => {
            const round = ROUNDS.find(r => r.id === roundId);
            if (!round) return;
            
            // V√©rifier si ce tour contient des scores
            const scoresSnap = await getDocs(query(collection(db, "scores"), where("roundId", "==", roundId)));
            if (!scoresSnap.empty) {
                if (!await confirm(`Ce tour contient ${scoresSnap.size} notation(s). Supprimer le tour ET toutes ses notations ?`)) {
                    return;
                }
                
                // Supprimer tous les scores du tour
                const batch = writeBatch(db);
                scoresSnap.forEach(doc => batch.delete(doc.ref));
                await batch.commit();
            } else {
                if (!await confirm(`Supprimer le tour "${round.name}" ?`)) {
                    return;
                }
            }
            
            ROUNDS = ROUNDS.filter(r => r.id !== roundId);
            
            // Si on supprime le tour actif, activer le premier tour disponible
            if (activeRoundId === roundId && ROUNDS.length > 0) {
                activeRoundId = ROUNDS[0].id;
                ROUNDS[0].active = true;
            }
            
            saveRounds();
        };
        
        window.setActiveRound = (roundId) => {
            ROUNDS.forEach(r => r.active = (r.id === roundId));
            activeRoundId = roundId;
            saveRounds();
        };
        
        window.finishRound = async () => {
            if (!activeRoundId) {
                await customAlert("Aucun tour actif s√©lectionn√©.");
                return;
            }
            
            const activeRound = ROUNDS.find(r => r.id === activeRoundId);
            if (!activeRound) {
                await customAlert("Tour actif introuvable.");
                return;
            }
            
            // V√©rifier que tous les candidats du tour actif sont soit qualifi√©s soit √©limin√©s
            const candidatesInRound = CANDIDATES.filter(c => c.tour === activeRoundId);
            const candidatesNotReady = candidatesInRound.filter(c => c.status !== 'Qualifie' && c.status !== 'Elimine');
            
            if (candidatesNotReady.length > 0) {
                const names = candidatesNotReady.map(c => `- ${c.name} (${c.status})`).join('\n');
                await customAlert(`‚ùå Impossible de terminer le tour.\n\n${candidatesNotReady.length} candidat(s) ne sont ni Qualifi√©s ni √âlimin√©s :\n\n${names}\n\nVeuillez mettre √† jour leur statut dans l'onglet "Notes".`);
                return;
            }
            
            // Trouver le tour suivant
            const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
            const currentIndex = sortedRounds.findIndex(r => r.id === activeRoundId);
            
            if (currentIndex === -1) {
                await customAlert("Erreur : impossible de trouver le tour actif.");
                return;
            }
            
            if (currentIndex >= sortedRounds.length - 1) {
                await customAlert("C'est le dernier tour. Impossible de passer au tour suivant.");
                return;
            }
            
            const nextRound = sortedRounds[currentIndex + 1];
            
            // Demander confirmation
            const qualifiedCount = candidatesInRound.filter(c => c.status === 'Qualifie').length;
            const eliminatedCount = candidatesInRound.filter(c => c.status === 'Elimine').length;
            
            if (!await customConfirm(`Terminer le tour "${activeRound.name}" ?\n\n‚úì ${qualifiedCount} candidat(s) qualifi√©(s) passeront au tour "${nextRound.name}"\n‚úó ${eliminatedCount} candidat(s) √©limin√©(s)\n\nContinuer ?`)) {
                return;
            }
            
            // Passer les candidats qualifi√©s au tour suivant et les remettre en "Actif"
            let movedCount = 0;
            CANDIDATES.forEach(candidate => {
                if (candidate.tour === activeRoundId && candidate.status === 'Qualifie') {
                    candidate.tour = nextRound.id;
                    candidate.status = 'Actif';
                    movedCount++;
                }
            });
            
            // Sauvegarder les modifications
            await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: CANDIDATES });
            
            // Changer le tour actif
            activeRoundId = nextRound.id;
            ROUNDS.forEach(r => r.active = (r.id === activeRoundId));
            await saveRounds();
            
            await customAlert(`‚úì Tour termin√© avec succ√®s !\n\n${movedCount} candidat(s) qualifi√©(s) sont pass√©s au tour "${nextRound.name}".\n\nLe tour actif est maintenant : "${nextRound.name}"`);
            
            // Rafra√Æchir l'affichage
            renderNotesTable();
        };
        
        loadRounds();

        // --- GESTION NOTES ---
        // Variables globales pour le tri du tableau Notes et l'affichage des tours
        let notesSortColumn = 'id'; // Tri par d√©faut par ID
        let notesSortAscending = true;
        let notesDisplayRound = null; // Tour affich√© dans le tableau Notes
        let podiumDisplayRound = null; // Tour affich√© dans le podium
        
        async function renderNotesTable() {
            const tbody = document.getElementById('notes-table-body');
            const thead = document.querySelector('#notes-table thead tr');
            tbody.innerHTML = '';
            
            // Utiliser le tour s√©lectionn√© dans le dropdown ou le tour actif par d√©faut
            const displayRound = notesDisplayRound || activeRoundId || 'round1';
            
            // Charger TOUS les jurys depuis la collection accounts
            await loadJuries();
            const sortedJuries = [...JURIES].sort((a, b) => a.name.localeCompare(b.name));
            
            // Charger les scores du tour s√©lectionn√©
            const q = query(
                collection(db, "scores"),
                where("roundId", "==", displayRound)
            );
            const querySnapshot = await getDocs(q);
            const scoresByCandidate = {};
            
            querySnapshot.forEach(docSnap => {
                const data = docSnap.data();
                const juryId = data.juryId || data.juryName;
                if (!scoresByCandidate[data.candidateId]) {
                    scoresByCandidate[data.candidateId] = {};
                }
                scoresByCandidate[data.candidateId][juryId] = {
                    id: docSnap.id,
                    score1: data.score1,
                    score2: data.score2
                };
            });
            
            // Calculer le score total pour chaque candidat
            let candidatesWithScores = CANDIDATES.map(candidate => {
                let totalScore = 0;
                let hasScores = false;
                
                sortedJuries.forEach(jury => {
                    const scores = scoresByCandidate[candidate.id]?.[jury.id];
                    if (scores) {
                        const s1 = parseFloat(scores.score1) || 0;
                        const s2 = parseFloat(scores.score2) || 0;
                        if (scores.score1 !== '-' && scores.score1 !== 'EL' &&
                            scores.score2 !== '-' && scores.score2 !== 'EL') {
                            totalScore += (s1 * 3 + s2);
                            hasScores = true;
                        }
                    }
                });
                
                return {
                    candidate,
                    totalScore: hasScores ? totalScore : null,
                    scoresByJury: scoresByCandidate[candidate.id] || {}
                };
            });
            
            // Filtrer par tour si le checkbox est coch√©
            const filterCheckbox = document.getElementById('notes-filter-current-round');
            if (filterCheckbox && filterCheckbox.checked) {
                candidatesWithScores = candidatesWithScores.filter(item => 
                    item.candidate.tour === displayRound
                );
            }
            
            // Appliquer le tri si une colonne est s√©lectionn√©e
            if (notesSortColumn) {
                candidatesWithScores.sort((a, b) => {
                    let valA, valB;
                    
                    if (notesSortColumn === 'id') {
                        valA = parseInt(a.candidate.id) || 0;
                        valB = parseInt(b.candidate.id) || 0;
                    } else if (notesSortColumn === 'candidat') {
                        valA = a.candidate.name.toLowerCase();
                        valB = b.candidate.name.toLowerCase();
                    } else if (notesSortColumn === 'score') {
                        valA = a.totalScore !== null ? a.totalScore : -Infinity;
                        valB = b.totalScore !== null ? b.totalScore : -Infinity;
                    } else if (notesSortColumn === 'tour') {
                        const roundA = ROUNDS.find(r => r.id === a.candidate.tour);
                        const roundB = ROUNDS.find(r => r.id === b.candidate.tour);
                        valA = roundA ? roundA.name.toLowerCase() : '';
                        valB = roundB ? roundB.name.toLowerCase() : '';
                    } else if (notesSortColumn === 'statut') {
                        valA = a.candidate.status.toLowerCase();
                        valB = b.candidate.status.toLowerCase();
                    }
                    
                    if (valA < valB) return notesSortAscending ? -1 : 1;
                    if (valA > valB) return notesSortAscending ? 1 : -1;
                    return 0;
                });
            }
            
            // Construire l'en-t√™te avec colonnes triables
            const sortIcon = (col) => {
                if (notesSortColumn === col) {
                    return notesSortAscending ? ' ‚ñ≤' : ' ‚ñº';
                }
                return '';
            };
            
            thead.innerHTML = `
                <th style="width: 60px; cursor: pointer;" onclick="sortNotesTable('id')">ID${sortIcon('id')}</th>
                <th class="col-candidate" style="cursor: pointer;" onclick="sortNotesTable('candidat')">Candidat${sortIcon('candidat')}</th>
                <th style="width: 100px; cursor: pointer;" onclick="sortNotesTable('score')">Score${sortIcon('score')}</th>
                <th style="min-width: 200px; width: 200px; cursor: pointer;" onclick="sortNotesTable('tour')">Dernier Tour${sortIcon('tour')}</th>
                <th style="width: 150px; cursor: pointer;" onclick="sortNotesTable('statut')">Statut${sortIcon('statut')}</th>
                ${sortedJuries.map(j => `<th colspan="2" class="col-score" style="min-width: 180px;">${j.name}<br><small>(Fond | Forme)</small></th>`).join('')}
            `;
            
            // Construire les lignes
            candidatesWithScores.forEach(item => {
                const candidate = item.candidate;
                const row = tbody.insertRow();
                
                // ID
                const idCell = row.insertCell();
                idCell.textContent = candidate.id;
                idCell.style.textAlign = 'center';
                
                // Nom du candidat
                const nameCell = row.insertCell();
                nameCell.className = 'candidate-name col-candidate';
                nameCell.textContent = candidate.name;
                
                // Score total
                const scoreCell = row.insertCell();
                scoreCell.textContent = item.totalScore !== null ? item.totalScore.toFixed(0) : '-';
                scoreCell.style.textAlign = 'center';
                scoreCell.style.fontWeight = 'bold';
                
                // Tour
                const tourCell = row.insertCell();
                tourCell.innerHTML = createTourDropdown(candidate);
                
                // Statut
                const statusCell = row.insertCell();
                statusCell.innerHTML = createStatusDropdown(candidate);
                
                // Notes par jury
                sortedJuries.forEach(jury => {
                    const scores = item.scoresByJury[jury.id];
                    
                    const cell1 = row.insertCell();
                    const cell2 = row.insertCell();
                    cell1.className = 'col-score';
                    cell2.className = 'col-score';
                    cell1.style.minWidth = '90px';
                    cell1.style.width = '90px';
                    cell2.style.minWidth = '90px';
                    cell2.style.width = '90px';
                    
                    // Si le statut est "Elimine" ou "Qualifie", les notes ne sont pas √©ditables
                    const readonly = (candidate.status === 'Elimine' || candidate.status === 'Qualifie');
                    
                    if (scores) {
                        cell1.innerHTML = createScoreDropdown(scores.id, 'score1', scores.score1, candidate.id, jury.id, readonly);
                        cell2.innerHTML = createScoreDropdown(scores.id, 'score2', scores.score2, candidate.id, jury.id, readonly);
                    } else {
                        cell1.innerHTML = createScoreDropdown(null, 'score1', '-', candidate.id, jury.id, readonly);
                        cell2.innerHTML = createScoreDropdown(null, 'score2', '-', candidate.id, jury.id, readonly);
                    }
                });
            });
        }
        
        window.sortNotesTable = (column) => {
            if (notesSortColumn === column) {
                notesSortAscending = !notesSortAscending;
            } else {
                notesSortColumn = column;
                notesSortAscending = true;
            }
            renderNotesTable();
        };
        
        // Fonction pour remplir le dropdown des tours dans l'onglet Notes
        function populateNotesRoundDropdown() {
            const select = document.getElementById('notes-round-select');
            if (!select) return;
            
            select.innerHTML = '';
            const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
            
            sortedRounds.forEach(round => {
                const option = document.createElement('option');
                option.value = round.id;
                option.textContent = round.name;
                option.selected = (round.id === (notesDisplayRound || activeRoundId));
                select.appendChild(option);
            });
        }
        
        // Fonction pour remplir le dropdown des tours dans l'onglet Podium
        function populatePodiumRoundDropdown() {
            const select = document.getElementById('podium-round-select');
            if (!select) return;
            
            select.innerHTML = '';
            const sortedRounds = [...ROUNDS].sort((a, b) => a.order - b.order);
            
            sortedRounds.forEach(round => {
                const option = document.createElement('option');
                option.value = round.id;
                option.textContent = round.name;
                option.selected = (round.id === (podiumDisplayRound || activeRoundId));
                select.appendChild(option);
            });
        }
        
        // Fonction pour changer le tour affich√© dans Notes
        window.changeNotesRound = (roundId) => {
            notesDisplayRound = roundId;
            renderNotesTable();
        };
        
        // Fonction pour changer le tour affich√© dans Podium
        window.changePodiumRound = (roundId) => {
            podiumDisplayRound = roundId;
            loadResults();
        };
        
        function createTourDropdown(candidate) {
            let html = `<select onchange="updateCandidateTour('${candidate.id}', this.value)" style="width: 100%; min-width: 180px; padding: 6px 8px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px; font-size: 13px;">`;
            ROUNDS.forEach(round => {
                const selected = round.id === candidate.tour ? 'selected' : '';
                html += `<option value="${round.id}" ${selected}>${round.name}</option>`;
            });
            html += '</select>';
            return html;
        }
        
        function createStatusDropdown(candidate) {
            const statuses = ['Actif', 'Reset', 'Elimine', 'Qualifie'];
            let html = `<select onchange="updateCandidateStatus('${candidate.id}', this.value)" style="width: 100%; min-width: 130px; padding: 6px 8px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 3px; font-size: 13px;">`;
            statuses.forEach(status => {
                const selected = status === candidate.status ? 'selected' : '';
                html += `<option value="${status}" ${selected}>${status}</option>`;
            });
            html += '</select>';
            return html;
        }
        
        window.updateCandidateTour = async (candidateId, newTour) => {
            const candidate = CANDIDATES.find(c => c.id === candidateId);
            if (candidate) {
                candidate.tour = newTour;
                await saveCandidates();
                renderNotesTable();
            }
        };
        
        window.updateCandidateStatus = async (candidateId, newStatus) => {
            const candidate = CANDIDATES.find(c => c.id === candidateId);
            if (!candidate) return;
            
            const oldStatus = candidate.status;
            candidate.status = newStatus;
            
            // Si on passe √† "Reset", r√©initialiser les notes et revenir √† "Actif"
            if (newStatus === 'Reset') {
                await resetCandidateScores(candidateId);
                candidate.status = 'Actif';
            }
            
            await saveCandidates();
            renderNotesTable();
            await loadResults();
        };
        
        // Fonction pour v√©rifier si un candidat a toutes ses notes d√©finies et le qualifier automatiquement
        async function checkAndQualifyCandidate(candidateId) {
            const candidate = CANDIDATES.find(c => c.id === candidateId);
            if (!candidate || candidate.status !== 'Actif') return;
            
            // Charger toutes les notes du candidat pour le tour actif
            const q = query(
                collection(db, "scores"),
                where("candidateId", "==", candidateId),
                where("roundId", "==", activeRoundId || 'round1')
            );
            const querySnapshot = await getDocs(q);
            
            // V√©rifier si toutes les notes sont d√©finies (score1 ET score2 par jury)
            const juryScores = {};
            querySnapshot.forEach(docSnap => {
                const data = docSnap.data();
                const juryId = data.juryId || data.juryName;
                juryScores[juryId] = {
                    score1: data.score1,
                    score2: data.score2
                };
            });
            
            // V√©rifier que chaque jury a ses deux notes compl√®tes
            let allComplete = true;
            if (JURIES.length === 0) {
                allComplete = false;
            } else {
                for (const jury of JURIES) {
                    const scores = juryScores[jury.id];
                    if (!scores || 
                        !scores.score1 || scores.score1 === '-' || scores.score1 === 'EL' ||
                        !scores.score2 || scores.score2 === '-' || scores.score2 === 'EL') {
                        allComplete = false;
                        break;
                    }
                }
            }
            
            if (allComplete) {
                candidate.status = 'Qualifie';
                await saveCandidates();
            }
        }

        function createScoreDropdown(scoreId, field, currentValue, candidateId, juryId, readonly = false) {
            const options = ['-', '5', '10', '15', '20', 'EL'];
            const selectId = `score-${candidateId}-${juryId}-${field}`;
            const disabledAttr = readonly ? 'disabled' : '';
            
            let html = `<select id="${selectId}" onchange="handleScoreChange('${scoreId}', '${field}', this.value, '${candidateId}', '${juryId}')" ${disabledAttr} style="text-align: center;">`;
            options.forEach(opt => {
                const selected = opt === String(currentValue) ? 'selected' : '';
                html += `<option value="${opt}" ${selected}>${opt}</option>`;
            });
            html += '</select>';
            return html;
        }

        window.handleScoreChange = async function(scoreId, field, value, candidateId, juryId) {
            if (value === '-') {
                // Supprimer le score s'il existe
                if (scoreId && scoreId !== 'null') {
                    await deleteDoc(doc(db, "scores", scoreId));
                }
            } else {
                // Cr√©er ou mettre √† jour le score
                if (scoreId && scoreId !== 'null') {
                    await updateScore(scoreId, field, value);
                } else {
                    await createScore(candidateId, juryId, field, value);
                }
            }
            
            // V√©rifier si le candidat doit √™tre qualifi√© automatiquement
            await checkAndQualifyCandidate(candidateId);
            
            // Rafra√Æchir les deux onglets
            renderNotesTable();
            await loadResults();
        };

        async function createScore(candidateId, juryNameOrId, field, value) {
            // juryNameOrId est maintenant le juryId dans le nouveau syst√®me ou le nom dans l'ancien
            // On essaie d'abord par juryId, sinon par juryName (compatibilit√©)
            let q = query(collection(db, "scores"), 
                where("candidateId", "==", candidateId),
                where("juryId", "==", juryNameOrId),
                where("roundId", "==", activeRoundId || 'round1'));
            let snap = await getDocs(q);
            
            // Si pas trouv√© par juryId, essayer par juryName (ancien syst√®me)
            if (snap.empty) {
                q = query(collection(db, "scores"), 
                    where("candidateId", "==", candidateId),
                    where("juryName", "==", juryNameOrId),
                    where("roundId", "==", activeRoundId || 'round1'));
                snap = await getDocs(q);
            }
            
            if (snap.empty) {
                // Cr√©er nouveau score - d√©terminer si on a un juryId ou juryName
                let juryId, juryName;
                if (juryNameOrId.startsWith('jury')) {
                    // C'est un ID num√©rique
                    juryId = juryNameOrId;
                    const juryDoc = await getDoc(doc(db, "accounts", juryId));
                    juryName = juryDoc.exists() ? (juryDoc.data().name || juryId) : juryId;
                } else {
                    // C'est un ancien nom - chercher l'ID
                    const accountsSnap = await getDocs(collection(db, "accounts"));
                    accountsSnap.forEach(d => {
                        if ((d.data().name || d.id) === juryNameOrId) {
                            juryId = d.id;
                            juryName = juryNameOrId;
                        }
                    });
                    // Si pas trouv√©, utiliser le nom comme ID (compatibilit√©)
                    if (!juryId) {
                        juryId = juryNameOrId;
                        juryName = juryNameOrId;
                    }
                }
                
                const data = {
                    candidateId: candidateId,
                    juryId: juryId,
                    juryName: juryName,
                    roundId: activeRoundId || 'round1',
                    score1: field === 'score1' ? value : '-',
                    score2: field === 'score2' ? value : '-',
                    timestamp: new Date()
                };
                
                await addDoc(collection(db, "scores"), data);
            } else {
                // Si des doublons existent, les nettoyer
                if (snap.docs.length > 1) {
                    console.warn(`‚ö†Ô∏è ${snap.docs.length} doublons trouv√©s pour ${candidateId}/${juryName}, nettoyage...`);
                    // Garder le plus r√©cent, supprimer les autres
                    const sorted = snap.docs.sort((a, b) => {
                        const timeA = a.data().timestamp?.toDate?.() || new Date(0);
                        const timeB = b.data().timestamp?.toDate?.() || new Date(0);
                        return timeB - timeA;
                    });
                    
                    // Supprimer tous sauf le premier (le plus r√©cent)
                    for (let i = 1; i < sorted.length; i++) {
                        await deleteDoc(doc(db, "scores", sorted[i].id));
                    }
                }
                
                // Mettre √† jour le score existant (ou le seul restant apr√®s nettoyage)
                const scoreDoc = snap.docs[0];
                await updateScore(scoreDoc.id, field, value);
            }
        }

        window.updateScore = async (scoreId, field, value) => {
            try {
                const scoreRef = doc(db, "scores", scoreId);
                const scoreSnap = await getDoc(scoreRef);
                
                if (!scoreSnap.exists()) return;
                
                const data = scoreSnap.data();
                data[field] = value;
                
                // Ne pas stocker totalWeightedScore - il sera calcul√© √† la vol√©e
                delete data.totalWeightedScore;
                
                await setDoc(scoreRef, data);
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la mise √† jour: ' + e.message);
            }
        };

        async function resetCandidateScores(candidateId) {
            // Supprimer toutes les notes de ce candidat pour le tour actif
            const scoresQuery = query(
                collection(db, "scores"), 
                where("candidateId", "==", candidateId),
                where("roundId", "==", activeRoundId || 'round1')
            );
            const scoresSnap = await getDocs(scoresQuery);
            
            for (const scoreDoc of scoresSnap.docs) {
                await deleteDoc(doc(db, "scores", scoreDoc.id));
            }
            
            // D√©verrouiller automatiquement ce candidat apr√®s r√©initialisation (compatibilit√©)
            if (candidateLocks[candidateId]) {
                delete candidateLocks[candidateId];
                await setDoc(doc(db, "config", "locks"), { locks: candidateLocks });
            }
        }

        // --- CALCUL DES SCORES ---
        window.loadResults = async () => {
            // Utiliser le tour s√©lectionn√© dans le dropdown du podium ou le tour actif par d√©faut
            const displayRound = podiumDisplayRound || activeRoundId || 'round1';
            
            // Charger les scores du tour s√©lectionn√©
            const q = query(
                collection(db, "scores"),
                where("roundId", "==", displayRound)
            );
            const querySnapshot = await getDocs(q);
            aggregatedData = {};
            const juries = new Set();

            CANDIDATES.forEach(c => {
                aggregatedData[c.id] = { name: c.name, total: 0, juryScores: {}, elimCount: 0, hasScores: false };
            });

            // Utiliser un Set pour d√©tecter et √©viter les doublons
            const processedKeys = new Set();

            querySnapshot.forEach(doc => {
                const data = doc.data();
                const key = `${data.candidateId}_${data.juryName}`;
                
                // Ignorer les doublons (garder seulement le premier rencontr√©)
                if (processedKeys.has(key)) {
                    console.warn(`‚ö†Ô∏è Doublon ignor√©: ${key}`);
                    return;
                }
                processedKeys.add(key);
                
                if (aggregatedData[data.candidateId]) {
                    juries.add(data.juryName);
                    aggregatedData[data.candidateId].hasScores = true;
                    aggregatedData[data.candidateId].juryScores[data.juryName] = data;
                    
                    if (data.score1 === "EL") {
                        aggregatedData[data.candidateId].elimCount++;
                    } else {
                        // TOUJOURS calculer le score pond√©r√© √† partir des scores bruts
                        // IGNORER compl√®tement toute valeur totalWeightedScore stock√©e
                        let weightedScore = 0;
                        if (data.score1 && data.score1 !== '-' && 
                            data.score2 && data.score2 !== '-' &&
                            data.score1 !== 'EL' && data.score2 !== 'EL') {
                            weightedScore = (parseInt(data.score1) * 3) + parseInt(data.score2);
                            console.log(`Candidat ${data.candidateId}, Jury ${data.juryName}: ${data.score1}√ó3 + ${data.score2} = ${weightedScore} (DB avait: ${data.totalWeightedScore})`);
                        }
                        aggregatedData[data.candidateId].total += weightedScore;
                    }
                }
            });

            renderMatrix(Array.from(juries).sort());
            renderPodium();
        };

        let currentSortColumn = -1;
        let currentSortDirection = 'desc'; // Start with descending for Total column
        let cachedSortedJuries = [];

        function renderMatrix(sortedJuries) {
            cachedSortedJuries = sortedJuries; // Cache for sorting
            
            const thead = document.querySelector("#scores-matrix thead tr");
            const tbody = document.querySelector("#scores-matrix tbody");
            
            // Build header with click handlers
            thead.innerHTML = "<th data-col='0' title='Cliquer pour trier'>Candidat</th>" + 
                sortedJuries.map((j, idx) => `<th data-col='${idx + 1}' title='Cliquer pour trier'>${j}</th>`).join('') + 
                "<th data-col='total' title='Cliquer pour trier'>Total</th>";
            
            // Add click handlers to headers
            thead.querySelectorAll('th').forEach((th, colIndex) => {
                th.addEventListener('click', () => sortTable(colIndex));
            });
            
            // Store data for sorting
            const candidateRows = CANDIDATES.map(c => {
                const data = aggregatedData[c.id];
                return { candidate: c, data: data };
            });
            
            // Sort if needed
            if (currentSortColumn >= 0) {
                candidateRows.sort((a, b) => {
                    let valA, valB;
                    
                    if (currentSortColumn === 0) {
                        // Sort by candidate name
                        valA = a.candidate.name.toLowerCase();
                        valB = b.candidate.name.toLowerCase();
                        return currentSortDirection === 'asc' ? 
                            valA.localeCompare(valB) : valB.localeCompare(valA);
                    } else if (currentSortColumn === sortedJuries.length + 1) {
                        // Sort by total
                        valA = a.data.total || 0;
                        valB = b.data.total || 0;
                        return currentSortDirection === 'asc' ? valA - valB : valB - valA;
                    } else {
                        // Sort by jury score
                        const juryName = sortedJuries[currentSortColumn - 1];
                        const scoreA = a.data.juryScores[juryName];
                        const scoreB = b.data.juryScores[juryName];
                        
                        // Calculate weighted scores
                        valA = 0;
                        valB = 0;
                        
                        if (scoreA && scoreA.score1 !== '-' && scoreA.score2 !== '-' && 
                            scoreA.score1 !== 'EL' && scoreA.score2 !== 'EL') {
                            valA = (parseInt(scoreA.score1) * 3) + parseInt(scoreA.score2);
                        }
                        if (scoreB && scoreB.score1 !== '-' && scoreB.score2 !== '-' && 
                            scoreB.score1 !== 'EL' && scoreB.score2 !== 'EL') {
                            valB = (parseInt(scoreB.score1) * 3) + parseInt(scoreB.score2);
                        }
                        
                        return currentSortDirection === 'asc' ? valA - valB : valB - valA;
                    }
                });
                
                // Update sort indicator
                thead.querySelectorAll('th').forEach(th => {
                    th.classList.remove('sorted-asc', 'sorted-desc');
                });
                thead.querySelectorAll('th')[currentSortColumn].classList.add(
                    currentSortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc'
                );
            }
            
            // Render rows
            tbody.innerHTML = "";
            candidateRows.forEach(({ candidate: c, data }) => {
                const row = tbody.insertRow();
                row.insertCell().innerHTML = `<b>${c.name}</b>`;
                
                sortedJuries.forEach(j => {
                    const scoreObj = data.juryScores[j];
                    const cell = row.insertCell();
                    if (scoreObj) {
                        if (scoreObj.score1 === "EL") {
                            cell.className = "eliminado";
                            cell.textContent = "√âLIMIN√â";
                        } else {
                            // Recalculer le weighted score pour l'affichage
                            let displayWeightedScore = 0;
                            if (scoreObj.score1 && scoreObj.score1 !== '-' && 
                                scoreObj.score2 && scoreObj.score2 !== '-' &&
                                scoreObj.score1 !== 'EL' && scoreObj.score2 !== 'EL') {
                                displayWeightedScore = (parseInt(scoreObj.score1) * 3) + parseInt(scoreObj.score2);
                            }
                            cell.innerHTML = `<span class="detail-note">${scoreObj.score1} | ${scoreObj.score2}</span><span class="weighted-total">${displayWeightedScore}</span>`;
                        }
                    } else { cell.textContent = "-"; }
                });
                const totalCell = row.insertCell();
                totalCell.className = "total-score";
                totalCell.textContent = data.total;
            });
        }

        function sortTable(colIndex) {
            if (currentSortColumn === colIndex) {
                // Toggle direction
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                // New column - default to descending for numbers, ascending for names
                currentSortColumn = colIndex;
                currentSortDirection = colIndex === 0 ? 'asc' : 'desc';
            }
            renderMatrix(cachedSortedJuries);
        }

        window.renderPodium = function() {
            const body = document.getElementById('podium-body');
            if (!body) return;
            
            body.innerHTML = "";
            
            // V√©rifier que les donn√©es sont charg√©es
            if (!aggregatedData || Object.keys(aggregatedData).length === 0) {
                const row = body.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 4;
                cell.textContent = "Aucune donn√©e. Les r√©sultats se calculent automatiquement en ouvrant cet onglet.";
                cell.style.textAlign = "center";
                cell.style.padding = "20px";
                cell.style.color = "var(--text-secondary)";
                return;
            }
            
            let list = Object.values(aggregatedData).filter(c => c.hasScores).sort((a,b) => b.total - a.total);
            
            // Limiter le nombre de r√©sultats affich√©s
            const limitInput = document.getElementById('result-limit');
            const limit = limitInput ? parseInt(limitInput.value || 3) : 3;
            list = list.slice(0, limit);
            
            if (list.length === 0) {
                const row = body.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 4;
                cell.textContent = "Aucun r√©sultat disponible.";
                cell.style.textAlign = "center";
                cell.style.padding = "20px";
                return;
            }
            
            list.forEach((c, i) => {
                const row = body.insertRow();
                if (c.elimCount >= 3) row.className = "eliminated-row";
                else if (i === 0) row.className = "rank-1";
                else if (i === 1) row.className = "rank-2";
                else if (i === 2) row.className = "rank-3";

                row.insertCell().textContent = c.elimCount >= 3 ? "‚Äî" : i + 1;
                row.insertCell().textContent = c.name;
                row.insertCell().textContent = c.total;
                row.insertCell().textContent = c.elimCount >= 3 ? `√âLIMIN√â (${c.elimCount} jurys)` : "Qualifi√©";
            });
        };

        // Migrer les scores vers le nouveau syst√®me avec juryId
        window.migrateScoresToJuryIds = async () => {
            if (!await confirm('Migrer tous les scores vers le nouveau syst√®me avec IDs num√©riques ?\n\nCela ajoutera un champ juryId √† tous les scores qui n\'en ont pas encore.')) {
                return;
            }
            
            try {
                // Charger tous les comptes jury
                const accountsSnap = await getDocs(collection(db, "accounts"));
                const juryNameToId = new Map();
                accountsSnap.forEach(doc => {
                    const juryName = doc.data().name || doc.id;
                    juryNameToId.set(juryName, doc.id);
                });
                
                // Charger tous les scores
                const scoresSnap = await getDocs(collection(db, "scores"));
                let migrated = 0;
                let skipped = 0;
                let notFound = 0;
                
                const batch = writeBatch(db);
                let batchCount = 0;
                
                for (const scoreDoc of scoresSnap.docs) {
                    const data = scoreDoc.data();
                    
                    // Si le score a d√©j√† un juryId, le sauter
                    if (data.juryId) {
                        skipped++;
                        continue;
                    }
                    
                    // Chercher le juryId correspondant au juryName
                    const juryId = juryNameToId.get(data.juryName);
                    
                    if (juryId) {
                        // Ajouter le juryId au score
                        batch.update(scoreDoc.ref, { juryId: juryId });
                        migrated++;
                        batchCount++;
                        
                        // Firestore batch limit is 500
                        if (batchCount >= 500) {
                            await batch.commit();
                            batchCount = 0;
                        }
                    } else {
                        notFound++;
                        console.warn(`‚ö†Ô∏è Jury non trouv√© pour le score: ${data.juryName}`);
                    }
                }
                
                // Commit remaining operations
                if (batchCount > 0) {
                    await batch.commit();
                }
                
                alert(`‚úì Migration termin√©e !\n\n${migrated} score(s) migr√©(s)\n${skipped} score(s) d√©j√† √† jour\n${notFound} jury(s) non trouv√©(s)`);
                
                // Rafra√Æchir l'affichage
                await loadResults();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la migration: ' + e.message);
            }
        };
        
        // Nettoyer et v√©rifier la conformit√© de la base de donn√©es
        window.cleanDatabase = async () => {
            if (!await confirm('‚ö†Ô∏è NETTOYAGE DE LA BASE DE DONN√âES ‚ö†Ô∏è\n\nCette op√©ration va :\n- Supprimer les doublons de scores\n- Supprimer les scores orphelins (candidats/jurys supprim√©s)\n- Nettoyer les valeurs calcul√©es obsol√®tes\n\nüíæ Recommandation : Sauvegardez votre base avant de continuer !\n\nContinuer le nettoyage ?')) {
                return;
            }
            
            try {
                let report = {
                    duplicatesRemoved: 0,
                    orphanScores: 0,
                    obsoleteFields: 0
                };
                
                // 1. Charger les candidats et jurys valides
                const candidatsSnap = await getDoc(doc(db, "candidats", "liste_actuelle"));
                const validCandidates = new Set(candidatsSnap.exists() ? (candidatsSnap.data().candidates || []).map(c => c.id) : []);
                
                const accountsSnap = await getDocs(collection(db, "accounts"));
                const validJuries = new Set();
                accountsSnap.forEach(d => {
                    validJuries.add(d.id); // juryId
                    validJuries.add(d.data().name || d.id); // juryName pour compatibilit√©
                });
                
                // 2. Analyser tous les scores
                const querySnapshot = await getDocs(collection(db, "scores"));
                const scoresByKey = {};
                const toDelete = [];
                
                querySnapshot.forEach(scoreDoc => {
                    const data = scoreDoc.data();
                    const key = `${data.candidateId}_${data.juryId || data.juryName}_${data.roundId || 'round1'}`;
                    
                    // V√©rifier si le score est orphelin
                    const isOrphan = !validCandidates.has(data.candidateId) || 
                                     (!validJuries.has(data.juryId) && !validJuries.has(data.juryName));
                    
                    if (isOrphan) {
                        toDelete.push({ id: scoreDoc.id, reason: 'orphan' });
                        report.orphanScores++;
                    } else {
                        // Grouper pour d√©tecter les doublons
                        if (!scoresByKey[key]) {
                            scoresByKey[key] = [];
                        }
                        scoresByKey[key].push({ 
                            id: scoreDoc.id, 
                            data: data, 
                            timestamp: data.timestamp 
                        });
                    }
                    
                    // V√©rifier les champs obsol√®tes
                    if ('totalWeightedScore' in data) {
                        toDelete.push({ id: scoreDoc.id, reason: 'obsoleteField', data: data });
                        report.obsoleteFields++;
                    }
                });
                
                // 3. Trouver les doublons
                for (const key in scoresByKey) {
                    const scores = scoresByKey[key];
                    if (scores.length > 1) {
                        // Trier par timestamp (le plus r√©cent en premier)
                        scores.sort((a, b) => {
                            const timeA = a.timestamp?.toDate?.() || new Date(0);
                            const timeB = b.timestamp?.toDate?.() || new Date(0);
                            return timeB - timeA;
                        });
                        
                        // Marquer les anciens pour suppression
                        for (let i = 1; i < scores.length; i++) {
                            toDelete.push({ id: scores[i].id, reason: 'duplicate' });
                            report.duplicatesRemoved++;
                        }
                    }
                }
                
                // 4. Supprimer les scores invalides/obsol√®tes
                for (const item of toDelete) {
                    if (item.reason === 'obsoleteField') {
                        // Juste enlever le champ obsol√®te
                        const { totalWeightedScore, ...cleanData } = item.data;
                        await setDoc(doc(db, "scores", item.id), cleanData);
                    } else {
                        // Supprimer compl√®tement (doublon ou orphelin)
                        await deleteDoc(doc(db, "scores", item.id));
                    }
                }
                
                await alert(`‚úì Nettoyage termin√© !\n\nüìä Rapport :\n- ${report.duplicatesRemoved} doublon(s) supprim√©(s)\n- ${report.orphanScores} score(s) orphelin(s) supprim√©(s)\n- ${report.obsoleteFields} champ(s) obsol√®te(s) nettoy√©(s)\n\nTotal : ${report.duplicatesRemoved + report.orphanScores} score(s) supprim√©(s)`);
                
                // Rafra√Æchir l'affichage
                renderNotesTable();
                await loadResults();
            } catch (e) {
                console.error('Erreur:', e);
                await alert('Erreur lors du nettoyage: ' + e.message);
            }
        };
        
        // Supprimer les doublons de scores
        window.removeDuplicateScores = async () => {
            if (!await confirm('Rechercher et supprimer les doublons de scores ?\n\nPour chaque combinaison candidat+jury, seule la note la plus r√©cente sera conserv√©e.')) {
                return;
            }
            
            try {
                const querySnapshot = await getDocs(collection(db, "scores"));
                
                // Grouper par candidat+jury
                const scoresByKey = {};
                querySnapshot.forEach(doc => {
                    const data = doc.data();
                    const key = `${data.candidateId}_${data.juryName}`;
                    
                    if (!scoresByKey[key]) {
                        scoresByKey[key] = [];
                    }
                    scoresByKey[key].push({ id: doc.id, data: data, timestamp: data.timestamp });
                });
                
                // Trouver et supprimer les doublons
                let duplicatesFound = 0;
                let duplicatesRemoved = 0;
                
                for (const key in scoresByKey) {
                    const scores = scoresByKey[key];
                    if (scores.length > 1) {
                        duplicatesFound += scores.length - 1;
                        console.log(`Doublon trouv√© pour ${key}: ${scores.length} entr√©es`);
                        
                        // Trier par timestamp (le plus r√©cent en premier)
                        scores.sort((a, b) => {
                            const timeA = a.timestamp?.toDate?.() || new Date(0);
                            const timeB = b.timestamp?.toDate?.() || new Date(0);
                            return timeB - timeA;
                        });
                        
                        // Garder le premier (le plus r√©cent), supprimer les autres
                        for (let i = 1; i < scores.length; i++) {
                            console.log(`Suppression de l'ancien score: ${scores[i].id}`, scores[i].data);
                            await deleteDoc(doc(db, "scores", scores[i].id));
                            duplicatesRemoved++;
                        }
                    }
                }
                
                alert(`‚úì Nettoyage des doublons termin√© !\n${duplicatesFound} doublon(s) trouv√©(s)\n${duplicatesRemoved} doublon(s) supprim√©(s)`);
                
                // Rafra√Æchir l'affichage
                renderNotesTable();
                await loadResults();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors du nettoyage des doublons: ' + e.message);
            }
        };

        // Nettoyer les valeurs calcul√©es obsol√®tes de la base de donn√©es
        // T√©l√©charger toute la base de donn√©es en JSON
        window.downloadDatabase = async () => {
            try {
                const backup = {
                    exportDate: new Date().toISOString(),
                    version: "2.0",
                    data: {}
                };
                
                // Exporter les candidats
                const candidatsSnap = await getDoc(doc(db, "candidats", "liste_actuelle"));
                if (candidatsSnap.exists()) {
                    backup.data.candidats = candidatsSnap.data();
                }
                
                // Exporter tous les comptes jury (collection accounts)
                const accountsSnap = await getDocs(collection(db, "accounts"));
                backup.data.accounts = [];
                accountsSnap.forEach(d => {
                    backup.data.accounts.push({ 
                        id: d.id, 
                        ...d.data(),
                        // Convertir les timestamps en ISO strings pour le JSON
                        createdAt: d.data().createdAt?.toDate?.()?.toISOString() || null
                    });
                });
                
                // Exporter tous les scores
                const scoresSnap = await getDocs(collection(db, "scores"));
                backup.data.scores = [];
                scoresSnap.forEach(d => {
                    const scoreData = d.data();
                    backup.data.scores.push({ 
                        id: d.id, 
                        ...scoreData,
                        // Convertir les timestamps en ISO strings
                        timestamp: scoreData.timestamp?.toDate?.()?.toISOString() || null
                    });
                });
                
                // Exporter la configuration compl√®te
                backup.data.config = {};
                
                // Config: locks
                const locksSnap = await getDoc(doc(db, "config", "locks"));
                if (locksSnap.exists()) {
                    backup.data.config.locks = locksSnap.data();
                }
                
                // Config: session
                const sessionSnap = await getDoc(doc(db, "config", "session"));
                if (sessionSnap.exists()) {
                    backup.data.config.session = sessionSnap.data();
                }
                
                // Config: admin (mot de passe et th√®me)
                const adminSnap = await getDoc(doc(db, "config", "admin"));
                if (adminSnap.exists()) {
                    backup.data.config.admin = adminSnap.data();
                }
                
                // Config: rounds (tours)
                const roundsSnap = await getDoc(doc(db, "config", "rounds"));
                if (roundsSnap.exists()) {
                    backup.data.config.rounds = roundsSnap.data();
                }
                
                // Cr√©er le fichier JSON
                const json = JSON.stringify(backup, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // T√©l√©charger
                const a = document.createElement('a');
                a.href = url;
                a.download = `concours-eloquence-backup-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert(`‚úì Sauvegarde cr√©√©e avec succ√®s !\n\n${backup.data.scores.length} score(s)\n${backup.data.candidats?.candidates?.length || 0} candidat(s)\n${backup.data.accounts.length} jury(s)`);
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la sauvegarde: ' + e.message);
            }
        };
        
        // Restaurer la base de donn√©es depuis un fichier JSON
        window.uploadDatabase = async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!await confirm(`‚ö†Ô∏è ATTENTION ‚ö†Ô∏è\n\nRestaurer la base de donn√©es va REMPLACER toutes les donn√©es actuelles !\n\nVoulez-vous continuer ?`)) {
                event.target.value = ''; // Reset file input
                return;
            }
            
            try {
                const text = await file.text();
                const backup = JSON.parse(text);
                
                if (!backup.data || !backup.version) {
                    throw new Error('Format de fichier invalide');
                }
                
                let restored = 0;
                
                // Restaurer les candidats
                if (backup.data.candidats) {
                    await setDoc(doc(db, "candidats", "liste_actuelle"), backup.data.candidats);
                    CANDIDATES = backup.data.candidats.candidates || [];
                    restored++;
                }
                
                // Restaurer les comptes jury (supprimer les anciens d'abord)
                if (backup.data.accounts) {
                    const oldAccounts = await getDocs(collection(db, "accounts"));
                    for (const d of oldAccounts.docs) {
                        await deleteDoc(doc(db, "accounts", d.id));
                    }
                    
                    for (const account of backup.data.accounts) {
                        const { id, ...accountData } = account;
                        // Convertir les ISO strings en Timestamps
                        if (accountData.createdAt && typeof accountData.createdAt === 'string') {
                            accountData.createdAt = new Date(accountData.createdAt);
                        }
                        await setDoc(doc(db, "accounts", id), accountData);
                        restored++;
                    }
                }
                
                // Restaurer les scores (supprimer les anciens d'abord)
                const oldScores = await getDocs(collection(db, "scores"));
                for (const d of oldScores.docs) {
                    await deleteDoc(doc(db, "scores", d.id));
                }
                
                if (backup.data.scores) {
                    for (const score of backup.data.scores) {
                        const { id, ...scoreData } = score;
                        // Convertir les ISO strings en Timestamps
                        if (scoreData.timestamp && typeof scoreData.timestamp === 'string') {
                            scoreData.timestamp = new Date(scoreData.timestamp);
                        }
                        await addDoc(collection(db, "scores"), scoreData);
                        restored++;
                    }
                }
                
                // Restaurer la configuration (version 2.0 avec structure unifi√©e)
                if (backup.data.config) {
                    if (backup.data.config.locks) {
                        await setDoc(doc(db, "config", "locks"), backup.data.config.locks);
                        candidateLocks = backup.data.config.locks.locks || {};
                        restored++;
                    }
                    
                    if (backup.data.config.session) {
                        await setDoc(doc(db, "config", "session"), backup.data.config.session);
                        restored++;
                    }
                    
                    if (backup.data.config.admin) {
                        await setDoc(doc(db, "config", "admin"), backup.data.config.admin);
                        restored++;
                    }
                    
                    if (backup.data.config.rounds) {
                        await setDoc(doc(db, "config", "rounds"), backup.data.config.rounds);
                        restored++;
                    }
                }
                // Support de l'ancien format (version 1.0)
                else {
                    if (backup.data.locks) {
                        await setDoc(doc(db, "config", "locks"), backup.data.locks);
                        candidateLocks = backup.data.locks.locks || {};
                        restored++;
                    }
                    
                    if (backup.data.session) {
                        await setDoc(doc(db, "config", "session"), backup.data.session);
                        restored++;
                    }
                    
                    if (backup.data.adminPassword) {
                        await setDoc(doc(db, "config", "admin"), { password: backup.data.adminPassword });
                        restored++;
                    }
                }
                
                alert(`‚úì Restauration r√©ussie !\n\n${restored} √©l√©ment(s) restaur√©(s)\nVersion: ${backup.version}\nDate de sauvegarde: ${new Date(backup.exportDate).toLocaleString()}`);
                
                // Recharger la page pour rafra√Æchir toutes les donn√©es
                location.reload();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la restauration: ' + e.message);
                event.target.value = ''; // Reset file input
            }
        };

        window.recalculateAllScores = async () => {
            if (!await confirm('Nettoyer les valeurs calcul√©es obsol√®tes en base de donn√©es ?\n\nLes scores pond√©r√©s seront d√©sormais toujours calcul√©s √† la vol√©e.')) {
                return;
            }
            
            try {
                const querySnapshot = await getDocs(collection(db, "scores"));
                let cleaned = 0;
                
                for (const scoreDoc of querySnapshot.docs) {
                    const data = scoreDoc.data();
                    
                    // Supprimer totalWeightedScore s'il existe
                    if ('totalWeightedScore' in data) {
                        delete data.totalWeightedScore;
                        await setDoc(doc(db, "scores", scoreDoc.id), data);
                        cleaned++;
                    }
                }
                
                alert(`‚úì Nettoyage termin√© !\n${cleaned} enregistrement(s) nettoy√©(s).\n\nLes totaux sont maintenant calcul√©s correctement.`);
                
                // Rafra√Æchir l'affichage
                renderNotesTable();
                await loadResults();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors du nettoyage: ' + e.message);
            }
        };

        window.confirmDeleteAllJuries = async () => {
            if (!await confirm(`‚ö†Ô∏è ATTENTION ‚ö†Ô∏è\n\nSupprimer TOUTES les notations de TOUS les jurys ?\n\nLa liste des candidats sera conserv√©e.\n\nCette action est IRR√âVERSIBLE !`)) {
                return;
            }
            
            // Double confirmation
            if (!await confirm(`√ätes-vous VRAIMENT s√ªr ?\n\nToutes les notes de tous les jurys seront supprim√©es d√©finitivement.`)) {
                return;
            }
            
            try {
                const querySnapshot = await getDocs(collection(db, "scores"));
                let deletedCount = 0;
                
                for (const d of querySnapshot.docs) {
                    await deleteDoc(doc(db, "scores", d.id));
                    deletedCount++;
                }
                
                // Supprimer tous les verrous
                candidateLocks = {};
                await setDoc(doc(db, "config", "locks"), { locks: {} });
                
                alert(`‚úì Tous les jurys supprim√©s avec succ√®s\n${deletedCount} notation(s) supprim√©e(s)`);
                location.reload();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la suppression: ' + e.message);
            }
        };

        window.insertTestData = async () => {
            if (!await customConfirm("Ins√©rer les candidats et jurys de test ?\n\n‚úì 68 candidats\n‚úì 6 jurys\n\nCeci ajoutera ces donn√©es aux donn√©es existantes.")) {
                return;
            }
            
            try {
                const testCandidateNames = [
                    "Tim√©o Charvolin", "Paul R√©gent", "Lo√Øc Delais", "Sophie Moreau", "Lucas Bernard",
                    "Emma Dubois", "Nathan Thomas", "L√©a Petit", "Hugo Robert", "Chlo√© Richard",
                    "Arthur Durand", "Manon Lefebvre", "Louis Martin", "Camille Laurent", "Gabriel Simon",
                    "Sarah Michel", "Alexandre Lef√®vre", "Julie Garcia", "Maxime Roux", "Marine Vincent",
                    "Th√©o Fournier", "Clara Bertrand", "Antoine Girard", "Pauline Morel", "Nicolas Andr√©",
                    "Laura Mercier", "Julien Blanchard", "Alice Fontaine", "Romain Rousseau", "Ana√Øs Lambert",
                    "Pierre Chevalier", "Am√©lie Bonnet", "L√©na Garnier", "Benjamin Faure", "In√®s Clement",
                    "Rapha√´l Gauthier", "Tim√©o Charvolin", "Paul R√©gent", "Lo√Øc Delais", "Sophie Moreau",
                    "Lucas Bernard", "Emma Dubois", "Nathan Thomas", "L√©a Petit", "Hugo Robert",
                    "Chlo√© Richard", "Arthur Durand", "Manon Lefebvre", "Louis Martin", "Camille Laurent",
                    "Gabriel Simon", "Sarah Michel", "Alexandre Lef√®vre", "Julie Garcia", "Maxime Roux",
                    "Marine Vincent", "Th√©o Fournier", "Clara Bertrand", "Antoine Girard", "Pauline Morel",
                    "Nicolas Andr√©", "Laura Mercier", "Julien Blanchard", "Alice Fontaine", "Romain Rousseau",
                    "Ana√Øs Lambert", "Pierre Chevalier", "Am√©lie Bonnet", "L√©na Garnier", "Benjamin Faure",
                    "In√®s Clement", "Rapha√´l Gauthier"
                ];
                
                const testJuryNames = ["Martin", "Lasso", "Murat", "Blier", "Collisse", "Pierre"];
                
                // Charger les candidats et jurys existants
                const candidatesDoc = await getDoc(doc(db, "candidats", "liste_actuelle"));
                let existingCandidates = candidatesDoc.exists() ? candidatesDoc.data().candidates || [] : [];
                
                await loadJuries();
                const existingJuryNames = new Set(JURIES.map(j => j.name.toLowerCase()));
                
                // Ajouter les candidats de test
                let candidatesAdded = 0;
                const usedIds = new Set(existingCandidates.map(c => c.id));
                
                for (const name of testCandidateNames) {
                    // G√©n√©rer un ID unique
                    let newId;
                    do {
                        newId = String(Math.floor(Math.random() * 999) + 1).padStart(3, '0');
                    } while (usedIds.has(newId));
                    usedIds.add(newId);
                    
                    existingCandidates.push({
                        id: newId,
                        name: name,
                        tour: activeRoundId || 'round1',
                        status: 'Actif'
                    });
                    candidatesAdded++;
                }
                
                // Sauvegarder les candidats
                await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: existingCandidates });
                
                // Ajouter les jurys de test
                let juriesAdded = 0;
                for (const juryName of testJuryNames) {
                    if (!existingJuryNames.has(juryName.toLowerCase())) {
                        // Trouver le prochain ID disponible
                        let maxId = 0;
                        JURIES.forEach(j => {
                            const num = parseInt(j.id.replace('jury', ''));
                            if (num > maxId) maxId = num;
                        });
                        const newJuryId = `jury${maxId + 1}`;
                        
                        await setDoc(doc(db, "accounts", newJuryId), {
                            name: juryName,
                            password: '',
                            theme: 'light'
                        });
                        
                        JURIES.push({
                            id: newJuryId,
                            name: juryName
                        });
                        
                        juriesAdded++;
                    }
                }
                
                await customAlert(`‚úì ${candidatesAdded} candidat(s) ajout√©(s)\n‚úì ${juriesAdded} jury(s) ajout√©(s)`);
                
                // Rafra√Æchir l'affichage
                await loadList();
                await loadJuries();
                renderJuryTable();
            } catch (e) {
                console.error('Erreur:', e);
                await customAlert('Erreur lors de l\'insertion des donn√©es de test: ' + e.message);
            }
        };

        window.autoFillActiveRound = async () => {
            if (!await customConfirm("Auto-remplir les notes des candidats actifs du tour en cours avec '-' et les passer en 'Qualifi√©' ?")) {
                return;
            }
            
            try {
                // Charger les candidats
                const candidatesDoc = await getDoc(doc(db, "candidats", "liste_actuelle"));
                if (!candidatesDoc.exists()) {
                    await customAlert("Aucun candidat trouv√©");
                    return;
                }
                const allCandidates = candidatesDoc.data().candidates || [];
                
                // Filtrer les candidats actifs du tour en cours
                const activeCandidatesInRound = allCandidates.filter(c => 
                    c.tour === activeRoundId && (c.status === 'Actif' || c.status === 'Reset')
                );
                
                if (activeCandidatesInRound.length === 0) {
                    await customAlert("Aucun candidat actif trouv√© pour le tour en cours");
                    return;
                }
                
                // Charger les jurys
                await loadJuries();
                if (JURIES.length === 0) {
                    await customAlert("Aucun jury trouv√©");
                    return;
                }
                
                // Pour chaque candidat actif, cr√©er des scores "-" pour chaque jury
                let scoresCreated = 0;
                for (const candidate of activeCandidatesInRound) {
                    for (const jury of JURIES) {
                        // V√©rifier si un score existe d√©j√†
                        const q = query(
                            collection(db, "scores"),
                            where("candidateId", "==", candidate.id),
                            where("juryId", "==", jury.id),
                            where("roundId", "==", activeRoundId)
                        );
                        const existingScores = await getDocs(q);
                        
                        // Ne cr√©er un score que s'il n'existe pas d√©j√†
                        if (existingScores.empty) {
                            const scoreData = {
                                juryId: jury.id,
                                juryName: jury.name,
                                candidateId: candidate.id,
                                roundId: activeRoundId,
                                score1: '-',
                                score2: '-',
                                timestamp: new Date()
                            };
                            await addDoc(collection(db, "scores"), scoreData);
                            scoresCreated++;
                        }
                    }
                    
                    // Passer le candidat en "Qualifi√©"
                    const candidateIndex = allCandidates.findIndex(c => c.id === candidate.id);
                    if (candidateIndex >= 0) {
                        allCandidates[candidateIndex].status = 'Qualifie';
                    }
                }
                
                // Sauvegarder les candidats mis √† jour
                await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: allCandidates });
                
                await customAlert(`‚úì ${scoresCreated} score(s) cr√©√©(s) et ${activeCandidatesInRound.length} candidat(s) qualifi√©(s)`);
                
                // Rafra√Æchir l'affichage
                await loadList();
                await renderNotesTable();
            } catch (e) {
                console.error('Erreur:', e);
                await customAlert('Erreur lors de l\'auto-remplissage: ' + e.message);
            }
        };

        window.confirmResetScores = async () => {
            if(!await customConfirm("Supprimer TOUTES les notes (les candidats seront conserv√©s) ?")) return;
            
            try {
                const snap = await getDocs(collection(db, "scores"));
                for (const d of snap.docs) { 
                    await deleteDoc(doc(db, "scores", d.id)); 
                }
                
                // R√©initialiser les verrous
                await setDoc(doc(db, "config", "locks"), { locks: {} });
                candidateLocks = {};
                
                alert('Toutes les notes ont √©t√© supprim√©es');
                location.reload();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la r√©initialisation: ' + e.message);
            }
        };

        window.confirmResetAll = async () => {
            const confirmation = await prompt('Pour confirmer la r√©initialisation TOTALE, tapez "RESET":');
            if (confirmation !== 'RESET') {
                alert('R√©initialisation annul√©e');
                return;
            }
            
            try {
                // Supprimer les scores
                const scoresSnap = await getDocs(collection(db, "scores"));
                for (const d of scoresSnap.docs) { 
                    await deleteDoc(doc(db, "scores", d.id)); 
                }
                
                // Supprimer les candidats
                await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: [] });
                
                // R√©initialiser les verrous
                await setDoc(doc(db, "config", "locks"), { locks: {} });
                
                alert('R√©initialisation compl√®te effectu√©e');
                location.reload();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la r√©initialisation: ' + e.message);
            }
        };

        // Export vers CSV
        // Export des notes en CSV (format √©ditable)
        window.exportNotesToCSV = async () => {
            try {
                // R√©cup√©rer les scores du tour actif
                const q = query(
                    collection(db, "scores"),
                    where("roundId", "==", activeRoundId || 'round1')
                );
                const scoresSnap = await getDocs(q);
                const juries = new Set();
                const scoresByCandidate = {};
                
                scoresSnap.forEach(d => {
                    const data = d.data();
                    juries.add(data.juryName);
                    
                    if (!scoresByCandidate[data.candidateId]) {
                        scoresByCandidate[data.candidateId] = {};
                    }
                    scoresByCandidate[data.candidateId][data.juryName] = data;
                });
                
                const sortedJuries = Array.from(juries).sort();
                
                // Cr√©er l'en-t√™te CSV
                let csv = 'CandidatID,CandidatNom';
                sortedJuries.forEach(jury => {
                    csv += `,${jury}_Note1,${jury}_Note2`;
                });
                csv += '\n';
                
                // Ajouter les donn√©es
                CANDIDATES.forEach(c => {
                    let row = `${c.id},"${c.name}"`;
                    
                    sortedJuries.forEach(jury => {
                        const scores = scoresByCandidate[c.id]?.[jury];
                        const note1 = scores?.score1 || '-';
                        const note2 = scores?.score2 || '-';
                        row += `,${note1},${note2}`;
                    });
                    
                    csv += row + '\n';
                });
                
                // T√©l√©charger
                const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                const date = new Date().toISOString().split('T')[0];
                link.setAttribute('href', url);
                link.setAttribute('download', `notes_${date}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                alert('‚úì Export CSV r√©ussi !');
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de l\'export: ' + e.message);
            }
        };
        
        // Import des notes depuis CSV
        window.importNotesFromCSV = async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!await confirm(`‚ö†Ô∏è ATTENTION ‚ö†Ô∏è\n\nImporter depuis CSV va :\n- V√©rifier le format du fichier\n- Mettre √† jour les notes existantes\n- Cr√©er de nouvelles notes si n√©cessaire\n\nLes notes actuelles seront modifi√©es !\n\nContinuer ?`)) {
                event.target.value = '';
                return;
            }
            
            try {
                const text = await file.text();
                const lines = text.split('\n').filter(l => l.trim());
                
                if (lines.length < 2) {
                    throw new Error('Fichier CSV vide ou invalide');
                }
                
                // Parser l'en-t√™te
                const header = lines[0].split(',').map(h => h.trim());
                
                // V√©rifier le format
                if (header[0] !== 'CandidatID' || header[1] !== 'CandidatNom') {
                    throw new Error('Format CSV invalide. L\'en-t√™te doit commencer par: CandidatID,CandidatNom');
                }
                
                // Extraire les jurys de l'en-t√™te et mapper aux IDs
                await loadJuries();  // S'assurer que JURIES est charg√©
                const juries = [];
                for (let i = 2; i < header.length; i += 2) {
                    const juryName = header[i].replace('_Note1', '');
                    // Chercher le juryId correspondant
                    const jury = JURIES.find(j => j.name === juryName);
                    juries.push({
                        name: juryName,
                        id: jury ? jury.id : null
                    });
                }
                
                if (juries.length === 0) {
                    throw new Error('Aucun jury trouv√© dans le fichier CSV');
                }
                
                let imported = 0;
                let errors = [];
                
                // Parser chaque ligne
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = line.match(/(".*?"|[^,]+)/g).map(v => v.replace(/^"|"$/g, '').trim());
                    
                    const candidatId = values[0];
                    
                    // V√©rifier que le candidat existe
                    const candidate = CANDIDATES.find(c => c.id === candidatId);
                    if (!candidate) {
                        errors.push(`Ligne ${i + 1}: Candidat "${candidatId}" non trouv√©`);
                        continue;
                    }
                    
                    // Importer les notes pour chaque jury
                    for (let j = 0; j < juries.length; j++) {
                        const jury = juries[j];
                        const juryName = jury.name;
                        const juryId = jury.id;
                        const note1 = values[2 + j * 2];
                        const note2 = values[3 + j * 2];
                        
                        // V√©rifier que le jury existe
                        if (!juryId) {
                            errors.push(`Ligne ${i + 1}: Jury "${juryName}" non trouv√© dans la base de donn√©es`);
                            continue;
                        }
                        
                        // Valider les notes
                        const validValues = ['-', '5', '10', '15', '20', 'EL', 'Elimine']; // Accepter Elimine pour r√©trocompatibilit√©
                        if (!validValues.includes(note1) || !validValues.includes(note2)) {
                            errors.push(`Ligne ${i + 1}, ${juryName}: Notes invalides (${note1}, ${note2})`);
                            continue;
                        }
                        
                        // Chercher si un score existe d√©j√† pour ce tour (par juryId)
                        const q = query(
                            collection(db, "scores"),
                            where("candidateId", "==", candidatId),
                            where("juryId", "==", juryId),
                            where("roundId", "==", activeRoundId || 'round1')
                        );
                        const existingScores = await getDocs(q);
                        
                        const scoreData = {
                            candidateId: candidatId,
                            juryId: juryId,
                            juryName: juryName,
                            roundId: activeRoundId || 'round1',
                            score1: note1,
                            score2: note2,
                            timestamp: new Date()
                        };
                        
                        if (!existingScores.empty) {
                            // Mettre √† jour
                            await setDoc(doc(db, "scores", existingScores.docs[0].id), scoreData);
                        } else {
                            // Cr√©er
                            await addDoc(collection(db, "scores"), scoreData);
                        }
                        
                        imported++;
                    }
                }
                
                event.target.value = '';
                
                let message = `‚úì Import termin√© !\n\n${imported} note(s) import√©e(s)`;
                if (errors.length > 0) {
                    message += `\n\n‚ö†Ô∏è ${errors.length} erreur(s) :\n${errors.slice(0, 5).join('\n')}`;
                    if (errors.length > 5) {
                        message += `\n... et ${errors.length - 5} autre(s)`;
                    }
                }
                
                alert(message);
                
                // Rafra√Æchir l'affichage
                renderNotesTable();
                await loadResults();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de l\'import: ' + e.message);
                event.target.value = '';
            }
        };

        window.exportToExcel = async () => {
            if (!CANDIDATES.length || !Object.keys(aggregatedData).length) {
                await alert('Veuillez d\'abord charger les r√©sultats (bouton "Charger et Calculer")');
                return;
            }

            // R√©cup√©rer les jurys
            const juries = new Set();
            Object.values(aggregatedData).forEach(candidate => {
                Object.keys(candidate.juryScores).forEach(jury => juries.add(jury));
            });
            const sortedJuries = Array.from(juries).sort();

            // Cr√©er l'en-t√™te CSV
            let csv = 'Candidat,' + sortedJuries.join(',') + ',Total,Statut\n';

            // Ajouter les donn√©es des candidats
            CANDIDATES.forEach(c => {
                const data = aggregatedData[c.id];
                if (!data.hasScores) return;

                let row = `"${c.name}",`;
                
                // Scores par jury
                sortedJuries.forEach((jury, index) => {
                    const scoreObj = data.juryScores[jury];
                    if (scoreObj) {
                        if (scoreObj.score1 === "EL") {
                            row += '√âLIMIN√â';
                        } else {
                            // Recalculer le score pond√©r√© pour l'export
                            let weightedScore = 0;
                            if (scoreObj.score1 && scoreObj.score1 !== '-' && 
                                scoreObj.score2 && scoreObj.score2 !== '-' &&
                                scoreObj.score1 !== 'EL' && scoreObj.score2 !== 'EL') {
                                weightedScore = (parseInt(scoreObj.score1) * 3) + parseInt(scoreObj.score2);
                            }
                            row += `"${scoreObj.score1}|${scoreObj.score2} (${weightedScore})"`;
                        }
                    } else {
                        row += '-';
                    }
                    if (index < sortedJuries.length - 1) row += ',';
                });

                // Total et statut
                row += `,${data.total}`;
                row += data.elimCount >= 3 ? ',√âLIMIN√â' : ',Qualifi√©';
                csv += row + '\n';
            });

            // T√©l√©charger le fichier
            const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            const date = new Date().toISOString().split('T')[0];
            link.setAttribute('href', url);
            link.setAttribute('download', `resultats_concours_${date}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };

        // Export du podium en image
        window.exportPodiumToImage = async () => {
            const podiumTable = document.getElementById('podium-table');
            
            if (!podiumTable || !podiumTable.querySelector('tbody').children.length) {
                alert('Veuillez d\'abord charger les r√©sultats (bouton "Charger et Calculer")');
                return;
            }

            try {
                // V√©rifier si html2canvas est charg√©
                if (typeof html2canvas === 'undefined') {
                    alert('Erreur: html2canvas n\'est pas charg√©');
                    return;
                }

                // Cr√©er un conteneur temporaire avec le titre
                const container = document.createElement('div');
                container.style.padding = '30px';
                container.style.background = 'white';
                container.style.width = 'fit-content';
                
                const title = document.createElement('h1');
                title.textContent = 'Classement Officiel - Concours d\'√âloquence';
                title.style.color = '#007bff';
                title.style.textAlign = 'center';
                title.style.marginBottom = '20px';
                title.style.fontSize = '24px';
                
                const tableClone = podiumTable.cloneNode(true);
                tableClone.style.fontSize = '16px';
                
                container.appendChild(title);
                container.appendChild(tableClone);
                
                // Ajouter temporairement au document
                container.style.position = 'absolute';
                container.style.left = '-9999px';
                document.body.appendChild(container);

                // Capturer avec html2canvas
                const canvas = await html2canvas(container, {
                    backgroundColor: '#ffffff',
                    scale: 2, // Haute r√©solution
                    logging: false
                });

                // Supprimer le conteneur temporaire
                document.body.removeChild(container);

                // T√©l√©charger l'image
                const date = new Date().toISOString().split('T')[0];
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `podium_concours_${date}.png`;
                    link.click();
                    URL.revokeObjectURL(url);
                });

            } catch (e) {
                console.error('Erreur lors de l\'export:', e);
                alert('Erreur lors de la g√©n√©ration de l\'image: ' + e.message);
            }
        };

        // Modal pour changement de mot de passe
        window.showPasswordModal = async function() {
            try {
                // 1. Demander le mot de passe actuel
                const currentPassword = await prompt('√âtape 1/3: Entrez le mot de passe actuel:');
                
                if (!currentPassword) {
                    return; // Annul√©
                }

                // V√©rifier le mot de passe actuel
                const adminDoc = await getDoc(doc(db, "config", "admin"));
                const storedPassword = adminDoc.exists() ? adminDoc.data().password : 'admin';

                if (currentPassword !== storedPassword) {
                    alert('Mot de passe actuel incorrect !');
                    return;
                }

                // 2. Demander le nouveau mot de passe
                const newPassword = await prompt('√âtape 2/3: Entrez le nouveau mot de passe:\n(minimum 4 caract√®res)');
                
                if (!newPassword) {
                    return; // Annul√©
                }

                if (newPassword.length < 4) {
                    alert('Le mot de passe doit contenir au moins 4 caract√®res');
                    return;
                }

                // 3. Demander la confirmation
                const confirmPassword = await prompt('√âtape 3/3: Confirmez le nouveau mot de passe:');
                
                if (!confirmPassword) {
                    return; // Annul√©
                }

                if (newPassword !== confirmPassword) {
                    alert('Les mots de passe ne correspondent pas !');
                    return;
                }

                // Tout est OK, changer le mot de passe
                await changeAdminPassword(newPassword);
                
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la v√©rification du mot de passe');
            }
        };

        // Changement du mot de passe administrateur
        async function changeAdminPassword(newPassword) {
            try {
                await setDoc(doc(db, "config", "admin"), { password: newPassword });
                alert('Mot de passe chang√© avec succ√®s !');
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors du changement de mot de passe');
            }
        }

        // D√©connexion admin
        window.adminLogout = async function() {
            if (await confirm('Voulez-vous vous d√©connecter ?')) {
                window.location.href = 'index.html';
            }
        };

        // Theme Toggle Logic - Propre √† l'admin
        function initTheme() {
            const savedTheme = localStorage.getItem('theme_admin') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            const toggle = document.getElementById('theme-toggle');
            if (toggle) {
                if (savedTheme === 'dark') {
                    toggle.classList.add('active');
                }
            }
        }

        window.toggleTheme = async function() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            
            // Sauvegarder avec une cl√© sp√©cifique √† l'admin
            localStorage.setItem('theme_admin', newTheme);
            
            // Sauvegarder aussi dans Firebase avec merge pour pr√©server le mot de passe
            try {
                await setDoc(doc(db, "config", "admin"), {
                    theme: newTheme
                }, { merge: true });
            } catch (e) {
                console.log('Impossible de sauvegarder le th√®me admin dans Firebase:', e);
            }
            
            const toggle = document.getElementById('theme-toggle');
            if (toggle) {
                if (newTheme === 'dark') {
                    toggle.classList.add('active');
                } else {
                    toggle.classList.remove('active');
                }
            }
        };

        window.toggleMenu = function() {
            const menu = document.getElementById('menu-content');
            if (menu) {
                menu.classList.toggle('active');
            }
        };

        // Close menu when clicking outside
        document.addEventListener('click', function(event) {
            const menu = document.getElementById('menu-content');
            const burgerIcon = document.querySelector('.burger-icon');
            if (menu && burgerIcon && !menu.contains(event.target) && !burgerIcon.contains(event.target)) {
                menu.classList.remove('active');
            }
        });

        // Initialize theme on page load
        initTheme();
    </script>
    
    <script>window.useCustomModals = true;</script>
    <script src="modal.js"></script>
</body>
</html>