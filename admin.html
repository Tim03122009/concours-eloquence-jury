<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="description" content="Tableau de bord administrateur - Gestion des r√©sultats du concours">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <title>üèÜ Administration - R√©sultats Concours</title>
    <style>
        /* Modern Admin Dashboard Styles - Responsive */
        :root {
            /* Light Mode (Default) */
            --primary: #007bff;
            --success: #28a745;
            --warning: #ffc107;
            --danger: #dc3545;
            --danger-color: #dc3545;
            --danger-dark: #c82333;
            --neutral: #6c757d;
            --neutral-color: #6c757d;
            --white: #ffffff;
            --text-color: #333;
            --text-secondary: #666;
            --border-color: #ddd;
            --bg-gradient-start: #667eea;
            --bg-gradient-end: #764ba2;
            --card-bg: #ffffff;
            --input-bg: #ffffff;
            --info-bg-start: #e3f2fd;
            --info-bg-end: #bbdefb;
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 8px rgba(0,0,0,0.12);
            --shadow-lg: 0 8px 16px rgba(0,0,0,0.15);
            --radius: 10px;
            --spacing: 20px;
        }

        /* Dark Mode */
        [data-theme="dark"] {
            --primary: #4da3ff;
            --success: #4caf50;
            --warning: #ffa726;
            --danger: #f44336;
            --danger-color: #f44336;
            --danger-dark: #d32f2f;
            --neutral: #9e9e9e;
            --neutral-color: #9e9e9e;
            --white: #ffffff;
            --text-color: #e0e0e0;
            --text-secondary: #b0b0b0;
            --border-color: #444;
            --bg-gradient-start: #3d5266;
            --bg-gradient-end: #1a252f;
            --card-bg: #2d2d3a;
            --input-bg: #3a3a4a;
            --info-bg-start: #1e3a5f;
            --info-bg-end: #2c4f7c;
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.5);
        }

        * {
            box-sizing: border-box;
        }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            padding: clamp(12px, 3vw, 20px);
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            margin: 0;
            min-height: 100vh;
            line-height: 1.6;
            transition: background 0.3s ease;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--card-bg);
            padding: clamp(15px, 4vw, 40px);
            border-radius: var(--radius);
            box-shadow: var(--shadow-lg);
            position: relative;
        }

        h1 { 
            color: var(--primary);
            border-bottom: 3px solid var(--primary);
            padding-bottom: 15px;
            margin-top: 0;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            font-weight: 700;
        }

        h2 { 
            color: var(--primary);
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
            margin-top: var(--spacing);
            font-size: clamp(1.2rem, 3vw, 1.8rem);
            font-weight: 600;
        }

        /* Action Buttons */
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: var(--spacing);
        }

        .action-button { 
            padding: clamp(10px, 2vw, 14px) clamp(16px, 3vw, 24px);
            font-size: clamp(0.95rem, 2vw, 1.1rem);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-sm);
            flex: 1 1 auto;
            min-width: 140px;
        }

        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .action-button:active {
            transform: translateY(0);
        }

        .load-button { 
            background: linear-gradient(135deg, var(--success) 0%, #1e7e34 100%);
            color: white;
        }

        .export-button { 
            background: linear-gradient(135deg, var(--warning) 0%, #e0a800 100%);
            color: #212529;
        }

        .export-button.excel { 
            background: linear-gradient(135deg, var(--primary) 0%, #0056b3 100%);
            color: white;
        }

        /* Candidate Zone */
        .candidate-zone { 
            margin-top: var(--spacing);
            padding: clamp(15px, 3vw, 25px);
            border: 2px solid var(--border-color);
            background: var(--input-bg);
            border-radius: var(--radius);
            box-shadow: var(--shadow-sm);
        }

        .candidate-zone h2 {
            margin-top: 0;
            color: var(--primary);
        }

        .candidate-zone textarea { 
            width: 100%;
            min-height: 120px;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-family: inherit;
            font-size: clamp(0.95rem, 2vw, 1.05rem);
            transition: all 0.3s ease;
            resize: vertical;
            background: var(--card-bg);
            color: var(--text-color);
        }

        .candidate-zone textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
        }

        /* Tables */
        .table-container {
            overflow-x: auto;
            margin: var(--spacing) 0;
            border-radius: var(--radius);
            box-shadow: var(--shadow-md);
        }

        #scores-matrix { 
            width: 100%;
            border-collapse: collapse;
            background: var(--card-bg);
            font-size: clamp(0.8rem, 1.5vw, 0.95rem);
        }

        #scores-matrix th, #scores-matrix td { 
            border: 1px solid var(--border-color);
            padding: clamp(8px, 2vw, 12px);
            text-align: center;
            color: var(--text-color);
        }

        #scores-matrix th { 
            background: var(--input-bg);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            color: var(--text-color);
        }

        .detail-note { 
            font-size: 0.85em;
            color: var(--text-secondary);
            display: block;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 3px;
            margin-bottom: 5px;
        }

        .weighted-total { 
            font-weight: bold;
            color: var(--primary);
            font-size: 1.1em;
        }

        .total-score { 
            background: linear-gradient(135deg, #ffc107 0%, #ffb300 100%);
            font-weight: bold;
            font-size: 1.15em;
            color: #212529;
        }

        .eliminado { 
            background: linear-gradient(135deg, var(--danger) 0%, #c82333 100%);
            color: white;
            font-weight: 600;
        }

        /* Podium Table */
        #podium-table { 
            width: 100%;
            max-width: 800px;
            border-collapse: collapse;
            background: var(--card-bg);
            box-shadow: var(--shadow-md);
            border-radius: var(--radius);
            overflow: hidden;
        }

        #podium-table th, #podium-table td { 
            border: 1px solid var(--border-color);
            padding: clamp(10px, 2.5vw, 15px);
            text-align: center;
            color: var(--text-color);
        }

        #podium-table th {
            background: var(--neutral-color);
            color: var(--white);
            font-weight: 600;
        }

        #podium-table td {
            color: var(--text-color);
        }

        .rank-1 { 
            background: linear-gradient(135deg, gold 0%, #ffed4e 100%);
            font-weight: bold;
            font-size: 1.1em;
        }

        .rank-2 { 
            background: linear-gradient(135deg, silver 0%, #e0e0e0 100%);
            font-weight: bold;
            font-size: 1.05em;
        }

        .rank-3 { 
            background: linear-gradient(135deg, #cd7f32 0%, #b87333 100%);
            color: white;
            font-weight: bold;
        }

        .eliminated-row { 
            background: linear-gradient(135deg, var(--neutral) 0%, #5a6268 100%);
            color: white;
            opacity: 0.8;
        }

        /* Reset Zone */
        .reset-zone { 
            margin-top: 50px;
            padding: clamp(15px, 3vw, 25px);
            border: 3px solid var(--danger-color);
            background: rgba(220, 53, 69, 0.1);
            border-radius: var(--radius);
            box-shadow: var(--shadow-sm);
        }

        .reset-zone h2 {
            color: var(--danger-color);
            margin-top: 0;
        }

        .reset-zone .action-button {
            background: linear-gradient(135deg, var(--danger-color) 0%, var(--danger-dark) 100%);
            color: white;
        }

        hr {
            border: none;
            border-top: 2px solid var(--border-color);
            margin: calc(var(--spacing) * 1.5) 0;
        }

        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            gap: 5px;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: var(--spacing);
            flex-wrap: wrap;
        }

        .tab-btn {
            padding: 12px 24px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .tab-btn:hover {
            color: var(--primary);
            background: rgba(0, 123, 255, 0.05);
        }

        .tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Candidate Table */
        .candidate-table {
            width: 100%;
            border-collapse: collapse;
            margin: var(--spacing) 0;
        }

        .candidate-table th,
        .candidate-table td {
            border: 1px solid var(--border-color);
            padding: 12px;
            text-align: left;
            color: var(--text-color);
        }

        .candidate-table th {
            background: var(--input-bg);
            font-weight: 600;
            color: var(--text-color);
        }

        .candidate-table input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background: var(--card-bg);
            color: var(--text-color);
            font-family: inherit;
        }

        .candidate-table .actions {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2em;
            padding: 4px 8px;
            transition: all 0.3s ease;
        }

        .icon-btn:hover {
            transform: scale(1.2);
        }

        .icon-btn.delete {
            color: var(--danger-color);
        }

        .icon-btn.reset {
            color: var(--warning);
        }

        .icon-btn.lock {
            color: var(--neutral-color);
        }

        .icon-btn.lock.locked {
            color: var(--danger-color);
        }

        /* Notes Table */
        .notes-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
            table-layout: fixed;
        }

        .notes-table th,
        .notes-table td {
            border: 1px solid var(--border-color);
            padding: 8px;
            text-align: center;
            overflow: hidden;
            color: var(--text-color);
        }

        .notes-table th {
            background: var(--input-bg);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            color: var(--text-color);
        }

        .notes-table select {
            width: 100%;
            max-width: 90px;
            padding: 4px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: var(--card-bg);
            color: var(--text-color);
            text-align: center;
            font-size: 0.9em;
            font-family: inherit;
        }

        .notes-table .candidate-name {
            text-align: left;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .notes-table .locked-cell {
            background: rgba(220, 53, 69, 0.1);
        }

        .notes-table .col-actions {
            width: 100px;
        }

        .notes-table .col-candidate {
            width: 150px;
        }

        .notes-table .col-score {
            width: 100px;
        }

        /* Burger Menu & Theme Toggle */
        .burger-menu {
            position: absolute;
            top: var(--spacing);
            right: var(--spacing);
            z-index: 9999;
        }

        .burger-icon {
            width: 36px;
            height: 36px;
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 4px;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-sm);
        }

        .burger-icon:hover {
            box-shadow: var(--shadow-md);
        }

        .burger-icon span {
            width: 20px;
            height: 2px;
            background: var(--text-color);
            transition: all 0.3s ease;
        }

        .burger-menu-content {
            position: absolute;
            top: 45px;
            right: 0;
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 5px;
            box-shadow: var(--shadow-lg);
            padding: 0;
            min-width: 200px;
            display: none;
            overflow: hidden;
            z-index: 10000;
        }

        .burger-menu-content.active {
            display: block;
        }

        .burger-menu-content > * {
            padding: 12px;
        }

        .burger-menu-content > *:not(:last-child) {
            border-bottom: 1px solid var(--border-color);
        }

        .theme-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: var(--text-color);
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: var(--neutral-color);
            border-radius: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-switch.active {
            background: var(--primary);
        }

        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(24px);
        }

        .menu-item {
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 12px;
            color: var(--text-color);
            border: none;
            background: transparent;
            width: 100%;
            text-align: left;
            font-size: clamp(0.9rem, 2vw, 1rem);
            font-family: inherit;
            margin: 0;
        }

        .menu-item:hover {
            background: var(--info-bg-start, rgba(0, 123, 255, 0.1));
        }

        #menu-content .menu-item {
            padding: 12px;
        }

        /* Responsive Design */
        @media (max-width: 767px) {
            .button-group {
                flex-direction: column;
            }

            .action-button {
                width: 100%;
                min-width: unset;
            }

            #scores-matrix {
                font-size: 0.75rem;
            }

            #scores-matrix th,
            #scores-matrix td {
                padding: 6px;
            }

            #podium-table {
                font-size: 0.85rem;
            }
        }

        @media (min-width: 768px) and (max-width: 1023px) {
            .button-group {
                justify-content: flex-start;
            }

            .action-button {
                flex: 0 1 calc(50% - 6px);
            }
        }

        @media (min-width: 1024px) {
            .action-button {
                flex: 0 1 auto;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .action-button {
                min-height: 44px;
            }
        }

        /* Print styles */
        @media print {
            body {
                background: white;
            }

            .container {
                box-shadow: none;
            }

            .candidate-zone,
            .reset-zone,
            .action-button {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="burger-menu">
            <div class="burger-icon" onclick="toggleMenu()">
                <span></span>
                <span></span>
                <span></span>
            </div>
            <div class="burger-menu-content" id="menu-content">
                <div class="theme-toggle">
                    <span>Mode sombre</span>
                    <div class="toggle-switch" id="theme-toggle" onclick="toggleTheme()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
                <div class="menu-item" onclick="showPasswordModal()">
                    <span>Changer le mot de passe</span>
                </div>
                <div class="menu-item" onclick="adminLogout()" style="color: var(--danger-color); font-weight: 600;">
                    <span>D√©connexion</span>
                </div>
            </div>
        </div>
        
        <h1>Tableau de bord Administrateur</h1>
        
        <!-- Tab Navigation -->
        <div class="tab-navigation">
            <button class="tab-btn active" onclick="switchTab('candidats')">Candidats</button>
            <button class="tab-btn" onclick="switchTab('notes')">Notes</button>
            <button class="tab-btn" onclick="switchTab('resultats')">R√©sultats</button>
            <button class="tab-btn" onclick="switchTab('podium')">Podium</button>
            <button class="tab-btn" onclick="switchTab('reinitialiser')">R√©initialiser</button>
        </div>

        <!-- TAB 1: CANDIDATS -->
        <div id="tab-candidats" class="tab-content active">
            <h2>Gestion des Candidats</h2>
            
            <div class="candidate-zone">
                <h3>Import rapide (copier-coller)</h3>
                <textarea id="candidate-names" placeholder="Un nom par ligne...&#10;Exemple:&#10;Alice Martin&#10;Bob Dupont&#10;Claire Bernard"></textarea>
                <button onclick="importCandidates()" class="action-button" style="background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); color:white;">Importer la liste</button>
            </div>

            <h3>Liste des candidats</h3>
            <button onclick="addCandidate()" class="action-button" style="background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); color:white;">+ Ajouter un candidat</button>
            
            <table class="candidate-table" id="candidate-table">
                <thead>
                    <tr>
                        <th style="width: 80px;">ID</th>
                        <th>Nom du candidat</th>
                        <th style="width: 100px;">Actions</th>
                    </tr>
                </thead>
                <tbody id="candidate-table-body">
                    <!-- Rempli dynamiquement -->
                </tbody>
            </table>
        </div>

        <!-- TAB 2: NOTES -->
        <div id="tab-notes" class="tab-content">
            <h2>Gestion des Notes</h2>
            <p style="color: var(--text-secondary); margin-bottom: 20px;">
                Modifiez les notes directement dans le tableau. Les modifications sont sauvegard√©es automatiquement.
            </p>
            
            <div class="table-container">
                <table class="notes-table" id="notes-table">
                    <thead>
                        <tr>
                            <th style="width: 60px;">Actions</th>
                            <th style="width: 150px;">Candidat</th>
                            <!-- Colonnes jurys ajout√©es dynamiquement -->
                        </tr>
                    </thead>
                    <tbody id="notes-table-body">
                        <!-- Rempli dynamiquement -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- TAB 3: RESULTATS -->
        <div id="tab-resultats" class="tab-content">
            <h2>R√©sultats du Concours (Note1 √ó3 + Note2 √ó1)</h2>

            <div class="button-group" style="margin-bottom: 20px;">
                <button onclick="exportToExcel()" class="action-button export-button excel">Exporter en CSV</button>
            </div>

            <h3>Matrice compl√®te</h3>
            <div class="table-container">
                <table id="scores-matrix">
                    <thead><tr><th>Candidat</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <!-- TAB 4: PODIUM -->
        <div id="tab-podium" class="tab-content">
            <h2>Classement Officiel</h2>
            
            <div style="margin-bottom: 20px;">
                <label for="result-limit" style="font-weight: 600; margin-right: 10px;">Nombre de candidats √† afficher:</label>
                <input type="number" id="result-limit" value="18" min="1" onchange="renderPodium()" style="width: 80px; padding: 8px; border: 2px solid var(--border-color); border-radius: 5px; background: var(--card-bg); color: var(--text-color);">
                <button onclick="exportPodiumToImage()" class="action-button export-button" style="margin-left: 10px;">Exporter en image</button>
            </div>

            <div class="table-container">
                <table id="podium-table">
                    <thead>
                        <tr><th>Rang</th><th>Candidat</th><th>Score Pond√©r√©</th><th>Statut</th></tr>
                    </thead>
                    <tbody id="podium-body"></tbody>
                </table>
            </div>
        </div>

        <!-- TAB 5: REINITIALISER -->
        <div id="tab-reinitialiser" class="tab-content">
            <h2>Zone de Danger</h2>
            <p style="color: var(--danger-color); font-weight: 600; margin-bottom: 20px;">
                ‚ö†Ô∏è Attention: Ces actions sont irr√©versibles !
            </p>

            <div class="reset-zone" style="background: var(--info-bg-start); border: 2px solid var(--primary);">
                <h3 style="color: var(--primary);">üîß Utilitaires</h3>
                <p>Nettoyer les anciennes valeurs calcul√©es stock√©es en base (utile si les totaux sont incorrects). Les scores pond√©r√©s sont maintenant toujours calcul√©s √† la vol√©e.</p>
                <button onclick="recalculateAllScores()" class="action-button" style="background: var(--primary);">Nettoyer la base de donn√©es</button>
                
                <p style="margin-top: 15px;">Supprimer les doublons de scores (un m√™me jury ayant not√© plusieurs fois le m√™me candidat).</p>
                <button onclick="removeDuplicateScores()" class="action-button" style="background: var(--warning-color); color: #212529;">Supprimer les doublons</button>
            </div>

            <div class="reset-zone">
                <h3>Supprimer un jury sp√©cifique</h3>
                <p>Supprime toutes les notations d'un jury sp√©cifique.</p>
                <div style="margin-bottom: 15px;">
                    <select id="jury-to-delete" style="padding: 10px; border: 2px solid var(--border-color); border-radius: 5px; background: var(--card-bg); color: var(--text-color); font-family: inherit; min-width: 200px;">
                        <option value="">-- S√©lectionner un jury --</option>
                    </select>
                </div>
                <button onclick="confirmDeleteJury()" class="action-button">Supprimer ce jury</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px;">
                <h3>Supprimer TOUS les jurys</h3>
                <p>Supprime toutes les notations de tous les jurys (mais conserve la liste des candidats).</p>
                <button onclick="confirmDeleteAllJuries()" class="action-button" style="background: var(--warning-color); color: #212529;">Supprimer tous les jurys</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px;">
                <h3>R√©initialiser les scores</h3>
                <p>Remet toutes les notations √† "-" mais conserve la structure (jurys et candidats).</p>
                <button onclick="confirmResetScores()" class="action-button">R√©initialiser les scores uniquement</button>
            </div>

            <div class="reset-zone" style="margin-top: 30px;">
                <h3>R√©initialisation compl√®te</h3>
                <p>Supprime TOUS les candidats ET toutes les notations. Remet l'application √† z√©ro.</p>
                <button onclick="confirmResetAll()" class="action-button">R√âINITIALISER TOUT (Candidats + Scores)</button>
            </div>
        </div>
    </div>

    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script type="module">
        import { db } from './firebase-init.js';
        import { collection, getDocs, deleteDoc, doc, setDoc, getDoc, addDoc, query, where } from "https://www.gstatic.com/firebasejs/10.1.0/firebase-firestore.js";

        let CANDIDATES = [];
        let aggregatedData = {};
        let candidateLocks = {}; // {candidateId: {juryName: boolean}}

        // --- TAB SWITCHING ---
        window.switchTab = function(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(`tab-${tabName}`).classList.add('active');
            event.target.classList.add('active');
            
            // Load tab-specific data
            if (tabName === 'candidats') {
                renderCandidateTable();
            } else if (tabName === 'notes') {
                renderNotesTable();
            } else if (tabName === 'resultats') {
                loadResults();
            } else if (tabName === 'podium') {
                loadResults();
            } else if (tabName === 'reinitialiser') {
                populateJuryDropdown();
            }
        };

        // --- GESTION CANDIDATS ---
        const loadList = async () => {
            const snap = await getDoc(doc(db, "candidats", "liste_actuelle"));
            if (snap.exists()) {
                CANDIDATES = snap.data().candidates || [];
                document.getElementById('candidate-names').value = CANDIDATES.map(c => c.name).join('\n');
                renderCandidateTable();
            }
            
            // Charger les verrous
            const lockSnap = await getDoc(doc(db, "config", "locks"));
            if (lockSnap.exists()) {
                candidateLocks = lockSnap.data().locks || {};
            }
        };

        window.importCandidates = async () => {
            const names = document.getElementById('candidate-names').value.split('\n').map(n => n.trim()).filter(n => n !== "");
            if (names.length === 0) {
                alert("Veuillez entrer au moins un candidat");
                return;
            }
            
            const list = names.map((n, i) => ({ id: `C${i+1}`, name: n }));
            await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: list });
            alert(`${names.length} candidat(s) import√©(s) !`);
            CANDIDATES = list;
            renderCandidateTable();
        };

        window.addCandidate = () => {
            const name = prompt("Nom du nouveau candidat:");
            if (!name || !name.trim()) return;
            
            const newId = `C${CANDIDATES.length + 1}`;
            CANDIDATES.push({ id: newId, name: name.trim() });
            saveCandidates();
        };

        window.deleteCandidate = async (candidateId) => {
            if (!confirm(`Supprimer ce candidat et toutes ses notes ?`)) return;
            
            CANDIDATES = CANDIDATES.filter(c => c.id !== candidateId);
            
            // Supprimer aussi les scores de ce candidat
            const scoresQuery = query(collection(db, "scores"), where("candidateId", "==", candidateId));
            const scoresSnap = await getDocs(scoresQuery);
            for (const scoreDoc of scoresSnap.docs) {
                await deleteDoc(doc(db, "scores", scoreDoc.id));
            }
            
            saveCandidates();
        };

        window.updateCandidateName = (candidateId, newName) => {
            const candidate = CANDIDATES.find(c => c.id === candidateId);
            if (candidate) {
                candidate.name = newName;
                saveCandidates();
            }
        };

        async function saveCandidates() {
            await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: CANDIDATES });
            renderCandidateTable();
        }

        function renderCandidateTable() {
            const tbody = document.getElementById('candidate-table-body');
            tbody.innerHTML = '';
            
            CANDIDATES.forEach(candidate => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${candidate.id}</td>
                    <td><input type="text" value="${candidate.name}" onchange="updateCandidateName('${candidate.id}', this.value)"></td>
                    <td class="actions">
                        <button class="icon-btn delete" onclick="deleteCandidate('${candidate.id}')" title="Supprimer">üóëÔ∏è</button>
                    </td>
                `;
            });
        }

        loadList();

        // --- GESTION NOTES ---
        async function renderNotesTable() {
            const tbody = document.getElementById('notes-table-body');
            const thead = document.querySelector('#notes-table thead tr');
            tbody.innerHTML = '';
            
            // Charger tous les scores
            const querySnapshot = await getDocs(collection(db, "scores"));
            const scoresByCandidate = {};
            const juries = new Set();
            
            querySnapshot.forEach(docSnap => {
                const data = docSnap.data();
                juries.add(data.juryName);
                if (!scoresByCandidate[data.candidateId]) {
                    scoresByCandidate[data.candidateId] = {};
                }
                scoresByCandidate[data.candidateId][data.juryName] = {
                    id: docSnap.id,
                    score1: data.score1,
                    score2: data.score2
                };
            });
            
            const sortedJuries = Array.from(juries).sort();
            
            // Construire l'en-t√™te avec bouton lock/unlock all
            thead.innerHTML = `
                <th class="col-actions">
                    Actions<br>
                    <button class="icon-btn" onclick="toggleAllLocks()" title="Verrouiller/D√©verrouiller tout" style="font-size: 0.9em; margin-top: 5px;">üîí Tout</button>
                </th>
                <th class="col-candidate">Candidat</th>
                ${sortedJuries.map(j => `<th colspan="2" class="col-score">${j}<br><small>(Fond | Forme)</small></th>`).join('')}
            `;
            
            // Construire les lignes
            CANDIDATES.forEach(candidate => {
                const row = tbody.insertRow();
                const isLocked = candidateLocks[candidate.id] || {};
                
                // Actions
                const actionsCell = row.insertCell();
                actionsCell.className = 'col-actions';
                actionsCell.innerHTML = `
                    <button class="icon-btn reset" onclick="resetCandidateScores('${candidate.id}')" title="R√©initialiser √† '-'">üîÑ</button>
                    <button class="icon-btn lock ${Object.keys(isLocked).length > 0 ? 'locked' : ''}" onclick="toggleCandidateLock('${candidate.id}')" title="Verrouiller/D√©verrouiller">üîí</button>
                `;
                
                // Nom du candidat
                const nameCell = row.insertCell();
                nameCell.className = 'candidate-name col-candidate';
                nameCell.textContent = candidate.name;
                
                // Notes par jury
                sortedJuries.forEach(jury => {
                    const scores = scoresByCandidate[candidate.id]?.[jury];
                    const locked = isLocked[jury] || false;
                    
                    const cell1 = row.insertCell();
                    const cell2 = row.insertCell();
                    cell1.className = 'col-score';
                    cell2.className = 'col-score';
                    
                    // Si verrouill√© ET qu'il n'y a pas de scores, afficher le cadenas
                    // Sinon, afficher les scores (existants ou dropdowns vides)
                    if (locked && !scores) {
                        cell1.className += ' locked-cell';
                        cell2.className += ' locked-cell';
                        cell1.textContent = 'üîí';
                        cell2.textContent = 'üîí';
                    } else if (scores) {
                        cell1.innerHTML = createScoreDropdown(scores.id, 'score1', scores.score1, candidate.id, jury);
                        cell2.innerHTML = createScoreDropdown(scores.id, 'score2', scores.score2, candidate.id, jury);
                    } else {
                        cell1.innerHTML = createScoreDropdown(null, 'score1', '-', candidate.id, jury);
                        cell2.innerHTML = createScoreDropdown(null, 'score2', '-', candidate.id, jury);
                    }
                });
            });
        }

        function createScoreDropdown(scoreId, field, currentValue, candidateId, juryName) {
            const options = ['-', '5', '10', '15', '20', 'Elimine'];
            const selectId = `score-${candidateId}-${juryName}-${field}`;
            
            let html = `<select id="${selectId}" onchange="handleScoreChange('${scoreId}', '${field}', this.value, '${candidateId}', '${juryName}')">`;
            options.forEach(opt => {
                const selected = opt === String(currentValue) ? 'selected' : '';
                html += `<option value="${opt}" ${selected}>${opt}</option>`;
            });
            html += '</select>';
            return html;
        }

        window.handleScoreChange = async function(scoreId, field, value, candidateId, juryName) {
            if (value === '-') {
                // Supprimer le score s'il existe
                if (scoreId && scoreId !== 'null') {
                    await deleteDoc(doc(db, "scores", scoreId));
                }
            } else {
                // Cr√©er ou mettre √† jour le score
                if (scoreId && scoreId !== 'null') {
                    await updateScore(scoreId, field, value);
                } else {
                    await createScore(candidateId, juryName, field, value);
                }
            }
            // Rafra√Æchir les deux onglets
            renderNotesTable();
            await loadResults();
        };

        async function createScore(candidateId, juryName, field, value) {
            // V√©rifier si un score existe d√©j√†
            const q = query(collection(db, "scores"), 
                where("candidateId", "==", candidateId),
                where("juryName", "==", juryName));
            const snap = await getDocs(q);
            
            if (snap.empty) {
                // Cr√©er nouveau score (sans totalWeightedScore - calcul√© √† la vol√©e)
                const data = {
                    candidateId: candidateId,
                    juryName: juryName,
                    score1: field === 'score1' ? value : '-',
                    score2: field === 'score2' ? value : '-',
                    timestamp: new Date()
                };
                
                await addDoc(collection(db, "scores"), data);
            } else {
                // Si des doublons existent, les nettoyer
                if (snap.docs.length > 1) {
                    console.warn(`‚ö†Ô∏è ${snap.docs.length} doublons trouv√©s pour ${candidateId}/${juryName}, nettoyage...`);
                    // Garder le plus r√©cent, supprimer les autres
                    const sorted = snap.docs.sort((a, b) => {
                        const timeA = a.data().timestamp?.toDate?.() || new Date(0);
                        const timeB = b.data().timestamp?.toDate?.() || new Date(0);
                        return timeB - timeA;
                    });
                    
                    // Supprimer tous sauf le premier (le plus r√©cent)
                    for (let i = 1; i < sorted.length; i++) {
                        await deleteDoc(doc(db, "scores", sorted[i].id));
                    }
                }
                
                // Mettre √† jour le score existant (ou le seul restant apr√®s nettoyage)
                const scoreDoc = snap.docs[0];
                await updateScore(scoreDoc.id, field, value);
            }
        }

        window.updateScore = async (scoreId, field, value) => {
            try {
                const scoreRef = doc(db, "scores", scoreId);
                const scoreSnap = await getDoc(scoreRef);
                
                if (!scoreSnap.exists()) return;
                
                const data = scoreSnap.data();
                data[field] = value;
                
                // Ne pas stocker totalWeightedScore - il sera calcul√© √† la vol√©e
                delete data.totalWeightedScore;
                
                await setDoc(scoreRef, data);
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la mise √† jour: ' + e.message);
            }
        };

        window.resetCandidateScores = async (candidateId) => {
            if (!confirm('R√©initialiser toutes les notes de ce candidat √† "-" ?')) return;
            
            const scoresQuery = query(collection(db, "scores"), where("candidateId", "==", candidateId));
            const scoresSnap = await getDocs(scoresQuery);
            
            for (const scoreDoc of scoresSnap.docs) {
                const data = scoreDoc.data();
                data.score1 = '-';
                data.score2 = '-';
                // Ne pas stocker totalWeightedScore - calcul√© √† la vol√©e
                delete data.totalWeightedScore;
                await setDoc(doc(db, "scores", scoreDoc.id), data);
            }
            
            // D√©verrouiller automatiquement ce candidat apr√®s r√©initialisation
            if (candidateLocks[candidateId]) {
                delete candidateLocks[candidateId];
                await setDoc(doc(db, "config", "locks"), { locks: candidateLocks });
            }
            
            alert('Notes r√©initialis√©es √† "-"\nLe candidat a √©t√© d√©verrouill√© automatiquement.');
            renderNotesTable();
            await loadResults();
        };

        window.toggleAllLocks = async () => {
            // Compter combien de candidats ont des scores non-set (-)
            const querySnapshot = await getDocs(collection(db, "scores"));
            const scoresByCandidate = {};
            const juries = new Set();
            
            querySnapshot.forEach(docSnap => {
                const data = docSnap.data();
                juries.add(data.juryName);
                if (!scoresByCandidate[data.candidateId]) {
                    scoresByCandidate[data.candidateId] = {};
                }
                scoresByCandidate[data.candidateId][data.juryName] = {
                    score1: data.score1,
                    score2: data.score2
                };
            });
            
            const sortedJuries = Array.from(juries).sort();
            let hasUnlockedNonSet = false;
            
            // V√©rifier s'il y a des scores "-" non verrouill√©s
            CANDIDATES.forEach(candidate => {
                const isLocked = candidateLocks[candidate.id] || {};
                sortedJuries.forEach(jury => {
                    const scores = scoresByCandidate[candidate.id]?.[jury];
                    const locked = isLocked[jury] || false;
                    
                    if (!locked && (!scores || scores.score1 === '-' || scores.score2 === '-')) {
                        hasUnlockedNonSet = true;
                    }
                });
            });
            
            // Toggle: si des non-set sont d√©verrouill√©s -> verrouiller tout
            // sinon -> d√©verrouiller tout
            if (hasUnlockedNonSet) {
                // Verrouiller tous les "-"
                CANDIDATES.forEach(candidate => {
                    if (!candidateLocks[candidate.id]) {
                        candidateLocks[candidate.id] = {};
                    }
                    sortedJuries.forEach(jury => {
                        const scores = scoresByCandidate[candidate.id]?.[jury];
                        if (!scores || scores.score1 === '-' || scores.score2 === '-') {
                            candidateLocks[candidate.id][jury] = true;
                        }
                    });
                });
            } else {
                // D√©verrouiller tout
                candidateLocks = {};
            }
            
            await setDoc(doc(db, "config", "locks"), { locks: candidateLocks });
            renderNotesTable();
        };

        window.toggleCandidateLock = async (candidateId) => {
            const allJuriesLocked = candidateLocks[candidateId] && Object.keys(candidateLocks[candidateId]).length > 0;
            
            if (allJuriesLocked) {
                // D√©verrouiller tous les jurys pour ce candidat
                delete candidateLocks[candidateId];
            } else {
                // Verrouiller uniquement les jurys qui n'ont pas encore de notes pour ce candidat
                const querySnapshot = await getDocs(collection(db, "scores"));
                const juries = new Set();
                const existingScores = new Set(); // Pour stocker les combinaisons candidat-jury qui ont d√©j√† des scores
                
                querySnapshot.forEach(d => {
                    const data = d.data();
                    juries.add(data.juryName);
                    
                    // Si ce jury a d√©j√† not√© ce candidat avec des vraies notes (pas juste "-"), on le marque
                    if (data.candidateId === candidateId) {
                        const hasRealScores = (data.score1 && data.score1 !== '-') || 
                                             (data.score2 && data.score2 !== '-');
                        if (hasRealScores) {
                            existingScores.add(data.juryName);
                        }
                    }
                });
                
                candidateLocks[candidateId] = {};
                
                // Ne verrouiller que les jurys qui n'ont pas encore de scores r√©els
                Array.from(juries).forEach(jury => {
                    if (!existingScores.has(jury)) {
                        candidateLocks[candidateId][jury] = true;
                    }
                });
            }
            
            await setDoc(doc(db, "config", "locks"), { locks: candidateLocks });
            renderNotesTable();
        };

        // --- CALCUL DES SCORES ---
        window.loadResults = async () => {
            const querySnapshot = await getDocs(collection(db, "scores"));
            aggregatedData = {};
            const juries = new Set();

            CANDIDATES.forEach(c => {
                aggregatedData[c.id] = { name: c.name, total: 0, juryScores: {}, elimCount: 0, hasScores: false };
            });

            // Utiliser un Set pour d√©tecter et √©viter les doublons
            const processedKeys = new Set();

            querySnapshot.forEach(doc => {
                const data = doc.data();
                const key = `${data.candidateId}_${data.juryName}`;
                
                // Ignorer les doublons (garder seulement le premier rencontr√©)
                if (processedKeys.has(key)) {
                    console.warn(`‚ö†Ô∏è Doublon ignor√©: ${key}`);
                    return;
                }
                processedKeys.add(key);
                
                if (aggregatedData[data.candidateId]) {
                    juries.add(data.juryName);
                    aggregatedData[data.candidateId].hasScores = true;
                    aggregatedData[data.candidateId].juryScores[data.juryName] = data;
                    
                    if (data.score1 === "Elimine") {
                        aggregatedData[data.candidateId].elimCount++;
                    } else {
                        // TOUJOURS calculer le score pond√©r√© √† partir des scores bruts
                        // IGNORER compl√®tement toute valeur totalWeightedScore stock√©e
                        let weightedScore = 0;
                        if (data.score1 && data.score1 !== '-' && 
                            data.score2 && data.score2 !== '-' &&
                            data.score1 !== 'Elimine' && data.score2 !== 'Elimine') {
                            weightedScore = (parseInt(data.score1) * 3) + parseInt(data.score2);
                            console.log(`Candidat ${data.candidateId}, Jury ${data.juryName}: ${data.score1}√ó3 + ${data.score2} = ${weightedScore} (DB avait: ${data.totalWeightedScore})`);
                        }
                        aggregatedData[data.candidateId].total += weightedScore;
                    }
                }
            });

            renderMatrix(Array.from(juries).sort());
            renderPodium();
        };

        function renderMatrix(sortedJuries) {
            const thead = document.querySelector("#scores-matrix thead tr");
            const tbody = document.querySelector("#scores-matrix tbody");
            thead.innerHTML = "<th>Candidat</th>" + sortedJuries.map(j => `<th>${j}</th>`).join('') + "<th>Total</th>";
            tbody.innerHTML = "";

            CANDIDATES.forEach(c => {
                const data = aggregatedData[c.id];
                const row = tbody.insertRow();
                row.insertCell().innerHTML = `<b>${c.name}</b>`;
                
                sortedJuries.forEach(j => {
                    const scoreObj = data.juryScores[j];
                    const cell = row.insertCell();
                    if (scoreObj) {
                        if (scoreObj.score1 === "Elimine") {
                            cell.className = "eliminado";
                            cell.textContent = "√âLIMIN√â";
                        } else {
                            // Recalculer le weighted score pour l'affichage
                            let displayWeightedScore = 0;
                            if (scoreObj.score1 && scoreObj.score1 !== '-' && 
                                scoreObj.score2 && scoreObj.score2 !== '-' &&
                                scoreObj.score1 !== 'Elimine' && scoreObj.score2 !== 'Elimine') {
                                displayWeightedScore = (parseInt(scoreObj.score1) * 3) + parseInt(scoreObj.score2);
                            }
                            cell.innerHTML = `<span class="detail-note">${scoreObj.score1} | ${scoreObj.score2}</span><span class="weighted-total">${displayWeightedScore}</span>`;
                        }
                    } else { cell.textContent = "-"; }
                });
                const totalCell = row.insertCell();
                totalCell.className = "total-score";
                totalCell.textContent = data.total;
            });
        }

        function renderPodium() {
            const body = document.getElementById('podium-body');
            body.innerHTML = "";
            let list = Object.values(aggregatedData).filter(c => c.hasScores).sort((a,b) => b.total - a.total);
            
            // Limiter le nombre de r√©sultats affich√©s
            const limit = parseInt(document.getElementById('result-limit')?.value || 18);
            list = list.slice(0, limit);
            
            list.forEach((c, i) => {
                const row = body.insertRow();
                if (c.elimCount >= 3) row.className = "eliminated-row";
                else if (i === 0) row.className = "rank-1";
                else if (i === 1) row.className = "rank-2";
                else if (i === 2) row.className = "rank-3";

                row.insertCell().textContent = c.elimCount >= 3 ? "‚Äî" : i + 1;
                row.insertCell().textContent = c.name;
                row.insertCell().textContent = c.total;
                row.insertCell().textContent = c.elimCount >= 3 ? `√âLIMIN√â (${c.elimCount} jurys)` : "Qualifi√©";
            });
        }

        // Supprimer les doublons de scores
        window.removeDuplicateScores = async () => {
            if (!confirm('Rechercher et supprimer les doublons de scores ?\n\nPour chaque combinaison candidat+jury, seule la note la plus r√©cente sera conserv√©e.')) {
                return;
            }
            
            try {
                const querySnapshot = await getDocs(collection(db, "scores"));
                
                // Grouper par candidat+jury
                const scoresByKey = {};
                querySnapshot.forEach(doc => {
                    const data = doc.data();
                    const key = `${data.candidateId}_${data.juryName}`;
                    
                    if (!scoresByKey[key]) {
                        scoresByKey[key] = [];
                    }
                    scoresByKey[key].push({ id: doc.id, data: data, timestamp: data.timestamp });
                });
                
                // Trouver et supprimer les doublons
                let duplicatesFound = 0;
                let duplicatesRemoved = 0;
                
                for (const key in scoresByKey) {
                    const scores = scoresByKey[key];
                    if (scores.length > 1) {
                        duplicatesFound += scores.length - 1;
                        console.log(`Doublon trouv√© pour ${key}: ${scores.length} entr√©es`);
                        
                        // Trier par timestamp (le plus r√©cent en premier)
                        scores.sort((a, b) => {
                            const timeA = a.timestamp?.toDate?.() || new Date(0);
                            const timeB = b.timestamp?.toDate?.() || new Date(0);
                            return timeB - timeA;
                        });
                        
                        // Garder le premier (le plus r√©cent), supprimer les autres
                        for (let i = 1; i < scores.length; i++) {
                            console.log(`Suppression de l'ancien score: ${scores[i].id}`, scores[i].data);
                            await deleteDoc(doc(db, "scores", scores[i].id));
                            duplicatesRemoved++;
                        }
                    }
                }
                
                alert(`‚úì Nettoyage des doublons termin√© !\n${duplicatesFound} doublon(s) trouv√©(s)\n${duplicatesRemoved} doublon(s) supprim√©(s)`);
                
                // Rafra√Æchir l'affichage
                renderNotesTable();
                await loadResults();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors du nettoyage des doublons: ' + e.message);
            }
        };

        // Nettoyer les valeurs calcul√©es obsol√®tes de la base de donn√©es
        window.recalculateAllScores = async () => {
            if (!confirm('Nettoyer les valeurs calcul√©es obsol√®tes en base de donn√©es ?\n\nLes scores pond√©r√©s seront d√©sormais toujours calcul√©s √† la vol√©e.')) {
                return;
            }
            
            try {
                const querySnapshot = await getDocs(collection(db, "scores"));
                let cleaned = 0;
                
                for (const scoreDoc of querySnapshot.docs) {
                    const data = scoreDoc.data();
                    
                    // Supprimer totalWeightedScore s'il existe
                    if ('totalWeightedScore' in data) {
                        delete data.totalWeightedScore;
                        await setDoc(doc(db, "scores", scoreDoc.id), data);
                        cleaned++;
                    }
                }
                
                alert(`‚úì Nettoyage termin√© !\n${cleaned} enregistrement(s) nettoy√©(s).\n\nLes totaux sont maintenant calcul√©s correctement.`);
                
                // Rafra√Æchir l'affichage
                renderNotesTable();
                await loadResults();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors du nettoyage: ' + e.message);
            }
        };

        window.confirmDeleteJury = async () => {
            const jurySelect = document.getElementById('jury-to-delete');
            const juryName = jurySelect.value;
            
            if (!juryName) {
                alert('Veuillez s√©lectionner un jury');
                return;
            }
            
            if (!confirm(`Supprimer TOUTES les notes du jury "${juryName}" ?\n\nCette action est irr√©versible.`)) {
                return;
            }
            
            try {
                const q = query(collection(db, "scores"), where("juryName", "==", juryName));
                const snap = await getDocs(q);
                
                for (const d of snap.docs) {
                    await deleteDoc(doc(db, "scores", d.id));
                }
                
                // Supprimer aussi les verrous pour ce jury
                Object.keys(candidateLocks).forEach(candidateId => {
                    if (candidateLocks[candidateId][juryName]) {
                        delete candidateLocks[candidateId][juryName];
                        if (Object.keys(candidateLocks[candidateId]).length === 0) {
                            delete candidateLocks[candidateId];
                        }
                    }
                });
                await setDoc(doc(db, "config", "locks"), { locks: candidateLocks });
                
                alert(`Jury "${juryName}" supprim√© avec succ√®s`);
                location.reload();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la suppression: ' + e.message);
            }
        };

        window.confirmDeleteAllJuries = async () => {
            if (!confirm(`‚ö†Ô∏è ATTENTION ‚ö†Ô∏è\n\nSupprimer TOUTES les notations de TOUS les jurys ?\n\nLa liste des candidats sera conserv√©e.\n\nCette action est IRR√âVERSIBLE !`)) {
                return;
            }
            
            // Double confirmation
            if (!confirm(`√ätes-vous VRAIMENT s√ªr ?\n\nToutes les notes de tous les jurys seront supprim√©es d√©finitivement.`)) {
                return;
            }
            
            try {
                const querySnapshot = await getDocs(collection(db, "scores"));
                let deletedCount = 0;
                
                for (const d of querySnapshot.docs) {
                    await deleteDoc(doc(db, "scores", d.id));
                    deletedCount++;
                }
                
                // Supprimer tous les verrous
                candidateLocks = {};
                await setDoc(doc(db, "config", "locks"), { locks: {} });
                
                alert(`‚úì Tous les jurys supprim√©s avec succ√®s\n${deletedCount} notation(s) supprim√©e(s)`);
                location.reload();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la suppression: ' + e.message);
            }
        };

        async function populateJuryDropdown() {
            const querySnapshot = await getDocs(collection(db, "scores"));
            const juries = new Set();
            
            querySnapshot.forEach(doc => {
                juries.add(doc.data().juryName);
            });
            
            const select = document.getElementById('jury-to-delete');
            select.innerHTML = '<option value="">-- S√©lectionner un jury --</option>';
            
            Array.from(juries).sort().forEach(jury => {
                const option = document.createElement('option');
                option.value = jury;
                option.textContent = jury;
                select.appendChild(option);
            });
        }

        window.confirmResetScores = async () => {
            if(!confirm("Supprimer TOUTES les notes (les candidats seront conserv√©s) ?")) return;
            
            try {
                const snap = await getDocs(collection(db, "scores"));
                for (const d of snap.docs) { 
                    await deleteDoc(doc(db, "scores", d.id)); 
                }
                
                // R√©initialiser les verrous
                await setDoc(doc(db, "config", "locks"), { locks: {} });
                candidateLocks = {};
                
                alert('Toutes les notes ont √©t√© supprim√©es');
                location.reload();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la r√©initialisation: ' + e.message);
            }
        };

        window.confirmResetAll = async () => {
            const confirmation = prompt('Pour confirmer la r√©initialisation TOTALE, tapez "RESET":');
            if (confirmation !== 'RESET') {
                alert('R√©initialisation annul√©e');
                return;
            }
            
            try {
                // Supprimer les scores
                const scoresSnap = await getDocs(collection(db, "scores"));
                for (const d of scoresSnap.docs) { 
                    await deleteDoc(doc(db, "scores", d.id)); 
                }
                
                // Supprimer les candidats
                await setDoc(doc(db, "candidats", "liste_actuelle"), { candidates: [] });
                
                // R√©initialiser les verrous
                await setDoc(doc(db, "config", "locks"), { locks: {} });
                
                alert('R√©initialisation compl√®te effectu√©e');
                location.reload();
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la r√©initialisation: ' + e.message);
            }
        };

        // Export vers CSV
        window.exportToExcel = () => {
            if (!CANDIDATES.length || !Object.keys(aggregatedData).length) {
                alert('Veuillez d\'abord charger les r√©sultats (bouton "Charger et Calculer")');
                return;
            }

            // R√©cup√©rer les jurys
            const juries = new Set();
            Object.values(aggregatedData).forEach(candidate => {
                Object.keys(candidate.juryScores).forEach(jury => juries.add(jury));
            });
            const sortedJuries = Array.from(juries).sort();

            // Cr√©er l'en-t√™te CSV
            let csv = 'Candidat,' + sortedJuries.join(',') + ',Total,Statut\n';

            // Ajouter les donn√©es des candidats
            CANDIDATES.forEach(c => {
                const data = aggregatedData[c.id];
                if (!data.hasScores) return;

                let row = `"${c.name}",`;
                
                // Scores par jury
                sortedJuries.forEach((jury, index) => {
                    const scoreObj = data.juryScores[jury];
                    if (scoreObj) {
                        if (scoreObj.score1 === "Elimine") {
                            row += '√âLIMIN√â';
                        } else {
                            // Recalculer le score pond√©r√© pour l'export
                            let weightedScore = 0;
                            if (scoreObj.score1 && scoreObj.score1 !== '-' && 
                                scoreObj.score2 && scoreObj.score2 !== '-' &&
                                scoreObj.score1 !== 'Elimine' && scoreObj.score2 !== 'Elimine') {
                                weightedScore = (parseInt(scoreObj.score1) * 3) + parseInt(scoreObj.score2);
                            }
                            row += `"${scoreObj.score1}|${scoreObj.score2} (${weightedScore})"`;
                        }
                    } else {
                        row += '-';
                    }
                    if (index < sortedJuries.length - 1) row += ',';
                });

                // Total et statut
                row += `,${data.total}`;
                row += data.elimCount >= 3 ? ',√âLIMIN√â' : ',Qualifi√©';
                csv += row + '\n';
            });

            // T√©l√©charger le fichier
            const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            const date = new Date().toISOString().split('T')[0];
            link.setAttribute('href', url);
            link.setAttribute('download', `resultats_concours_${date}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };

        // Export du podium en image
        window.exportPodiumToImage = async () => {
            const podiumTable = document.getElementById('podium-table');
            
            if (!podiumTable || !podiumTable.querySelector('tbody').children.length) {
                alert('Veuillez d\'abord charger les r√©sultats (bouton "Charger et Calculer")');
                return;
            }

            try {
                // V√©rifier si html2canvas est charg√©
                if (typeof html2canvas === 'undefined') {
                    alert('Erreur: html2canvas n\'est pas charg√©');
                    return;
                }

                // Cr√©er un conteneur temporaire avec le titre
                const container = document.createElement('div');
                container.style.padding = '30px';
                container.style.background = 'white';
                container.style.width = 'fit-content';
                
                const title = document.createElement('h1');
                title.textContent = 'Classement Officiel - Concours d\'√âloquence';
                title.style.color = '#007bff';
                title.style.textAlign = 'center';
                title.style.marginBottom = '20px';
                title.style.fontSize = '24px';
                
                const tableClone = podiumTable.cloneNode(true);
                tableClone.style.fontSize = '16px';
                
                container.appendChild(title);
                container.appendChild(tableClone);
                
                // Ajouter temporairement au document
                container.style.position = 'absolute';
                container.style.left = '-9999px';
                document.body.appendChild(container);

                // Capturer avec html2canvas
                const canvas = await html2canvas(container, {
                    backgroundColor: '#ffffff',
                    scale: 2, // Haute r√©solution
                    logging: false
                });

                // Supprimer le conteneur temporaire
                document.body.removeChild(container);

                // T√©l√©charger l'image
                const date = new Date().toISOString().split('T')[0];
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `podium_concours_${date}.png`;
                    link.click();
                    URL.revokeObjectURL(url);
                });

            } catch (e) {
                console.error('Erreur lors de l\'export:', e);
                alert('Erreur lors de la g√©n√©ration de l\'image: ' + e.message);
            }
        };

        // Modal pour changement de mot de passe
        window.showPasswordModal = async function() {
            try {
                // 1. Demander le mot de passe actuel
                const currentPassword = prompt('√âtape 1/3: Entrez le mot de passe actuel:');
                
                if (!currentPassword) {
                    return; // Annul√©
                }

                // V√©rifier le mot de passe actuel
                const adminDoc = await getDoc(doc(db, "config", "admin"));
                const storedPassword = adminDoc.exists() ? adminDoc.data().password : 'admin';

                if (currentPassword !== storedPassword) {
                    alert('Mot de passe actuel incorrect !');
                    return;
                }

                // 2. Demander le nouveau mot de passe
                const newPassword = prompt('√âtape 2/3: Entrez le nouveau mot de passe:\n(minimum 4 caract√®res)');
                
                if (!newPassword) {
                    return; // Annul√©
                }

                if (newPassword.length < 4) {
                    alert('Le mot de passe doit contenir au moins 4 caract√®res');
                    return;
                }

                // 3. Demander la confirmation
                const confirmPassword = prompt('√âtape 3/3: Confirmez le nouveau mot de passe:');
                
                if (!confirmPassword) {
                    return; // Annul√©
                }

                if (newPassword !== confirmPassword) {
                    alert('Les mots de passe ne correspondent pas !');
                    return;
                }

                // Tout est OK, changer le mot de passe
                await changeAdminPassword(newPassword);
                
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors de la v√©rification du mot de passe');
            }
        };

        // Changement du mot de passe administrateur
        async function changeAdminPassword(newPassword) {
            try {
                await setDoc(doc(db, "config", "admin"), { password: newPassword });
                alert('Mot de passe chang√© avec succ√®s !');
            } catch (e) {
                console.error('Erreur:', e);
                alert('Erreur lors du changement de mot de passe');
            }
        }

        // D√©connexion admin
        window.adminLogout = function() {
            if (confirm('Voulez-vous vous d√©connecter ?')) {
                window.location.href = 'index.html';
            }
        };

        // Theme Toggle Logic
        function initTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            const toggle = document.getElementById('theme-toggle');
            if (toggle) {
                if (savedTheme === 'dark') {
                    toggle.classList.add('active');
                }
            }
        }

        window.toggleTheme = function() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            
            const toggle = document.getElementById('theme-toggle');
            if (toggle) {
                if (newTheme === 'dark') {
                    toggle.classList.add('active');
                } else {
                    toggle.classList.remove('active');
                }
            }
        };

        window.toggleMenu = function() {
            const menu = document.getElementById('menu-content');
            if (menu) {
                menu.classList.toggle('active');
            }
        };

        // Close menu when clicking outside
        document.addEventListener('click', function(event) {
            const menu = document.getElementById('menu-content');
            const burgerIcon = document.querySelector('.burger-icon');
            if (menu && burgerIcon && !menu.contains(event.target) && !burgerIcon.contains(event.target)) {
                menu.classList.remove('active');
            }
        });

        // Initialize theme on page load
        initTheme();
    </script>
</body>
</html>